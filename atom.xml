<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou Zejin&#39;s Home</title>
  
  <subtitle>想象力比知识更重要！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-07T12:28:51.916Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhou Zejin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中的线程使用</title>
    <link href="http://yoursite.com/2018/02/07/Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/07/Android中的线程使用/</id>
    <published>2018-02-07T12:28:30.000Z</published>
    <updated>2018-02-07T12:28:51.916Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="进程和线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制</title>
    <link href="http://yoursite.com/2018/02/05/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/02/05/Android消息机制/</id>
    <published>2018-02-05T05:45:29.000Z</published>
    <updated>2018-02-07T12:25:38.581Z</updated>
    
    <content type="html"><![CDATA[<p>在Android系统中，主要有两种通信机制：Binder机制和消息机制。Binder机制用于跨进程通信，消息机制用于进程内部通信，也就是同一个进程中内部线程之间的通信。</p><h1 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h1><p>通常在工作线程中做完一些操作后需要更新UI，但是，UI控件不是线程安全的，不能直接在工作线程中更新UI。这时，工作线程需要通过UI线程的Handler对象向UI线程发送消息，通知UI线程去更新UI。这个过程的实质就是线程之间通过消息机制进行通信。</p><p>Android消息机制主要通过Handler实现，而Handler的运行需要MessageQueue和Looper配合。</p><p>MessageQueue是一个消息队列，采用链式队列的数据结构实现，用来存储Handler发送的消息。</p><p>Looper可以理解为消息循环，每个要处理消息的线程都拥有一个属于自己的Looper，这个Looper会以无限循环的方式查询MessageQueue，如果有消息，就通过消息对应的Handler对象处理消息，否则，就一直等待。</p><p>Handler有两个作用：一方面可以让其它线程通过Handler给拥有这个Handler对象的线程发送消息；另一方面可以在线程的Looper获取消息后，通过Handler处理这个消息。</p><p>需要注意的是，线程默认是没有Looper的，如果要使用Handler，必须先为线程创建一个Looper，并且，一个线程只能有一个Looper。不过，一个线程可以拥有多个Handler对象，这个并不影响Looper处理消息，因为不管是哪个Handler发送过来的消息，都一并存在MessageQueue，Looper只会串行获取这些消息进行处理。</p><h1 id="MessageQueue分析"><a href="#MessageQueue分析" class="headerlink" title="MessageQueue分析"></a>MessageQueue分析</h1><p>MessageQueue是一个链式队列，当消息过来时，会将消息对象Message插入到队列中；当要处理消息时，会读取队列中的消息，并删除已读取的消息。</p><p>MessageQueue通过enqueueMessage()方法插入消息，其源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// 消息队列为空，插入的消息处于队首，如果消息队列被阻塞，需要将其唤醒。</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在消息队列的中间位置插入消息。</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue通过next()方法读取并删除消息，其源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无线循环。</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 检索下一个Message，如果存在就返回这个Message。</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果队列中没有消息，进行阻塞，直到获取到下一个消息。</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// 下一个消息没有准备好，为其设置一个唤醒时间。</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取到下一个消息。</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="comment">// 删除当前获取的消息。</span></span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有更多消息了。</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Looper分析"><a href="#Looper分析" class="headerlink" title="Looper分析"></a>Looper分析</h1><p>Looper在消息机制中实现消息循环，具体来说，它会不停地从MessageQueue中查看是否有新消息，如果有就进行处理，没有就一直循环等待。</p><p>一个线程默认是没有Looper的，要让一个普通线程升级为Looper线程需要做一下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程初始化为Looper线程。</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他处理，如实例化handler。</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始循环处理消息队列。</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程并没有涉及到MessageQueue，这是因为Looper将MessageQueue进行了封装，开发者不需要直接与MessageQueue交互，这点可以从Looper的构造函数中看出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Looper.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Looper内的消息队列。</span></span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        <span class="comment">// 当前线程。</span></span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h2><p>prepare()方法用来为线程添加Looper对象，并且一个Thread只能有一个Looper对象，具体可以看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Looper.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sThreadLocal.get()会返回null除非调用了prepare()方法。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 试图在有Looper的线程中再次创建Looper将抛出异常。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，prepare()方法是通过ThreadLocal保证了每个线程只能有一个Looper对象。这里简单介绍下ThreadLocal的使用原理。</p><blockquote><p>ThreadLocal的使用原理</p></blockquote><p>ThreadLocal是一个创建线程局部变量的类。通常情况下，创建的变量是可以被任何一个线程访问并修改的，而使用ThreadLocal创建的变量，每个线程访问时都会获取其一个副本，这个副本只能在当前线程访问，其他线程无法访问和修改。ThreadLocal从本质上讲，是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p><blockquote><p><strong>注意</strong></p></blockquote><p>除了prepare()方法，Looper还提供了prepareMainLooper()方法专门为主线程（ActivityThread，也即UI线程）提供Looper对象，其本质也是通过prepare()方法创建Looper对象。不过，由于主线程的Looper对象比较特殊，Looper提供了一个getMainLooper()方法，通过这个方法可以在其它线程也能获取到主线程的Looper对象，所以，主线程的Looper对象不是ThreadLocal类型的。另外，Android系统在创建主线程的时候就已经为其初始化了Looper对象，所以，一般不需要另外调用prepareMainLooper()方法。</p><h2 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h2><p>loop()方法用来开启消息循环，只有调用了这个方法，Looper线程才能开始工作，其源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Looper.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">// 得到当前线程Looper。</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">// 得到当前Looper的MessageQueue。</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 开启无线循环。</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 去除Message，可能会被阻塞。</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有消息需要处理，退出无线循环。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// msg.target即发送这个消息的Handler对象，用这个Handler对象来处理消息。</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            msg.recycleUnchecked(); <span class="comment">// 回收消息资源。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，loop()方法是一个无线循环，不断从MessageQueue中获取消息并进行处理，唯一跳出循环的方式MessageQueue的next()方法返回了null。</p><p>loop()方法使用了myLooper()方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于ThreadLocal的原因，在任意线程调用Looper.myLooper()方法返回的都是当前线程的Looper对象。</p><h2 id="退出消息循环"><a href="#退出消息循环" class="headerlink" title="退出消息循环"></a>退出消息循环</h2><p>消息循环是可以退出的，Looper提供了quit()和quitSafely()方法来退出消息循环，这两个方法的区别是：quit()方法会直接退出消息循环；而quitSafely()方法只是设定了一个退出标记，只有当把消息队列中已有的消息处理完毕后才退出消息循环，这种方式比较安全。</p><p>如果在一个线程中创建Looper开启了消息循环，那么在任务完成后，需要主动退出消息循环，否则，该线程会一直处于等待状态，不会被终止。</p><h1 id="Handler分析"><a href="#Handler分析" class="headerlink" title="Handler分析"></a>Handler分析</h1><p>Handler用来向Looper的消息队列发送消息，在Looper获取这个消息后，会调用该Handler处理这个消息，这个过程是异步的。</p><h2 id="创建Handler"><a href="#创建Handler" class="headerlink" title="创建Handler"></a>创建Handler</h2><p>由于Handler需要向Looper的消息队列发送消息，所以，在初始化Handler时，需要关联一个Looper对象。但是，在一个线程中，通常直接使用Handler的无参构造函数去创建Handler对象，并没有直接让Handler对象与Looper对象关联。其实，关联是在这个构造函数中实现的，具体可以看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Handler.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Looper mLooper; <span class="comment">// 关联的Looper。</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue; <span class="comment">// 关联的MessageQueue。</span></span><br><span class="line">    <span class="keyword">final</span> Callback mCallback;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">// 默认将关联当前线程的Looper。</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Looper不能为空，即该默认的构造方法只能在拥有Looper的线程中使用。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，可以通过以下代码为在Looper线程中创建Handler对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler handler1;</span><br><span class="line">    <span class="keyword">private</span> Handler handler2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程初始化为Looper线程。</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实例化两个Handler。</span></span><br><span class="line">        handler1 = <span class="keyword">new</span> Handler();</span><br><span class="line">        handler2 = <span class="keyword">new</span> Handler();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始循环处理消息队列。</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，一个Looper线程能拥有多个Handler对象。加入多个Handler对象后，LooperThread的结构图如下所示：</p><p><img src="/uploads/android/LooperThread的结构.png" alt="LooperThread的结构"></p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>Handler创建完毕后，就可以使用post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和sendMessageDelayed(Message, long)等方法发送消息了。</p><p>通过这些API的参数看以看到，Handler不但可以发送Message对象，还能发送Runable对象，其实，Runable对象在底层也会被封装成Message对象发送给对应的消息队列。下面源码展示以post(Runnable)方法发送消息的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Handler.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// getPostMessage(r)将Runnable封装成Message。</span></span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r; <span class="comment">// 将Runnable设为Message的callback。</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Message的target必须设为当前Handler，因为Looper对象会用这个Handler对象处理此消息。</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis); <span class="comment">// 将消息插入到消息队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h2><p>发送消息后，在Looper.loop()方法中会调用<strong>msg.target.dispatchMessage(msg)</strong>方法来处理消息，这个target就发送消息的Handler对象。以下源码展示了Handler处理消息的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * frameworks/base/core/java/android/os/Handler.java</span></span><br><span class="line"><span class="comment"> * 开源项目:  Android       版本名称:  Nougat MR1     API Level:  25 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果Message设置了callback，即Runnable消息，处理callback。</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果Handler本身设置了callback，则执行callback。</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这种方式运行使用Handler handler = new Handler(callback)方式创建Handler；</span></span><br><span class="line">                <span class="comment">// 避免通过继承Handler重写handleMessage()方法。</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果Message没有callback，则调用Handler的handleMessage()方法。</span></span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理Runnable消息。</span></span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 使用Handler handler = new Handler(callback)方式创建Handler所使用的Callback接口。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 由子类实现的处理消息的方法，默认实现为空。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息机制通信的流程"><a href="#消息机制通信的流程" class="headerlink" title="消息机制通信的流程"></a>消息机制通信的流程</h1><p>经过以上分析，消息机制的原理已经很清楚了，下面以一幅图来展示消息机制通信的整个流程：</p><p><img src="/uploads/android/消息机制通信的流程.png" alt="消息机制通信的流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android系统中，主要有两种通信机制：Binder机制和消息机制。Binder机制用于跨进程通信，消息机制用于进程内部通信，也就是同一个进程中内部线程之间的通信。&lt;/p&gt;
&lt;h1 id=&quot;消息机制概述&quot;&gt;&lt;a href=&quot;#消息机制概述&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="进程和线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android中的IPC方式</title>
    <link href="http://yoursite.com/2018/02/02/Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/02/02/Android中的IPC方式/</id>
    <published>2018-02-02T08:05:28.000Z</published>
    <updated>2018-02-06T07:55:28.831Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Android中IPC的基本原理，这一篇文章详细介绍Android中各种跨进程通信的方式。</p><h1 id="IPC的方式"><a href="#IPC的方式" class="headerlink" title="IPC的方式"></a>IPC的方式</h1><p>具体方式有很多，但是，它们的使用场景有很大区别，下面对这些方式进行详细分析。</p><h2 id="使用Intent"><a href="#使用Intent" class="headerlink" title="使用Intent"></a>使用Intent</h2><p>Android中的四大组件有三大组件（Activity, Service, Receiver）都支持在Intent中传递Bundle数据。由于Bundle实现了Parcelable接口，所以，它能够在不同进程中进行传输。因此，当在一个进程中启动了另一个进程的Activity、Service和Receiver组件时，可以在Bundle中附加数据，并通过Intent发送给目标进程的组件，这样就实现了跨进程通信。</p><p>不过，在传输的过程中，所传输的数据必须支持序列化。比如基本数据类型，字符串，Parcelable的实现类和Serializable的实现类。</p><h2 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h2><p>文件共享式一种比较方便的跨进程通信方式，其原理是两个进程通过read/write同一个文件来交换数据。write文件的时候将对象序列化后保存到文件中，read文件的时候通过反序列化从文件中读取数据。</p><p>这种IPC方式对文件的格式没有具体要求，可以是txt、xml或者Json，只要是读写双方约定的格式即可。</p><p>不过这种方式存在并发read/write的问题，因此，使用这种方式时要尽量避免并发read/write文件的情况，或者使用线程同步的方式控制多个线程并发read/write文件。</p><h2 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h2><p>可以使用Messenger创建跨进程通信的接口，这种方式需要使用Handler响应不同的Message对象（这里涉及到<a href="/2018/02/05/Android消息机制/">Android消息机制</a>），因此，Handler是使用Messenger的基础。Messenger能够让服务端和客户端共享Binder对象，这样，客户端可以使用Messenger向服务端发送Message消息。另外，客户端也能定义一个Messenger，让服务端能够回传Message消息。</p><p>Messenger对AIDL做了封装，使用相对比较简单，不过，它是在一个线程中串行处理客户端请求，不需要考虑线程同步的问题。</p><p>以下是使用Messenger的主要步骤：</p><ol><li>在服务端实现一个Handler，用来处理客户端发送的消息；</li><li>在服务端使用步骤1中的Handler初始化Messenger对象；</li><li>在服务端的onBind()方法中，使用步骤2中的Messenger对象创建一个Binder对象，并返回给客户端；</li><li>在客户端中使用步骤3中的Binder对象初始化一个Messenger对象，它用来给服务端发送Message对象；</li><li>服务端接在Handler中接收到Message对象后，进行相应的处理；</li></ol><p>在服务端创建Messenger接口的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Command to the service to display a message */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SAY_HELLO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler of incoming messages from clients.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_SAY_HELLO:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"hello!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Target we publish for clients to send messages to IncomingHandler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When binding to the service, we return an interface to our messenger</span></span><br><span class="line"><span class="comment">     * for sending messages to the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">"binding"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端使用Binder对象创建Messenger对象，并发送消息的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityMessenger</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Messenger for communicating with the service. */</span></span><br><span class="line">    Messenger mService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flag indicating whether we have called bind on the service. */</span></span><br><span class="line">    <span class="keyword">boolean</span> mBound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class for interacting with the main interface of the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// established, giving us the object we can use to</span></span><br><span class="line">            <span class="comment">// interact with the service.  We are communicating with the</span></span><br><span class="line">            <span class="comment">// service using a Messenger, so here we get a client-side</span></span><br><span class="line">            <span class="comment">// representation of that from the raw IBinder object.</span></span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This is called when the connection with the service has been</span></span><br><span class="line">            <span class="comment">// unexpectedly disconnected -- that is, its process crashed.</span></span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// Create and send a message to the service, using a supported 'what' value</span></span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_SAY_HELLO, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to the service</span></span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class), mConnection,</span><br><span class="line">            Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例没有展示服务端如何回复客户端。不过，如果服务端需要回复客户端，有一点非常关键，那就是当客户端发送消息的时候，需要把接收服务器端回复的Messenger通过Message的replyTo参数传递给服务端，作为通信的桥梁。</p><p>通过Messenger进行IPC的原理图如下所示：</p><p><img src="/uploads/android/Messenger通信原理.png" alt="Messenger通信原理"></p><h2 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h2><p>Messenger串行处理客户端发送的消息，如果大量的消息同时发送到服务端，Messenger方式就不太合适了；同时，Messenger的主要作用是传递消息，如果要跨进程调用服务端方法，Messenger也无法做到。不过，AIDL可以实现这样的需求。</p><p>AIDL是一种接口定义语言，用于约束两个进程间的通讯规则，在进行IPC时，通信信息会被转换为AIDL协议消息，然后发送给对方，对方接收到AIDL协议消息后，再转换成相应的对象。</p><p>AIDL是由Binder机制实现的，Binder机制以在上一篇文章中介绍了，下面阐述如何使用AIDL进行IPC。</p><h3 id="创建aidl文件"><a href="#创建aidl文件" class="headerlink" title="创建aidl文件"></a>创建aidl文件</h3><p>可以使用Java语法定义aidl文件，每个文件必须定义一个interface，并将interface只能有一个，然后在interface声明调用的方法。</p><p>AIDL支持以下数据类型：</p><ul><li>所有Java支持的原子数据类型（比如int, long, char, boolean等）</li><li>String</li><li>CharSequence</li><li>List：只支持ArrayList，里面的每个元素都必须能被AIDL支持</li><li>Map：只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value</li><li>Parcelable：所有实现了Parcelable接口的对象</li><li>AIDL：所有AIDL接口本身也可以在AIDL文件中使用</li></ul><p>在定义AIDL接口时，需要注意以下几点：</p><ul><li>如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的aidl文件，并在其中声明为parcelable类型。</li><li>自定义的Parcelable对象和AIDL对象必须在aidl文件中要显示import，即使他们和当前的aidl文件定义在同一个包内。</li><li>AIDL除了原子数据类型外，其它类型的参数必须标明数据流动的方向：in、out或者inout，原子类型默认方向是in，并且不能被改变。</li><li>要根据具体情况标明参数的数据流动方向，不能一概使用inout，因为这在底层是有开销的。</li><li>AIDL接口只支持声明方法，不支持声明static常量，这一点与Java中的接口不一样。</li></ul><p>下面是一个定义AIDL接口的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.android;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Example service interface */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Request the process ID of this service, to do evil things with it. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>创建完AIDL接口后，Build项目，这时会根据aidl文件生成一个对应Java接口文件。这个接口包含了一个名为Stub的子类，它是一个Binder接口，服务端需要实现这个接口提供对应的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.myPid();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现AIDL接口定义的方法时，需要注意：</p><ul><li>要考虑多线程问题；</li><li>默认情况下，客户端调用服务端方法（RPC）是同步的，如果客户端的UI线程进行RPC，并且这个RPC比较耗时，会造成客户端ANR。所以，在需要的时候，在工作线程中进行RPC；</li><li>进行RPC时抛出的Exception不会被发送到客户端；</li></ul><h3 id="将接口暴露给客户端"><a href="#将接口暴露给客户端" class="headerlink" title="将接口暴露给客户端"></a>将接口暴露给客户端</h3><p>服务端实现AIDL接口后，需要将接口暴露给客户端。一般是通过Service组件，在其onBind()方法中将实现的Binder接口返回给客户端，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return the interface</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Process.myPid();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Does nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户端和服务端属于不同的项目，需要将服务端的aidl文件复制到客户端，这时客户端才能声明AIDL定义的接口，并进行使用。</p><p>当客户端调用bindService()方法连接服务端时，onServiceConnected()回调方法会接收到服务端返回的Binder接口，将其转换为AIDL定义接口后，就可以调用服务端对应的方法了，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IRemoteService mIRemoteService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="comment">// Called when the connection with the service is established</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Following the example above for an AIDL interface,</span></span><br><span class="line">        <span class="comment">// this gets an instance of the IRemoteInterface, which we can use to call on the service</span></span><br><span class="line">        mIRemoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the connection with the service disconnects unexpectedly</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Service has unexpectedly disconnected"</span>);</span><br><span class="line">        mIRemoteService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AIDL的进阶使用"><a href="#AIDL的进阶使用" class="headerlink" title="AIDL的进阶使用"></a>AIDL的进阶使用</h3><h4 id="跨进程监听器"><a href="#跨进程监听器" class="headerlink" title="跨进程监听器"></a>跨进程监听器</h4><p>通常会有这样的需求：客户端需要使用监听器去监听服务端数据的变化，然后做相应的处理。一般来说，会这样实现这个需求：客户端向服务端注册一个监听器，注册成功后，服务器在数据变化时，回调监听器里面的方法通知客户端数据发生变化；当客户端不需要数据监听数据变化时，就会向服务器注销这个监听器。</p><p>在AIDL中，需要使用AIDL接口定义监听器，然后，在服务器的AIDL接口中定义registerListener()和unRegisterListener()方法。由于要支持多线程，需要在服务端定义一个List去管理各个客户端的Listener，一般会想到使用CopyOnWriteArrayList去存储Listener，因为它支持多线程。不过，如果这样实现，我们可以发现：客户端可以正常register监听器，但是，客户端unRegister同一个监听器的时候，却总是失败！</p><p>之所以会出现这个情况，是因为在客户端中，虽然register和unRegister的是同一个Listener对象，但是，Listener对象的数据通过Binder机制跨进程传输到服务端，进行反序列化后，在服务端却是不同的对象。总的来说，对象是不能跨进程直接传输的。</p><p>为了解决这个问题，就需要使用<strong>RemoteCallbackList</strong>，它是系统专门提供的用于删除跨进程Listener对象的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，所以，可以使用它来代替CopyOnWriteArrayList管理客户端的Listener对象，实现跨进程监听器。</p><p>RemoteCallbackList的内部有一个Map结构专门用来保存所有的AIDL回调，其key是IBinder类型，value是Callback类型。其Map结构的具体声明如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;IBinder, Callback&gt; mCallbacks = <span class="keyword">new</span> ArrayMap&lt;IBinder, Callback&gt;();</span><br></pre></td></tr></table></figure><p>其中Callback中封装了正真的远程Listener。当客户端register时，它会把Listener的信息存入到Map结构中，key和value的获取过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder key = listener.asBinder();</span><br><span class="line">Callback value = <span class="keyword">new</span> Callback(listener, cookie);</span><br></pre></td></tr></table></figure><p>可以看到，Map结构的key值是Listener对应的Binder对象。之所以会这样，是因为Listener对象虽然是跨进程的，在客户端和服务端会是不同的对象，不过，这个跨进程的Listener在底层对应的Binder对象是同一个。正是利用这个特性，RemoteCallbackList可以正确删除掉对应的Listener对象。</p><p>同时，RemoteCallbackList内部自动实现了线程同步的功能，并且，在客户端进程意外终止后，也能够自动删除客户端注册的Listener对象。</p><p>RemoteCallbackList常用的API有：</p><ul><li>register和unregister：用来注册和注销客户端对应的Listener对象；</li><li>beginBroadcast和finishBroadcast：开始使用和结束使用RemoteCallbackList对象，必须成对使用；</li><li>getBroadcastItem(int pos)：根据pos获取对应的Listener对象；</li></ul><h4 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h4><ol><li><p>客户端调用服务端的远程方法时，远程方法运行在服务端的Binder线程池中，同时，客户端线程会被阻塞，如果这个线程是UI线程，并且远程方法执行比较耗时，会造成客户端出现ANR，所以，不要在UI线程中调用耗时的远程方法。</p></li><li><p>服务端的<strong>远程方法</strong>（通过实现Binder接口的方法）本身就运行在服务端的Binder线程池中，所以，服务端的<strong>远程方法</strong>本身就可以执行大量耗时操作，切记不要在远程方法中开启线程执行异步任务，除非明确知道开启异步线程的目的。</p></li><li><p>当服务端调用客户端Listener中的方法时，该方法也运行在Binder线程池中，不过是客户端的线程池，所以，相对于服务端，Listener中的方法也是<strong>远程方法</strong>，因此，也不能在服务端（要注意Service组件运行在UI线程）调用客户端的耗时远程方法。所以，要确保客户端的耗时远程方法运行在服务端的<strong>非UI线程</strong>，否则，会导致服务端无法及时响应。</p></li><li><p>客户端的远程方法运行在客户端的Binder线程池中，因此，不能在其远程方法中修改UI。如果要修改UI，需要使用Handler切换到UI线程。</p></li><li><p>服务端的Binder连接有可能意外断开，为了程序的健壮性，客户端可以在断开时，重新连接服务端。有两种方法实现这个功能：第一种是客户端连接服务端成功后，使用Binder.linkToDeath()方法设置DeathRecipient监听器，这样，在Binder断开时，客户端会收到binderDied()回调方法；第二种是在客户端连接服务端时，重载onServiceDisconnected()方法。这两种方法的区别是，binderDied()回调方法运行在客户端的Binder线程池中，而onServiceDisconnected()方法运行在UI线程中。</p></li></ol><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>默认情况下，远程服务任何客户端都能连接，这是不安全的，可以给服务加入权限验证功能。通常有两种方法：</p><ul><li>在onBind()方法中验证</li></ul><p>可以在服务端的onBind()方法中进行权限验证。下面介绍在onBind()方法中使用Permission验证：</p><p>1.在Manifest文件中声明所需的权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"com.example.ipc.permission.ACCESS_DADA"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.在onBind()方法中做权限验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> check = checkCallingSelfPermission(<span class="string">"com.example.ipc.permission.ACCESS_DADA"</span>);</span><br><span class="line"><span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> mBinder; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果权限不通过，就直接返回null，那么客户端就无法访问这个服务端。</p><p>3.如果客户端需要绑定声明权限的服务端，需要在Manifest中声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.ipc.permission.ACCESS_DADA"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式也可以用于Messenger中。</p><ul><li>在onTransact()方法中验证</li></ul><p>可以在服务端实现Binder接口时，重载onTransact()方法进行权限验证。下面介绍在onTransact()方法中获取客户端的Uid验证包名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">String packageName = <span class="keyword">null</span>;</span><br><span class="line">String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line"><span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">packageName = packages[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (packageName == <span class="keyword">null</span> || !packageName.startsWith(<span class="string">"com.example.ipc"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> fasle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果验证失败，就返回false，那么，客户端执行远程方法会失败。这种方式可以让客户端连接到服务端，但无法执行服务端的远程方法。</p><p>还可以使用getCallingPid()方法获取Pid，去验证客户端的包名，方法与上面介绍的基本一样。</p><p>不过，除了上述两种方法，还可以使用其它方式验证权限，比如为Service组件指定android:permission属性等，这里就不进行介绍了。</p><h2 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h2><p>ContentProvider是Android系统中专门用于不同应用间进行数据数据共享的方式，从这点来看，ContentProvider本身就适合进程间通信。和AIDL一样，它的底层也是通过Binder实现的，不过，系统对其进行了封装，使用过程比AIDL要简单。ContentProvider的具体使用这里就不介绍了，下面主要阐述使用ContentProvider进行IPC需要注意的细节。</p><p>创建一个ContentProvider一般需要实现六个抽象方法：onCreate、query、update、insert、delete和getType。根据Binder原理，这六个方法都运行在ContentProvider的进程中，不过，除了onCreate方法由系统回调并运行在<strong>主线程</strong>中，其它五个方法均由其它进程回调且运行在<strong>Binder线程池</strong>中。因此，不能在onCreate方法中做耗时操作，并且，其它应用调用另外五个<strong>远程方法</strong>时，如果这些方法比较耗时，不要在UI线程中调用。</p><p>由于query、update、insert、delete这四个方法会涉及到数据源的读写操作，并且它们运行在Binder线程池中，所以在具体实现这些方法时，要实现线程同步操作，保证线程安全。</p><h2 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h2><p>Socket主要用于网络通信，网络通信的服务端和客户端处于不同的主机，既然这样，处于同一个设备的服务端和客户端就更加能够使用Socket进行通信。因此，可以在Android系统中使用Socket方式进行进程间通信。Socket的具体使用这里就不介绍了，下面主要阐述在Android中使用Socket进行IPC需要注意的地方。</p><p>使用Socket进行通信，需要声明网络权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>另外，不要在主线程中访问进行网络通信，因为网络操作一般来说都比较耗时，如果放在主线程中会影响应用的响应效率。</p><h1 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h1><p>在使用AIDL时，如果一个项目中，有多个业务模块都要使用AIDL提供服务，按照正常的实现方式，会创建多个Service组件去实现这些服务。但是，Service组件是一种系统资源，过多使用会影响系统性能；并且，在一个应用中使用多个Service，用户在查看APP详情的时候，会发现这个应用会有多个服务同时在运行，给用户造成该应用浪费系统资源的印象。为了解决这个问题，需要减少Service的数量，将所有AIDL接口都放在同一个Service中去管理。</p><p>要实现用一个Service组件管理多个AIDL接口的需求，就要使用到Binder连接池：</p><ol><li><p>每个业务模块创建自己的AIDL接口，并实现这个接口，不过，不同的业务模块之间不能耦合；实现接口后，每个AIDL模块向服务端提供唯一的标识符和对应的Binder对象。</p></li><li><p>对于服务端，只需要一个Service组件，提供一个queryBinder接口，这个接口能根据AIDL模块的标识符返回对应的Binder对象给客户端。</p></li><li><p>对于客户端，通过AIDL模块的标识符调用远程queryBinder方法，获取对应的Binder对象后，就可以使用这个Binder对象调用该模块的远程方法。</p></li></ol><p>Binder连接池的主要作用是将客户端对每个业务模块的Binder请求统一转发到远程的Service中去执行，从而避免了重复创建Service组件，其工作原理如下图所示：</p><p><img src="/uploads/android/Binder连接池.png" alt="Binder连接池"></p><p>以上阐述了Binder连接池的实现原理，具体实现可以参考《Android开发艺术探索》相关章节。</p><h1 id="使用合适的IPC方式"><a href="#使用合适的IPC方式" class="headerlink" title="使用合适的IPC方式"></a>使用合适的IPC方式</h1><p>上面介绍了各种IPC方式，但每种IPC方式都有其使用场景，可以根据具体需求选择不同IPC方式。</p><p>下表总结了Android中各种IPC方式的优缺点以及使用场景：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>Intent</td><td>简单易用</td><td>只支持传输Bundle数据</td><td>四大组件之间的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合并发场景，无法做到即时通信</td><td>无并发访问、交换简单数据并且实时性不高的场景</td></tr><tr><td>Messenger</td><td>支持一对多串行通信，支持实时通信</td><td>不太适合高并发场景，不支持RPC，只支持传输Bundle数据</td><td>低并发的一对多的即时通信，并且无RPC要求</td></tr><tr><td>AIDL</td><td>支持一对多并发通信，支持实时通信</td><td>使用比较复杂，需要处理线程同步</td><td>一对多通信，或者有RPC需求</td></tr><tr><td>ContentProvider</td><td>支持一对多并发数据共享</td><td>可理解为受约束的AIDL，主要提供对数据源的CRUD操作</td><td>一对多的进程间的数据共享</td></tr><tr><td>Socket</td><td>功能强大，支持一对多并发实时通信</td><td>实现比较繁琐，不支持直接RPC</td><td>网络数据交换</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章介绍了Android中IPC的基本原理，这一篇文章详细介绍Android中各种跨进程通信的方式。&lt;/p&gt;
&lt;h1 id=&quot;IPC的方式&quot;&gt;&lt;a href=&quot;#IPC的方式&quot; class=&quot;headerlink&quot; title=&quot;IPC的方式&quot;&gt;&lt;/a&gt;IPC的方式&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="进程和线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android中的IPC介绍</title>
    <link href="http://yoursite.com/2018/02/01/Android%E4%B8%AD%E7%9A%84IPC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/02/01/Android中的IPC介绍/</id>
    <published>2018-02-01T02:27:40.000Z</published>
    <updated>2018-02-05T01:37:27.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPC简介和使用场景"><a href="#IPC简介和使用场景" class="headerlink" title="IPC简介和使用场景"></a>IPC简介和使用场景</h1><h2 id="IPC简介"><a href="#IPC简介" class="headerlink" title="IPC简介"></a>IPC简介</h2><p>IPC(Inter-Process Communication)是指进程间通信，即两个不同进程之间交换数据的过程。</p><p>在明确IPC之前，要明白线程和进程的区别：</p><ul><li><p>线程<br>线程是进程中的一个实体，是能被操作系统独立调度的基本单位。它不拥有系统资源，但是它可以与同属于同一个进程的其它线程共享进程的全部资源。</p></li><li><p>进程<br>一个执行单元，在PC和移动设备上一般指一个程序或者应用，一个进程可以包含多个线程。每个进程都拥有操作系统分配的相互独立的系统资源，比如CPU、内存等。</p></li></ul><p>在Android系统中，一般一个APP就是一个进程（在无特别代码实现的情况下），UI线程就是这个进程的主线程。如果有耗时操作，会导致主线程堵死，而Android中的主线程负责UI操作，就会出现所谓的ANR（Application Not Responding），影响用户体验。所以，Android中一般需要将耗时操作放在子线程中进行。</p><h2 id="IPC的使用场景"><a href="#IPC的使用场景" class="headerlink" title="IPC的使用场景"></a>IPC的使用场景</h2><p>在Android开发中，使用IPC的场景一般有以下两种情况：</p><ul><li><p>应用自身原因，需要采用多进程模式现实<br>比如，一个APP中的一些模块因为特殊原因需要在单独的进程中运行；或者，需要加大一个APP可使用的内存（Android系统对单个APP可使用的内存大小有限制）。</p></li><li><p>当前应用需要获取其他应用的数据<br>每个APP对应一个进程，所以需要使用IPC。</p></li></ul><h1 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h1><p>这里讨论的多进程模式是指在一个APP中开启多个进程的情况，因为两个APP之间默认就是多进程的。</p><h2 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h2><p>在Android中开启多进程一般只有一种方法，就是给四大组件（Activity，Service、Receiver、Provider）指定<em>android:process</em>属性，因此，不能为一个线程或者实体类指定其运行时所在的进程。</p><p>其实还有一种非常规开启多进程的方法，即通过JNI在native层fork一个新的进程，这种方法比较特殊，这里不进行考虑。</p><p>在Android中开启多进程的示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"com.example.ipc.SecondActivity"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"com.example.ipc.ThirdActivity"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:process</span>=<span class="string">".remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在APP中把这三个Activity都打开，通过DDMS可以看到开启了三个进程：</p><p><img src="/uploads/android/进程信息.png" alt="进程信息"></p><p>这三个进程分别是：</p><ul><li><p>com.example.ipc<br>MainActivity所在的进程，当前APP的默认进程，和包名相同。</p></li><li><p>com.example.ipc:remote<br>SecondActivity所在的进程，当前APP的私有进程。</p></li><li><p>.remote<br>ThirdActivity所在的进程，全局进程。</p></li></ul><p>SecondActivity与ThirdActivity所在的进程区别如下：</p><ul><li><p>如果进程名以 : 开始，那么这个进程名会被附加上当前应用的包名，表示该进程是当前应用的私有进程，其它应用不能和它在同一个进程中运行。</p></li><li><p>如果进程名不以 : 开始，那么进程名不会被附加包名信息，是一个完全的命名，表示该进程是全局进程，其它应用可以通过声明相同的<em>android:sharedUserId</em>属性，和它在同一个进程中运行。</p></li></ul><p>Android系统会为每个应用分配一个唯一的UID(User Id)，如果两个应用具有<strong>相同的UID</strong>，并且<strong>签名也相同</strong>，那么，这两个应用可以相互访问对方的私有数据，比如组件信息、data目录等；更进一步，如果这两个应用运行在同一个进程时，它们还可以共享内存数据，或者说它们就像是同一个应用的两个部分。</p><p>因此，可以把同一个应用中的多进程理解为两个不同的应用使用了相同sharedUserId属性。</p><h2 id="开启多进程存在的问题"><a href="#开启多进程存在的问题" class="headerlink" title="开启多进程存在的问题"></a>开启多进程存在的问题</h2><p>前面介绍过，操作系统会为每个进程分配相互独立的系统资源，同样，在Android系统中，会为每个进程分配一个独立的虚拟机。由于不同虚拟机在内存分配上的地址空间不同，这就导致不同进程访问同一个类时，会多次实例化这个类，这样，每个进程都会拥有一个这个类的对象，造成多进程间无法共享内存数据。</p><p>一般来说，在Android系统中，使用多进程会造成以下几个问题：</p><ul><li>静态成员和单例模式失效；</li><li>线程同步机制失效；</li><li>SharedPreferences的可靠性下降；</li><li>Application会创建多次；</li></ul><p>终上所述，在多进程模式中，不同进程的组件会拥有独立的虚拟机、Application和内存空间，这样，多进程之间就无法使用共享内存的方式进行通信，不过，Android系统提供一些跨进程的通信方式。接下来先介绍IPC涉及的一些基本概念，IPC的方式在会下一篇文章中详细分析。</p><h1 id="IPC涉及的基本概念"><a href="#IPC涉及的基本概念" class="headerlink" title="IPC涉及的基本概念"></a>IPC涉及的基本概念</h1><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化是指将对象转换为可保存的字节序列；反序列化是将字节序列恢复为可使用对象。进程间通信时，一个进程需要将传递的对象序列化，另一个进程接收到序列化对象后需要反序列化，才能正常获取对象的数据。</p><p>在Android中，通常有Serializable和Parcelable两种序列化方式，它们之间的有如下区别：</p><ul><li>Serializable是Java中的序列化接口，其使用起来简单但是开销较大，序列化和反序列化需要大量的I/O操作。</li><li>Parcelable是Android中的序列化方式，更适用于Android的平台，缺点是使用起来稍微麻烦，但是效率很高。</li><li>Parcelable主要用于内存序列化上，适合进程间的通信；Serializable更适合文件存储和网络传输。</li></ul><h2 id="Android-Binder机制"><a href="#Android-Binder机制" class="headerlink" title="Android Binder机制"></a>Android Binder机制</h2><h3 id="Binder定义及原理"><a href="#Binder定义及原理" class="headerlink" title="Binder定义及原理"></a>Binder定义及原理</h3><p>Binder在不同场景下有不同含义：</p><ul><li><p>从机制、模型的角度来说<br>Binder是Android系统中特有的一种进程通信方式，即Binder机制模型，用于Android系统实现IPC。</p></li><li><p>从模型的结构、组成的角度来说<br>Binder是一种虚拟的物理设备驱动，即Binder驱动，是ServiceManager连接Manager（比如ActivityManager）和相应ManagerService（比如ActivityManagerService）的桥梁。</p></li><li><p>从Android应用层来说<br>Binder是Client和Server进行通信的媒介，当Client绑定一个Server时，Server就会返回一个包含了服务端业务的Binder对象，Client可以通过这个Binder对象获取Server提供的数据和服务。</p></li><li><p>从Android代码实现的角度来说<br>Binder是一个类，实现了IBinder接口，用于在Android系统中具体实现Binder机制模型。</p></li></ul><p>可以用一张图描述Binder原理：</p><p><img src="/uploads/android/binder_ipc.jpg" alt="Binder原理"></p><p>Binder通信采用的是C/S架构。AMS(ActivityManagerService)可以看成Server；AMP(ActivityManagerProxy)是AMS的代理类，ActivityManager通过AMP与AMS进行通信，可以看成Client。</p><p>ServiceManager用于管理系统中的各种服务，不过需要注意的是，这里的ServiceManager是属于Native层（C++）而不是Framework层（Java）。</p><p>ioctl是一个系统调用，用于内核空间和用户空间交换数据。通常情况下，进程处于用户空间，并且相互独立，如果要进行通信，需要通过操作系统的内核空间交换数据。</p><p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制的，那么，图中的每个步骤都有相应的Client端与Server端：</p><ul><li><p>注册服务<br>首先AMS注册到ServiceManager。该过程：AMS所在进程(system_server)是客户端，ServiceManager是服务端。</p></li><li><p>获取服务<br>Client进程使用AMS前，须先向ServiceManager中获取AMS的代理类AMP。该过程：AMP所在进程(app process)是客户端，ServiceManager是服务端。</p></li><li><p>使用服务<br>app进程得到的代理类AMP后，就可以直接与AMS所在进程交互。该过程：AMP所在进程(app process)是客户端，AMS所在进程(system_server)是服务端。</p></li></ul><p>图中的Client, Server, ServiceManager之间交互都是虚线表示，是由于它们彼此之间不直接交互，而是通过Binder驱动进行交互，从而实现IPC。其中Binder驱动位于内核空间，Client, Server, ServiceManager位于用户空间。Binder驱动和ServiceManager可以看做是Android平台的基础架构，而Client和Server属于Android的应用层。</p><p>如果要进一步了解Binder的底层细节，可以参考<a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a>。</p><h3 id="Binder的优点"><a href="#Binder的优点" class="headerlink" title="Binder的优点"></a>Binder的优点</h3><p>对比Linux（Android基于Linux）上的其他进程通信方式（管道/消息队列/共享内存/信号量/Socket），Binder机制的优点有：</p><ul><li>高效</li></ul><ol><li>Binder数据复制只需要一次，而管道、消息队列、Socket都需要2次；</li><li>通过驱动在内核空间复制数据，不需要额外的同步处理，而共享内存需要进行同步处理；</li></ol><ul><li>安全性高</li></ul><ol><li>Binder机制进行通信时，会根据进程的UID/PID进行有效性检测；</li><li>其它进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信的IP地址是客户端手动填入，容易出现伪造；</li></ol><ul><li>使用简单</li></ul><ol><li>采用C/S架构；</li><li>实现了“面向对象”的调用方式，在使用Binder时就和调用一个本地对象实例一样；</li></ol><h3 id="Binder在Android中的应用"><a href="#Binder在Android中的应用" class="headerlink" title="Binder在Android中的应用"></a>Binder在Android中的应用</h3><p>在Android开发中，Binder主要用于Service组件中，Service组件根据是否被绑定分为普通Service（Unbounded Service）和绑定Service（Bounded Service）。其中，普通Service用于完成后台工作任务，不涉及交互，只有绑定Service才会使用Binder进行交互。</p><p>在Android中，使用绑定Service有以下三种方式：</p><ul><li><p>扩展Binder类<br>如果Service仅供当前应用使用，不需要跨进程工作，则可以实现自己的Binder类，让客户端通过该类直接访问Service中的公共方法。这种方式只在同一个进程中进行交互，不涉及IPC。</p></li><li><p>使用Messenger<br>如果Service需要进行跨进程通信，则需要在Service中使用Messenger。这种方式实现了IPC，并且会在单一线程中创建包含所有请求的队列，以串行的方式处理客户端发来的消息，这样，在进行IPC的时候不需要考虑线程同步的问题。</p></li><li><p>使用AIDL<br>如果Service需要跨进程通信，并且还需要并行处理客户端请求，则需要在Service中使用AIDL。这种方式实现了IPC，还可以让服务端具备多线程处理的能力， 不过，在进行IPC的时候需要考虑线程同步的问题。</p></li></ul><p>其实，Messenger底层是通过AIDL实现的，不过它们最终还是要使用Binder机制实现IPC。</p><p>虽然，Messenger和AIDL用于跨进程通信，但是，在同一个进程中，Messenger和AIDL也是能够使用的，不过，这两种情况的底层实现是不一样的，具体表现为：</p><p>当Client和Server在同一个进程中时，绑定成功后，Client获取的Binder对象就是Server中定义的Binder对象本身，这样可以直接调用Server中的方法，不需要进行IPC；</p><p>当Client和Server在不同的进程中时，绑定成功后，Client获取的Binder对象是Server中Binder的代理对象BinderProxy，具体进行IPC的时候就是通过这个代理对象实现的。</p><p>里面的具体细节可以参考<a href="http://blog.csdn.net/xxxzhi/article/details/51287054" target="_blank" rel="noopener">Android Binder跨进程与非跨进程的传输异同源码分析</a>。</p><p>不过，还有一点需要注意的是，Client发起请求时，Client所在的线程会挂起，直到Server所在的进程返回数据，所以，当要调用的远程方法比较耗时，最好不要在UI线程中发起这个远程调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IPC简介和使用场景&quot;&gt;&lt;a href=&quot;#IPC简介和使用场景&quot; class=&quot;headerlink&quot; title=&quot;IPC简介和使用场景&quot;&gt;&lt;/a&gt;IPC简介和使用场景&lt;/h1&gt;&lt;h2 id=&quot;IPC简介&quot;&gt;&lt;a href=&quot;#IPC简介&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="进程和线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Intent匹配规则</title>
    <link href="http://yoursite.com/2018/01/31/Intent%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2018/01/31/Intent匹配规则/</id>
    <published>2018-01-31T06:34:58.000Z</published>
    <updated>2018-02-02T01:31:26.111Z</updated>
    
    <content type="html"><![CDATA[<p>通过Intent启动Activity有“显示启动”和“隐式启动”两种方式。显示启动需要明确指定被启动Activity的组件信息，包括包名和类名；而隐式启动不需要明确指定启动哪个Activity，只需要使用“匹配规则”描述要启动的Activity的一些特征，系统会根据这些特征搜索对应的Activity，如果对应的Activity有多个，会让用户选择要启动的Activity，否则，直接启动匹配到的Activity。</p><p>隐式启动通常用于APP之间的交互，比如，一个APP要播放音乐，但是该APP没有提供播放功能，这时该APP就可以通过隐式启动，调用当前系统中能够播放音乐的APP进行播放。下面介绍隐式启动的使用及其匹配规则。</p><h1 id="隐式启动"><a href="#隐式启动" class="headerlink" title="隐式启动"></a>隐式启动</h1><p>隐式启动需要Intent能够匹配目标组件在intent-filter标签中设置的过滤信息，intent-filter标签中能设置的过滤信息有action、category和data三类，下面是一个过滤规则的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.chinaums.opensdkdemo.activity.tab.MyTabActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"keyboardHidden|orientation"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- umsapp://main.app/openwith?key1=value1&amp;key2=value2... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:host</span>=<span class="string">"main.app"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathPrefix</span>=<span class="string">"/openwith"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scheme</span>=<span class="string">"umsapp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>系统对Intent进行匹配时，要同时匹配以上三类信息，才能启动目标组件。intent-filter标签中的action、category和data可以有多个，同时，一个Activity中也可以有多个intent-filter。不过，一个Intent只要匹配任何一组intent-filter即可启动对应的的Activity。</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><p>接下来详细分析action、category和data这三类信息的匹配规则。</p><h2 id="action匹配规则"><a href="#action匹配规则" class="headerlink" title="action匹配规则"></a>action匹配规则</h2><p>action是一个字符串，系统预定了一些action，可以直接使用，同时，也可以自定义action。</p><p>action的匹配规则要求Intent中的action存在，并且必须和intent-filter标签中的一个action相同。</p><p>需要注意的是action区分大小写。</p><h2 id="category匹配规则"><a href="#category匹配规则" class="headerlink" title="category匹配规则"></a>category匹配规则</h2><p>category也是一个字符串，系统也预定义了一些category，同样，也可以自定义category。</p><p>但是，category匹配规则与action不一样。category匹配规则要求，如果Intent中出现了category，不管有几个category，对于每个category，它必须是intent-filter标签中已经定义了的category。</p><p>需要注意的是，如果Intent没有定义category，系统在调用startActivity()和startActivityForResult()方式时，会默认为Intent加上 “android.intent.category.DEFAULT” 这个category。因此，要想Activity能够接收隐式调用，必须在其intent-filter标签中指定这个默认的category。</p><h2 id="data匹配规则"><a href="#data匹配规则" class="headerlink" title="data匹配规则"></a>data匹配规则</h2><p>data匹配规则和action类似，如果intent-filter标签中定义了data，那么Intent中必须要也要定义可匹配的data。</p><p>data语法格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:host</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:port</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:mimeType</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>data由两部分组成：mimeType和URI。</p><p>mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic等，可以表示图片、文本、视频等不同的媒体格式。</p><p>URI包含了data标签中，除了mimeType以外的所有属性，下面是URI的结构及其实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scheme</span>&gt;</span>://<span class="tag">&lt;<span class="name">host</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span>[<span class="tag">&lt;<span class="name">path</span>&gt;</span>|<span class="tag">&lt;<span class="name">pathPrefix</span>&gt;</span>|<span class="tag">&lt;<span class="name">pathPattern</span>&gt;</span>]</span><br><span class="line"></span><br><span class="line">content://com.example.project:200/folder/subfolder/etc</span><br><span class="line">http://www.baidu.com/search/info</span><br></pre></td></tr></table></figure><p>URI中每项数据的含义如下：</p><ul><li>scheme：URI的模式，例如http、file、content等，如果URI中没有指定scheme，那么URI无效的。</li><li>host：URI的主机名，例如www.baidu.com，如果host没有指定，URI也是无效的。</li><li>port：URI的端口号，只有指定scheme和host参数，port参数才有意义。</li><li>path：表示URI的路径信息。</li><li>pathPrefix：表示URI路径的前缀信息。</li><li>pathPattern：也可以表示路径信息，不过可以包含通配符 “*” ，用于表示0个或多个任意字符。</li></ul><p>下面介绍两个data匹配的实例。</p><h3 id="只配置mimeType"><a href="#只配置mimeType" class="headerlink" title="只配置mimeType"></a>只配置mimeType</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的规则指定了媒体类型为所有格式的图片类型，那么Intent中的mimeType必须指定为 “image/*” 才能匹配。这里intent-filter没有指定URI，但是系统会为其指定默认值为content和file，所以，要匹配这个过滤器，Intent中URI部分的schema还必须设置为content或者file。</p><p>因此，要匹配上面的规则，可以使用下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>), <span class="string">"image/png"</span>);</span><br></pre></td></tr></table></figure><h3 id="配置多个data"><a href="#配置多个data" class="headerlink" title="配置多个data"></a>配置多个data</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的规则指定了两组data规则，如果要匹配这个规则，可以使用以下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>), <span class="string">"video/mpeg"</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>), <span class="string">"audio/mpeg"</span>);</span><br></pre></td></tr></table></figure><h1 id="匹配规则检测"><a href="#匹配规则检测" class="headerlink" title="匹配规则检测"></a>匹配规则检测</h1><p>在用隐式Intent启动一个Activity的时候，可以使用resolveActivity()方法对匹配规则进行检测，如果返为null就表示该Intent无法匹配到任何Activity。</p><p>还可以使用queryIntentActivities()方法进行检测，不过，这个方法返回所有成功匹配的Activity信息，而resolveActivity()方法返回的是最佳匹配的Activity信息。</p><p>另外，Intent的匹配规则对于Service和BroadcastReceiver也是一样的，不过Android建议尽量使用显示的方式启动Service。同时，PackageManager对象也提供了类似方法去检测是否存在匹配的Service或BroadcastReceiver组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过Intent启动Activity有“显示启动”和“隐式启动”两种方式。显示启动需要明确指定被启动Activity的组件信息，包括包名和类名；而隐式启动不需要明确指定启动哪个Activity，只需要使用“匹配规则”描述要启动的Activity的一些特征，系统会根据这些特征
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="APP组件" scheme="http://yoursite.com/tags/APP%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>内存优化</title>
    <link href="http://yoursite.com/2018/01/30/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/30/内存优化/</id>
    <published>2018-01-30T11:21:56.000Z</published>
    <updated>2018-01-31T02:37:36.707Z</updated>
    
    <content type="html"><![CDATA[<p>由于Android系统的沙箱机制，分别给每个APP的内存大小是有限的。为了APP能在有限的内存下流畅地运行，通常需要对内存进行一定的优化。</p><h1 id="Java中的存储空间"><a href="#Java中的存储空间" class="headerlink" title="Java中的存储空间"></a>Java中的存储空间</h1><p>在Java中，存储空间通常包括以下几个部分：</p><ul><li><p>寄存器<br>速度最快的存储场所，处于CPU内部，一般不在程序中进行控制。</p></li><li><p>栈<br>存放基本的数据类型和对象引用。</p></li><li><p>堆<br>存放使用new关键字创建的对象本身，由Java虚拟机的自动回收机制管理。</p></li><li><p>静态存储区<br>用来存储静态变量。</p></li><li><p>常量池<br>用来存储常量。</p></li></ul><p>通常来说，当定义了一个变量，Java虚拟机会在栈中为其分配存内存空间，当变量的作用域结束后，这部分内存会被立刻回收；如果用new关键字创建一个对象，那么会在堆中为这个对象分配内存空间，即使对象的作用域结束了，这部分内存不会被立刻回收，而是等待虚拟机的垃圾回收器进行回收。所以，内存优化主要是指优化堆所指的内存。</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>虽然，Java虚拟机可以通过垃圾回收器自动回收堆中的内存，但是，垃圾回收器不能在所有情况下都能正确地回收内存，这样，就会造成部分内存无法被再使用，即所谓的内存泄露。</p><p>所以，内存优化的目的不仅要有效地利用内存，还要尽量避免内存泄露。</p><h1 id="内存优化的方法"><a href="#内存优化的方法" class="headerlink" title="内存优化的方法"></a>内存优化的方法</h1><p>下面介绍一些常用的内存优化方法。</p><h2 id="Bitmap优化"><a href="#Bitmap优化" class="headerlink" title="Bitmap优化"></a>Bitmap优化</h2><p>Bitmap通常会占用大量内存，通常会造成OOM（Out Of Memory）。使用Bitmap时，可以使用以下优化方法：</p><ul><li>使用适当分辨率的图片</li></ul><p>由于Android系统在进行资源适配时，会根据屏幕分辨率加载对应分辨率的图片，如果在低分辨率的屏幕上加载高分辨率的图片，就会造成内存浪费。所以，在特定的屏幕上，只加载合适当分辨率的图片。另外，在对图像分辨率没有要求的地方，尽量使用低分辨率的图片。</p><ul><li>使用图片缓存</li></ul><p>使用内存缓存和磁盘缓存可以更好地使用Bitmap。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>可以从代码的角度进行内存优化，下面是常用的一些方法：</p><ul><li>对常量使用static修饰，可以加快访问速度；</li><li>尽量使用静态方法，静态方法比普通方法的访问速度更快；</li><li>减少不必要的成员变量；</li><li>减少不必要的对象，尽量使用基本类型；</li><li>尽量不使用枚举和迭代器；</li><li>对Cursor、Receiver、Sensor、File等对象，使用完毕后要注意回收和注销；</li><li>避免使用IoC（控制反转）框架，这些框架通常使用注解和反射实现，大量使用会降低性能；</li><li>使用RenderScript或OpenGL进行非常复杂的绘图操作；</li><li>使用SurfaceView代替View进行频繁的绘图操作；</li><li>尽量使用ViewHolder复用View；</li></ul><h1 id="Memory-Profiler"><a href="#Memory-Profiler" class="headerlink" title="Memory Profiler"></a>Memory Profiler</h1><p>Android Profiler工具中的Memory Profiler组件能够可视化APP内存使用情况，帮助开发者定位内存泄露。这个工具还提供了捕获堆内存释放、强制进行垃圾回收，以及跟踪内存分配等功能，帮助我们更好地对内存进行优化。</p><h1 id="更多性能优化"><a href="#更多性能优化" class="headerlink" title="更多性能优化"></a>更多性能优化</h1><p>Android的性能优化是一个比较大的话题，这里只介绍了常用的<a href="/2018/01/29/UI优化/">UI优化</a>和<a href="/2018/01/30/内存优化/">内存优化</a>，其它方面的性能优化可以参考<a href="https://developer.android.com/topic/performance/index.html" target="_blank" rel="noopener">性能优化的官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Android系统的沙箱机制，分别给每个APP的内存大小是有限的。为了APP能在有限的内存下流畅地运行，通常需要对内存进行一定的优化。&lt;/p&gt;
&lt;h1 id=&quot;Java中的存储空间&quot;&gt;&lt;a href=&quot;#Java中的存储空间&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UI优化</title>
    <link href="http://yoursite.com/2018/01/29/UI%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/29/UI优化/</id>
    <published>2018-01-29T09:09:47.000Z</published>
    <updated>2018-01-30T11:10:45.241Z</updated>
    
    <content type="html"><![CDATA[<p>系统在渲染UI时会消耗大量的资源，一个好的UI不仅该具有良好的视觉效果，还应该具有良好的使用体验。布局优化的任务就让UI在使用过程中不产生卡顿，让APP有更好的用户体验。</p><h1 id="UI渲染机制和检测工具"><a href="#UI渲染机制和检测工具" class="headerlink" title="UI渲染机制和检测工具"></a>UI渲染机制和检测工具</h1><h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><p>在Android中，系统通过VSYNC信号触发UI的渲染和重绘，信号发送的间隔时间是16ms。如果系统每次渲染的时间都控制在16ms之内，那么，UI界面会非常流畅，否则，就会造成丢帧，从而能使界面产生卡顿。例如，一次绘制任务耗时20ms，那么，在16ms系统发出VSYNC信号时就无法进行绘制，该帧只能等待下次VSYNC信号来临时才被绘制，这样，16*2ms内都是显示同一帧画面，用户在视觉上就会产生卡顿的感觉。</p><h2 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h2><p>Android系统提供了检测UI渲染时间的调试工具。打开“开发者选项”，选择 “Profile GPU Rendering” ，然后选中 “On screen as bars” 选项，这时在屏幕上会显示如下图形：</p><p><img src="/uploads/android/GPU-Rendering.png" alt="GPU渲染时间"></p><p>图中每条柱状图由多种颜色组成，每种颜色的长度表示在渲染时，各个绘制过程消耗的时间。中间的绿色横线表示VSYNC间隔时间16ms，一个良好的UI需要尽量将所有条状图都控制在这条绿线之下。每种颜色表示的绘制过程如下图所示：</p><p><img src="/uploads/android/profiler-legend.png" alt="GPU渲染的各个过程"></p><p>当知道了每个绘制过程的时间后，就可以针对特定的绘制过程进行优化。</p><h3 id="Input-Handing"><a href="#Input-Handing" class="headerlink" title="Input Handing"></a>Input Handing</h3><p>输入处理（Input）颜色的长度表示APP在输入事件回调方法中，处理事件花费的时间长短。</p><p>如果这方面时间花费太多，表示在处理输入事件时做了太多工作，由于回调方法是在主线程上进行的，可以将繁重的工作放到子线程中进行，从而达到优化效果。</p><p>另外，RecyclerView的滑动也属于输入处理，因为滑动会消耗触摸事件，所以，要尽可能快地布局和填充子View。</p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>动画（Anim）颜色的长度表示当前帧执行完所有动画花费的时间。这些常见的动画包括ObjectAnimator, ViewPropertyAnimator和Transitions. </p><p>如果这方面时间花费太多，一般都是执行动画引起属性变化造成的。比如，ListView或RecyclerView在执行fling动画时会快速滑动，引起大量子View的布局和重绘，从而造成执行动画时间过长。</p><h3 id="Measurement和Layout"><a href="#Measurement和Layout" class="headerlink" title="Measurement和Layout"></a>Measurement和Layout</h3><p>测量和布局（Measure）颜色表示系统在测量和布局View时花费的时间。</p><p>如果这方面花费时间太多，一般都是自定义View时，onLayout()和onMeasure()方法执行时间过长造成的。可以用Traceview和Systrace工具检查代码中这样的问题。</p><h3 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h3><p>绘制（Draw）颜色表示当前帧绘制View花费的时间，包括所有View执行onDraw()和dispatchDraw()方法的时间。</p><p>如果这方面花费时间太多，一般都是自定View时，onDraw()方法的逻辑太过复杂造成的。</p><h3 id="Sync和Upload"><a href="#Sync和Upload" class="headerlink" title="Sync和Upload"></a>Sync和Upload</h3><p>同步和上传（Upload）颜色表示当前帧中，将Bitmap对象从CPU内存转移到GPU内存花费的时间。</p><p>Android系统在绘制Bitmap时，需要将Bitmap从CPU传递到GPU，然后GPU再进行绘制。注意，在5.0系统上，这个时间用紫色表示。</p><p>如果这方面花费时间太多，一般来说是由两种情况造成的：一个是当前帧显示了一个接近屏幕大小的Bitmap；另一个是当前帧显示了大量缩略图。</p><p>如果要减少这方面的时间，可以使用以下两种方法：</p><ul><li>在显示图片时，不要让高分辨率的图片在低分辨率的屏幕上显示。</li><li>在CPU和GPU内存同步内存之前，利用prepareToDraw()方法异步上传Bitmap对象。</li></ul><h3 id="Issuing-Commands"><a href="#Issuing-Commands" class="headerlink" title="Issuing Commands"></a>Issuing Commands</h3><p>发布命令（Issue）颜色表示绘制屏幕时，发布所有绘制命令到显示列表（Display Lists）花费的时间。</p><p>由于系统绘制屏幕时，会向GPU发布必要的绘制命令，通常这些操作是通过OpenGL的API实现的。如果这方面花费的时间太多，表明在绘制时有太多的绘制命令需要发布。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">canvas.drawPoint()</span><br></pre></td></tr></table></figure><p>完成以上绘制的发布的绘制命令就完成以下绘制的要多，这样就会在发布命令上花费更多时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawPoints(mThousandPointArray);</span><br></pre></td></tr></table></figure><p>所以，在自定义View时，尽量减少draw操作的数量，可以减少发布命令的时间。</p><h3 id="Processing和Swapping-Buffers"><a href="#Processing和Swapping-Buffers" class="headerlink" title="Processing和Swapping Buffers"></a>Processing和Swapping Buffers</h3><p>CPU发布绘制命令和GPU执行绘制命令的操作是并行的，当CPU发布的速度快于GPU执行的速度时，命令队列会被填满，这时CPU就会被堵塞。处理和交换缓冲（Swap）的颜色表示的这时CPU等待GPU花费的时间。一般CPU被堵塞发生在交换缓冲区（Swap Buffers）阶段，因为在这个阶段，绘制一帧的所有绘制命令会被一起提交给GPU，造成GPU没时间处理CPU接下来发布的绘制命令。</p><p>减少这方面时间消耗用到方法与 “Issuing Commands” 中用到的方法一样。</p><h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><p>除了渲染UI，在主线程上还有很多其它操作，其它（Misc）颜色就是用来表示其它操作花费的时间。一般来说，其他时间就指在UI线程上连续绘制两帧之间的时间间隔。</p><p>如果这方面花费时间太多，表明在主线程中做了太多工作，可以将这些工作放到其它线程中。Method Tracing和Systrace工具可以可视化主线程中的任务，这些可视化的信息可以帮助进行相关优化工作。</p><h1 id="避免过度绘制"><a href="#避免过度绘制" class="headerlink" title="避免过度绘制"></a>避免过度绘制</h1><p>过度绘制（Overdraw）会浪费很多系统资源，比如，系统会默认绘制Activity的背景，如果再给根布局绘制背景，那么默认的Activity背景就属于无效的过度绘制。</p><p>Android系统提供了 “Enable GPU Overdraw” 调试工具来检查UI的过度绘制。在“开发者选项”中打开这个选项后，如下图所示：</p><p><img src="/uploads/android/gpu-overdraw.png" alt="过度绘制"></p><p>可以通过界面上的颜色来判断Overdraw的次数：</p><ul><li>没有颜色：没有过度绘制；</li><li>蓝色：过度绘制1次；</li><li>绿色：过度绘制2次；</li><li>粉色：过度绘制3次；</li><li>红色：过度绘制4次或更多次；</li></ul><p>一般可以使用以下几种方式减少过度绘制次数：</p><ul><li>移除布局中无用的背景</li></ul><p>可以使用Layout Inspector工具找出那些对用户不可见的背景，然后移除这些无用的背景属性。还可以将APP的window背景颜色设置为主背景，那么所有的根布局的就不需要背景色了，从而减少过度绘制次数。</p><ul><li>减少布局层级</li></ul><p>在Android中，系统对View进行测量、布局和绘制时，都是通过对View树的遍历进行操作的。如果一个布局的层级太深，就会严重影响这些操作的速度，并且还会增加过度绘制次数。所以，在定义布局时，应该尽量减少布局层级，这样不但可以提高渲染速度，还能减少过度绘制次数。</p><ul><li>减少使用透明度</li></ul><p>绘制具有透明度属性的像素会增加过度绘制，和一般的过度绘制不一样，带有透明度的对象要求先绘制对象原本的颜色，然后再去绘制对象的透明度值，这样，一个带透明度属性的对象就需要绘制两次。像透明度视觉效果的动画，比如淡入淡出和阴影就是涉及到透明度属性，会造成过度绘制。可以通过减少使用带有透明度属性的对象来改善这种形式的过度绘制。</p><h1 id="避免无用布局"><a href="#避免无用布局" class="headerlink" title="避免无用布局"></a>避免无用布局</h1><p>在“过度绘制”中已经提到过，布局层级太深会影响View进行测量、布局和绘制的速度，并且还会增加过度绘制次数。所以，要尽量避免无用布局，去减少布局的层级。下面介绍两种常用的避免无用布局的方法。</p><ul><li>使用merge标签</li></ul><p>通常会使用include标签重用layout，但是，使用include标签一般会在子View上增加一层根布局，有时在使用include中的子View时，可能并不需要这层根布局，这时就可以使用merge标签代替这个根布局。这样，子View会直接填充到include的位置，不会再添加任何额外的布局结构。</p><ul><li>使用ViewStub标签</li></ul><p>通常会在一个布局中隐藏一个子布局，在需要的时候再去显示。但是，即使将子布局进行隐藏，它们还是存在于布局中，在渲染UI时，还是会遍历这些隐藏的子布局，这时就可以使用ViewStub标签。</p><p>ViewStub虽然是View的一种，但是它没有大小，没有绘制功能，也不参与布局，资源消耗非常低，将它放置在布局当中，基本上不会影响UI性能。</p><p>不过，ViewStub加载的布局是不能使用merge标签的，因此，有可能导致加载出来的布局存在多余的布局结构。具体如何去取舍要根据实际情况来决定，对于那些隐藏的布局文件结构相当复杂的情况，使用ViewStub还是一种不错的选择。</p><h1 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h1><p>可以使用Hierarchy Viewer工具查看布局的View树结构，并测量每个View的绘制速度。这些信息可以帮助我们对UI进行优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统在渲染UI时会消耗大量的资源，一个好的UI不仅该具有良好的视觉效果，还应该具有良好的使用体验。布局优化的任务就让UI在使用过程中不产生卡顿，让APP有更好的用户体验。&lt;/p&gt;
&lt;h1 id=&quot;UI渲染机制和检测工具&quot;&gt;&lt;a href=&quot;#UI渲染机制和检测工具&quot; cla
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android安全机制</title>
    <link href="http://yoursite.com/2018/01/29/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/01/29/Android安全机制/</id>
    <published>2018-01-29T07:17:33.000Z</published>
    <updated>2018-01-29T09:01:34.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android安全机制简介"><a href="#Android安全机制简介" class="headerlink" title="Android安全机制简介"></a>Android安全机制简介</h1><p>Android系统中，可以用以下几种安全机制保护系统的安全。</p><h2 id="代码安全机制"><a href="#代码安全机制" class="headerlink" title="代码安全机制"></a>代码安全机制</h2><p>代码安全机制就是使用代码混淆proguard来保护系统安全。</p><p>APK存在被反编译的风险，proguard可以混淆关键代码，替换命名让破坏者阅读代码困难，同时可以压缩代码，优化编译后的Java字节码。</p><h2 id="应用权限控制"><a href="#应用权限控制" class="headerlink" title="应用权限控制"></a>应用权限控制</h2><p>应用权限控制是在Manifest文件中声明权限，对权限进行检查。</p><p>任何应用程序在使用系统受限资源时，都需要向系统声明所需要的权限，通过了权限检查，才能调用系统对应的服务。</p><h2 id="应用签名机制"><a href="#应用签名机制" class="headerlink" title="应用签名机制"></a>应用签名机制</h2><p>应用签名机制是利用数字证书来控制APK的来源是否安全。</p><p>Android中所有的APP都有一个数字证书，即APP的签名，用于保护APP的作者对已APP的信任关系。只有相同数字签名的APP，才会在升级时被认为是同一个APP，并且系统不会安装没有签名的APP。</p><h2 id="Linux内核层安全机制"><a href="#Linux内核层安全机制" class="headerlink" title="Linux内核层安全机制"></a>Linux内核层安全机制</h2><p>Android是基于Linux内核开发，所以Android继承了Linux的安全特性，比如文件访问权限控制。通常只有System和Root用户才有权限访问系统文件。</p><h2 id="虚拟机沙箱机制"><a href="#虚拟机沙箱机制" class="headerlink" title="虚拟机沙箱机制"></a>虚拟机沙箱机制</h2><p>Android的APP运行在虚拟机中，因此有了沙箱机制，可以让APP之间相互隔离。通常情况下，不同APP之间不能相互访问，每个APP运行在单独的虚拟机中，与其它APP完全隔离，即使一个APP崩溃，也不会对导致其它APP异常。</p><h1 id="APK反编译"><a href="#APK反编译" class="headerlink" title="APK反编译"></a>APK反编译</h1><p>APK文件本质上是一个压缩文件，但是APK一般都做过加密处理，普通的解压方式不能得到正确的文件，下面介绍一些常用的工具，它们可以分别反编译APK的不同部分。</p><h2 id="apktool"><a href="#apktool" class="headerlink" title="apktool"></a>apktool</h2><p>apktool可以用来反编译APK中的XML资源文件。</p><p>通过以下命令反编译一个APK文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.jar d test.apk</span><br></pre></td></tr></table></figure><p>参数d是decode的意思，apk文件可以加上目录。执行反编译命令后，当前文件夹会出现对应APK名字的文件夹，打开文件夹就可以看到APK的资源文件。</p><p>这个工具在汉化时比较有用，在提前资源文件进行汉化后，可以用以下命令重新打包：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.jar b test</span><br></pre></td></tr></table></figure><h2 id="smali"><a href="#smali" class="headerlink" title="smali"></a>smali</h2><p>使用apktool工具反编译APK文件后，可以得到一个smali文件夹。要查看APK的源码，首先需要将使用smali工具将smali代码转换为dex文件。</p><p>通过以下命令将smali文件转换为dex文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smali.jar test/smali -o test.dex</span><br></pre></td></tr></table></figure><p>使用以上命令后，后在当前文件夹会出现test.dex文件。</p><h2 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a>dex2jar</h2><p>使用smali工具获取dex文件后，还需要将dex文件转换为jar文件。</p><p>通过以下命令将dex文件转换为jar文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2jar.bat test.dex</span><br></pre></td></tr></table></figure><p>使用以上命令后，可以得到命名为test.dex.dex2jar.jar的文件。</p><h2 id="jd-gui"><a href="#jd-gui" class="headerlink" title="jd-gui"></a>jd-gui</h2><p>通过dex2jar工具获得了APK源码对应的jar文件后，就可以使用jd-gui工具查看APK的源码了。</p><p>直接打开jd-gui.exe程序，打开对应的jar文件查看即可。</p><h1 id="APK加密"><a href="#APK加密" class="headerlink" title="APK加密"></a>APK加密</h1><p>Java字节码很容易被反编译，可以使用ProGuard对代码进行混淆，增加APK的安全性。</p><p>ProGuard的原理是使用无意义的字母来重命名类、字段和方法。不过，除了进行混淆代码，ProGuard还可以删除无用的类、字段和方法，以及无用的注释，最大限度地优化Class文件。</p><p>在Gradle中使用ProGuard的代码如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="keyword">true</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中minifyEnabled表示是否打开代码混淆，proguardFiles表示混淆规则的文件。前一个是系统默认的混淆文件，大部分情况使用这个默认文件就行了；后一个是自定义的混淆文件，在这个文件中可以定义一些第三方依赖包的混淆规则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android安全机制简介&quot;&gt;&lt;a href=&quot;#Android安全机制简介&quot; class=&quot;headerlink&quot; title=&quot;Android安全机制简介&quot;&gt;&lt;/a&gt;Android安全机制简介&lt;/h1&gt;&lt;p&gt;Android系统中，可以用以下几种安全机制保护系统
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="系统与安全" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>获取系统和APK信息</title>
    <link href="http://yoursite.com/2018/01/29/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%92%8CAPK%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/01/29/获取系统和APK信息/</id>
    <published>2018-01-29T01:52:23.000Z</published>
    <updated>2018-01-29T07:14:43.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h1><p>通常可以通过android.os.Bulid和SystemProperty获取系统的配置信息。</p><h2 id="android-os-Build"><a href="#android-os-Build" class="headerlink" title="android.os.Build"></a>android.os.Build</h2><p>android.os.Bulid类包含了很多系统编译时的大量设备和配置信息，常用的有：</p><ul><li>Build.BOARD：主板</li><li>Build.BRAND：系统定制商</li><li>Build.SUPPORTED_ABIS：CPU指令集</li><li>Build.DEVICE：设备参数</li><li>Build.DISPLAY：显示屏参数</li><li>Build.FINGERPRINT：唯一编号</li><li>Build.SERIAL：硬件序列号</li><li>Build.ID：修订版本列表</li><li>Build.MANUFACTURER：硬件制造商</li><li>Build.MODEL：版本</li><li>Build.HARDWARE：硬件名</li><li>Build.TAGS：描述Build的标签</li><li>Build.TYPE：Build类型</li><li>Build.VERSION.CODENAME：当前开发代号</li><li>Build.VERSION.INCREMENTAL：源码控制版本号</li><li>Build.VERSION.RELEASE：版本字符串</li><li>Build.VERSION.SDK_INT：版本号</li><li>Build.HOST：Host值</li><li>Build.USER：User值</li><li>Build.TIME：编译时间</li></ul><p>可以直接使用android.os.Bulid类获取Build提供的系统信息。</p><h2 id="SystemProperty"><a href="#SystemProperty" class="headerlink" title="SystemProperty"></a>SystemProperty</h2><p>SystemProperty包含了许多系统配置属性值和参数，有一些也可以通过android.os.Bulid类获取，常用的有：</p><ul><li>os.verison：OS版本</li><li>os.name：OS名称</li><li>os.arch：OS架构</li><li>user.home：Home属性</li><li>user.name：Name属性</li><li>user.dir：Dir属性</li><li>user.timezone：时区</li><li>path.separator：路径分隔符</li><li>line.separator：行分隔符</li><li>file.separator：文件分隔符</li><li>java.vendor.url：Java vender URL属性</li><li>java.class.path：Java Class路径</li><li>java.class.version：Java Class版本</li><li>java.vendor：Java Vender属性</li><li>java.version：Java版本</li><li>java.home：Java Home属性</li></ul><p>具体获取SystemProperty的值通过System.getProperty(“xxx属性”)方法。</p><h1 id="获取APK信息"><a href="#获取APK信息" class="headerlink" title="获取APK信息"></a>获取APK信息</h1><p>除了获取系统相关信息，还可以获取APK的相关信息。</p><h2 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h2><p>Android系统使用PackageManager来负责管理所有已安装的APP，它通过解析Manifest文件，将APP的各种组件和相关信息封装成对应的类。下面介绍一些常用的封装类。</p><ul><li><p>ActivityInfo、ServiceInfo、ReceiverInfo、ProviderInfo<br>封装了Manifest文件中各个组件的信息，包括name、icon、label、launchmode等。</p></li><li><p>ApplicationInfo<br>封装了Manifest文件中application的信息，不过ApplicationInfo还包含了很多Flag，比如FLAG_SYSTEM表示系统应用、FLAG_EXTERAL_STORAGE表示安装在SDCard上的应用等，通过Flag，可以判断应用的类型。</p></li><li><p>PackageInfo<br>封装了APK安装包的基本信息，比如包名、权限等。</p></li><li><p>ResolveInfo<br>封装了Manifest文件中包含intent标签的组件的信息，可以用来寻找包含特定Intent的应用，比如寻找有分享功能的应用。</p></li></ul><p>PackageManager可以通过调用相关方法，获取上面介绍的封装类，从而获取APK相关的信息，常用的方法有：</p><ul><li>getPackageManager()：获取PackageManager对象。</li><li>getApplicationInfo()：获取指定包名的ApplicationInfo。</li><li>getApplicationIcon()：获取指定包名的Icon。</li><li>getInstalledApplications()：以ApplicationInfo形式返还系统安装的所有应用。</li><li>getInstalledPackages()：以PackageInfo形式返回系统安装的所有引用。</li><li>queryIntentActivities()：返回指定Intent的所有Activity的ResolveInfo对象。</li><li>queryIntentServices()：返回指定Intent的所有Service的ResolveInfo对象。</li><li>resolveActivity()：返回指定Intent的Activity的ResolveInfo对象。</li><li>resolveService()：返回指定Intent的Service的ResolveInfo对象。</li></ul><h2 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h2><p>PackageManager主要获取APK的静态信息，而ActivityManager可以获取APP运行时的信息。类似的，ActivityManager也将相关信息封装为对应的对象，比较常用的有：</p><ul><li><p>ActivityManager.MemoryInfo<br>提供当前系统内存相的关状态信息，提供的字段有：<br>availMem：系统可用内存；<br>totalMem：总内存；<br>threshold：低内存的阈值；<br>lowMemory：是否处于低内存；</p></li><li><p>Debug.MemoryInfo<br>提供提供某个进程的内存使用信息。</p></li><li><p>RunningAppProcessInfo<br>提供运行的进程的信息，提供的字段有：<br>processName：进程名；<br>pid：进程的pid；<br>uid：进程的uid；<br>pkgList：该进程下所有的包；</p></li><li><p>RunningServiceInfo<br>提供运行的服务的信息，提供的字段有：<br>activeSince：第一次激活的时间和方式；<br>foreground：服务是否在后台运行；</p></li></ul><p>一般通过以下代码获取ActivityManager对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager activityManager = </span><br><span class="line">        (ActivityManager) (getSystemService(Context.ACTIVITY_SERVICE));</span><br></pre></td></tr></table></figure><h1 id="Packages-xml"><a href="#Packages-xml" class="headerlink" title="Packages.xml"></a>Packages.xml</h1><p>Android系统在初始化的时候，PackageManager的底层实现类PackageManagerService会去扫描系统中的一些特点目录，并解析其中的APK文件，然后，把获取的信息保存在Packages.xml文件中，当系统中的APK进行安装、删除、升级时，这个文件会被更新，它的路径位于<em>/data/system/</em>目录下。</p><p>通过Packages.xml文件可以获取APP的很多信息，一般在进行系统层开发时，会通过这个文件获取系统的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取系统信息&quot;&gt;&lt;a href=&quot;#获取系统信息&quot; class=&quot;headerlink&quot; title=&quot;获取系统信息&quot;&gt;&lt;/a&gt;获取系统信息&lt;/h1&gt;&lt;p&gt;通常可以通过android.os.Bulid和SystemProperty获取系统的配置信息。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="系统与安全" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Activity任务栈和启动模式</title>
    <link href="http://yoursite.com/2018/01/24/Activity%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/24/Activity任务栈和启动模式/</id>
    <published>2018-01-24T08:25:50.000Z</published>
    <updated>2018-02-02T01:31:21.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity任务栈"><a href="#Activity任务栈" class="headerlink" title="Activity任务栈"></a>Activity任务栈</h1><p>一个APP通常有多个Activity，这些Activity通过栈结构保存，栈底是整个任务栈(Task)的发起者。</p><p>当一个APP启动时，如果系统中不存在该APP的任务栈，那么系统会为其创建一个任务栈，此后，这个APP启动的所有Activity都将在这个任务栈中被管理。需要注意的是，一个Task中的Activity可以来自不同的APP，同一个APP的Activity也可能存在于多个Task中。</p><p>在Task中，一个Activity启动另一个Activity时，新的Activity会被置于栈顶，并处于活动状态，而启动它的Activity依然保留在Task中，处于停止状态，当用户按返回键或者调用finish()方法时，系统会弹出栈顶的Activity，让后面的Activity从停止状态恢复到活动状态。以上是Task管理Activity的一般流程，当需要特殊处理时，就需要使用Activity的启动模式。</p><h1 id="通过Manifest声明启动模式"><a href="#通过Manifest声明启动模式" class="headerlink" title="通过Manifest声明启动模式"></a>通过Manifest声明启动模式</h1><p>可以在AndroidManifest文件中，为Activity声明启动模式，一共能声明四种启动模式：standard、singleTop、singleTask、singleInstance，下面分别进行介绍。</p><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>默认的启动模式，每次启动Activity都会创建一个新的实例。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个Task，也可以位于不同的Task。</p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>在singleTop模式下，启动一个Activity时，系统会判断当前Task中的栈顶Activity是否是要启动的Activity，如果是则不创建新的Activity，然后直接引用这个Activity，并调用其<strong>onNewIntent()</strong>方法；如果不是，则新建该Activity的实例，并将其置于栈顶。</p><p>因此，在同一个Task中，声明为singleTop模式的Activity也会存在多个实例，只不过这些实例不会相邻。</p><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>在singleTask模式下，只允许<strong>一个</strong>包含该Activity实例的Task存在。</p><p>singleTask模式下，Activity的启动方式与<em>android:taskAffinity</em>相关。当B是singleTask模式时，以A启动B来说：</p><ul><li><p>当A和B的taskAffinity相同时：第一次创建B的实例时，<strong>并不会启动新的Task</strong>，而是直接将B添加到A所在的Task；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其<strong>onNewIntent()</strong>方法。</p></li><li><p>当A和B的taskAffinity不同时：第一次创建B的实例时，<strong>会启动新的Task</strong>，然后将B添加到新建的Task中；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其<strong>onNewIntent()</strong>方法。</p></li></ul><p>注意，当要启动的Activity在其它APP的Task中，会在返回栈(Back Stack)中将要启动Activity所在的Task置于当前Task之前，具体过程如下图所示：</p><p><img src="/uploads/android/singletask_backstack.png" alt="singleTask启动模式"></p><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>singleInstance模式下，任意时刻只允许存在唯一的Activity实例，而且该Activity所在的Task不能容纳除该Activity之外的其他Activity实例。其它Activity要启动该Activity，只需要打开这个分离的Task，并调用其<strong>onNewIntent()</strong>方法。</p><p>singleInstance模式经常用于需要与应用分离的界面，该模式的Activity实例即使启动其它Activity，这些Activity也会自动运行于另一个Task中。</p><p>singleInstance与singleTask一个明显区别是：singleTask所在的Task中能有其它的Activity，而singleInstance的Task中不能有其他Activity。</p><p><strong>注意</strong></p><blockquote><p>如果ActivityA处于singleTask或singleInstance启动模式，当ActivityA通过startActivityForResult()方法启动另一个ActivityB时，将会直接返回RESULT_CANCELED，而不会等待ActivityB返回。因为Android系统不允许不同的Task之间直接传递数据，如果有这样的需要，只能通过onNewIntent()方法使用Intent传递。</p></blockquote><h1 id="通过Intent-Flags声明启动模式"><a href="#通过Intent-Flags声明启动模式" class="headerlink" title="通过Intent Flags声明启动模式"></a>通过Intent Flags声明启动模式</h1><p>除了在AndroidManifest文件中声明启动模式，还可以在启动Activity时，通过Intent中声明启动模式，这种Flag存在多个，下面介绍几个常用的启动Flag。</p><ul><li>Intent.FLAG_ACTIVITY_NO_HISTORY</li></ul><p>如果一个Activity是由该模式启动，当这个Activity再去启动其它Activity后，这个Activity就会被销毁，不会保留在Task中。</p><ul><li>Intent.FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>这个Flag的效果与singleTop启动模式的效果相同。</p><ul><li>Intent.FLAG_ACTIVITY_NEW_TASK</li></ul><p>这个Flag的效果会受到<strong>taskAffinity</strong>属性影响，当B声明为该模式，以A启动B来说：</p><p>当A和B的taskAffinity相同时，与standard模式效果一样，每次都在当前Task新建B的实例。</p><p>当A和B的taskAffinity不同时，如果是首次启动，会新建一个Task，并将该Activity实例添加到Task中；如果再次启动，只会把该Activity所在Task置于前台，但是<strong>不会</strong>将该Activity置于栈顶，也<strong>不会</strong>调用其onNewIntent()方法。</p><p>该Flag通常用于其它组件启动一个Activity，因为其它组件不存在任何Task中，<strong>可能</strong>需要新建一个Task管理Activity实例，比如，使用Service启动Activity的场景。不过，当系统存在一个与其taskAffinity属性相同的Task时，这时就不会新建Task，而会直接在这个Task中新建Activity实例。</p><ul><li>Intent.FLAG_ACTIVITY_CLEAR_TOP</li></ul><p>如果要启动的Activity在<strong>当前</strong>的Task中，会销毁该Activity之上的所有其它Activity，从而将其置于栈顶；否则，在当前Task新建Activity实例。</p><p>不过，当要启动的Activity同时被声明为<strong>standard模式</strong>时，该Activity实例也会跟着其它Activity从栈顶弹出，然后重新创建该Activity。之所以这样，是因为standard模式下，总是创建新实例响应Intent。</p><p>总的来说，该模式只会清空栈顶，是通过新建实例还是通过onNewIntent()响应Intent启动消息，要看该Activity的其它启动模式。</p><p>通常将FLAG_ACTIVITY_CLEAR_TOP与FLAG_ACTIVITY_NEW_TASK混合使用，来定位存在于其他Task中的Activity实例，并将其置于栈顶。</p><ul><li>Intent.FLAG_ACTIVITY_CLEAR_TASK</li></ul><p>这个Flag用来清空Task，单独使用没有什么效果，通常与FLAG_ACTIVITY_NEW_TASK混合使用，这时会受到<strong>taskAffinity</strong>属性影响，当B声明为该模式，以A启动B来说：</p><p>当A和B的taskAffinity相同时，清空当前Task，并在当前Task中新建Activity实例。</p><p>当A和B的taskAffinity不同时，如果首次启动，新建Task，并在新Task新建Activity实例；如果再次启动，则清空实例所在的Task，再新建Activity。</p><p><strong>注意</strong></p><blockquote><p>通过Intent Flags声明的启动模式能够覆盖通过Manifest文件声明的启动模式，因此，如果它们之间有冲突时，以Flags为准。</p></blockquote><h1 id="Task相关的属性"><a href="#Task相关的属性" class="headerlink" title="Task相关的属性"></a>Task相关的属性</h1><p>除了用启动模式可以控制Task，还可以使用Task相关的属性控制Task，这些属性在Manifest文件的Activity节点声明，常用的有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:taskAffinity="string"</span><br><span class="line">android:allowTaskReparenting=["true" | "false"]</span><br><span class="line">android:alwaysRetainTaskState=["true" | "false"]</span><br><span class="line">android:clearTaskOnLaunch=["true" | "false"]</span><br><span class="line">android:finishOnTaskLaunch=["true" | "false"]</span><br></pre></td></tr></table></figure><h2 id="处理Affinity"><a href="#处理Affinity" class="headerlink" title="处理Affinity"></a>处理Affinity</h2><ul><li>taskAffinity</li></ul><p>介绍启动模式的时候已经提到过这个属性。每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p><ul><li>allowTaskReparenting</li></ul><p>是否允许activity重新指定Task，默认值是false。</p><p>如果一个Activity的allowTaskReparenting设置为true，它进入后台后，当一个和它有相同taskAffinity属性的Task进入前台时，它会重新宿主，进入到该前台的Task中。</p><h2 id="清空任务栈"><a href="#清空任务栈" class="headerlink" title="清空任务栈"></a>清空任务栈</h2><p>一般来说，如果一个Task很长时间没有被用户使用，那么系统会清空这个Task中除了栈底Activity(Root Activity)之外的所有其它Activity，当用户重新进入这个Task时，只有Root Activity会被恢复。可以使用以下属性修改系统的这个默认行为。</p><ul><li>alwaysRetainTaskState</li></ul><p>默认值是false，如果将Root Activity的这个属性设置为true，那么该Activity所在的Task将不会被清空，即使很长时间不使用，这个Task中所有Activity的状态都会被保存。</p><ul><li>clearTaskOnLaunch</li></ul><p>默认值是false，如果将Root Activity的这个属性设置为true，不管用户什么时候离开该Activity所在的Task，系统会立刻清空这个Task中除了Root Activity之外的所有其它Activity，这个行为与alwaysRetainTaskState刚好相反。</p><ul><li>finishOnTaskLaunch</li></ul><p>默认值是false，如果某个Activity的finishOnTaskLaunch属性设置位true，只要你一离开该Activity所在的Task, 系统会立刻清除这个Activity, 不管这个Activity在Task的任何位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity任务栈&quot;&gt;&lt;a href=&quot;#Activity任务栈&quot; class=&quot;headerlink&quot; title=&quot;Activity任务栈&quot;&gt;&lt;/a&gt;Activity任务栈&lt;/h1&gt;&lt;p&gt;一个APP通常有多个Activity，这些Activity通过栈结构
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="APP组件" scheme="http://yoursite.com/tags/APP%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Activity状态和生命周期</title>
    <link href="http://yoursite.com/2018/01/24/Activity%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/01/24/Activity状态和生命周期/</id>
    <published>2018-01-24T06:10:06.000Z</published>
    <updated>2018-02-02T01:31:06.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity状态"><a href="#Activity状态" class="headerlink" title="Activity状态"></a>Activity状态</h1><p>Activity有多种状态，并且在这些状态之间可以相互切换，从而控制自己的生命周期。</p><ul><li>Resumed</li></ul><p>这个状态的Activity处于Activity任务栈的最顶层，对用户可见，并且具有焦点，能与用户进行交互。</p><ul><li>Paused</li></ul><p>当Activity失去焦点，被一个非全屏的或者透明的Activity覆盖时，Activity就处于Paused状态。这时，Activity不能与用户进行交互，但是，其状态信息、成员变量等还被系统保持着，只有在系统内存将要耗尽时，才会被系统回收。</p><ul><li>Stopped</li></ul><p>当Activity被另一个Activity完全覆盖时会进入到Stopped状态，这时，Activity不可见，但也保持了所有的状态信息和成员变量，不过，相比Paused状态，系统会优先回收Stopped状态的Activity。</p><ul><li>Destroyed</li></ul><p>当Activity被系统回收或调用finish()方法后，Activity就处于Destroyed状态。</p><h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><p>下面以一张图来展示Activity生命周期（来自于Android官方文档）：</p><p><img src="/uploads/android/activity_lifecycle.png" alt="Activity生命周期"></p><h2 id="Activity启动和销毁过程"><a href="#Activity启动和销毁过程" class="headerlink" title="Activity启动和销毁过程"></a>Activity启动和销毁过程</h2><p>当系统启动Activity时，首先调用onCreate()之后，接着调用onStart()，然后调用onResume()进入Active/Running状态。</p><p>当系统销毁Activity时，如果是正常的销毁流程，会依次调用onPause()、onStop()和onDestory()，让Activity回到Destroyed状态；如果是系统回收内存资源进行的销毁，可能不会调用onDestory()甚至onStop()方法。</p><p>根据Activity启动和销毁过程，可以在相关方法中做一些特定操作：</p><ul><li>onCreate()：创建UI并加载数据，开启后台线程，初始化成员变量。</li><li>onDestory()：释放所有还保留着的系统资源，特别注意要关闭开启的后台线程（对象引用在Activity销毁时会自动清除，但是线程不会）。</li></ul><h2 id="Activity暂停和恢复过程"><a href="#Activity暂停和恢复过程" class="headerlink" title="Activity暂停和恢复过程"></a>Activity暂停和恢复过程</h2><p>Activity暂停时会调用onPause()方法，暂停结束后，会调用onResume()方法恢复Activity的状态。</p><p>根据Activity暂停和恢复过程，可以在相关方法中做一些特定操作：</p><ul><li>onPause()：暂停不需要在Paused状态运行的操作，比如Music、Video和Animation等，释放不需要在Paused状态使用的系统资源，比如Camera、Sensor、Receivers等；注意onPause()方法运行时间比较短，不要在里面做耗时操作，比如保存数据、请求网络、执行数据库事务等，不过，可以在onStop()方法中做这些耗时的操作。</li><li>onResume()：开启onPause()中暂停的操作，重新初始化onPause()中释放的资源。</li></ul><h2 id="Activity停止和重新启动过程"><a href="#Activity停止和重新启动过程" class="headerlink" title="Activity停止和重新启动过程"></a>Activity停止和重新启动过程</h2><p>当Activity处于Paused状态时，通常会有两种可能：调用onResume()方法恢复Activity；调用onStop()方法，停止Activity。</p><p>Activity停止后会处于后台，如果要重新启动，会调用onReStart()和onStart()方法。</p><p>根据Activity停止和重新启动过程，可以在相关方法中做一些特定操作：</p><ul><li>onStop()：释放几乎所有系统资源，因为大部分系统资源在Activity不可见时不会再使用，比如注销在onStart()中开启的，能够影响UI的Receivers；特别要注意释放那些可能造成内存泄露的系统资源，因为系统可能会在内存不足的时候跳过onDestory()方法销毁Activity；另外，还可以做一些耗时的关闭操作，比如保存用户的草稿数据到数据库中。</li><li>onReStart()：只有在从后台恢复到前台时才会调用onReStart()方法。</li><li>onStart()：初始化一些影响UI系统资源，比如注册能够影响UI的Receivers等。</li></ul><h2 id="Activity重新创建过程"><a href="#Activity重新创建过程" class="headerlink" title="Activity重新创建过程"></a>Activity重新创建过程</h2><p>当Activity处于Paused或Stopped状态时，系统会因为内存不足回收Activity，这时，系统会将Activity的状态通过onSaveInstanceState()方法保存到Bundle对象中。当重新创建Activity时，Bundle对象会被传递到onRestoreInstanceState()和onCreate()方法中，这样就可以通过Bundle对象恢复Activity的状态。Android系统已经默认实现了系统控件的状态保存和恢复，不过只支持提供了android:id属性的View。</p><p>只有当前Activity离开前台，并且有被销毁的可能时，才会调用onSaveInstanceState()方法，如果调用finish()方法正常结束Activity的时候，该方法不会被调用。</p><p>另外，当系统配置改变时，Activity也会被重新创建，这时会调用onConfigurationChanged()方法。比如，在横竖屏切换时，系统会调用onSaveInstanceState()方法保存状态数据，然后，根据新的配置去恢复Activity的状态。</p><p>onSaveInstanceState()方法一般用来保存Activity的状态数据，如果要保存需要持久化的数据，应该在Activity在前台的时候，寻找合适的时机去保存，如果找不到合适的时机，可以在onStop()方法中进行。</p><p>onSaveInstanceState()方法会在onPause()方法之后、onStop()方法之前调用；onRestoreInstanceState()方法会在onStart()方法之后调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity状态&quot;&gt;&lt;a href=&quot;#Activity状态&quot; class=&quot;headerlink&quot; title=&quot;Activity状态&quot;&gt;&lt;/a&gt;Activity状态&lt;/h1&gt;&lt;p&gt;Activity有多种状态，并且在这些状态之间可以相互切换，从而控制自己的生
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="APP组件" scheme="http://yoursite.com/tags/APP%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>阴影和裁剪View及Drawable着色</title>
    <link href="http://yoursite.com/2018/01/23/%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A3%81%E5%89%AAView%E5%8F%8ADrawable%E7%9D%80%E8%89%B2/"/>
    <id>http://yoursite.com/2018/01/23/阴影和裁剪View及Drawable着色/</id>
    <published>2018-01-23T12:35:47.000Z</published>
    <updated>2018-01-24T05:46:15.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阴影效果"><a href="#阴影效果" class="headerlink" title="阴影效果"></a>阴影效果</h1><p>Android5.0以前，通常用X和Y两个属性表示View的平面位置，而在Android5.0中，增加了一个新属性Z，对应于垂直方向的位置，让View具有立体的效果，Z属性通过阴影的大小表示View的高低。</p><p>View的Z值有两部分组成：</p><ul><li>elevation：静态的，通过android:elevation或 View.setElevation()方法进行设置。</li><li>translationZ：动态的，用来实现动画效果，通过View.setTranslationZ()方法设置。</li></ul><p>Z = elevation + translationZ</p><p>可以使用 ViewPropertyAnimator.z()和ViewPropertyAnimator.translationZ()方法实现elevation属性的动画效果；</p><p>还可以使用StateListAnimator声明elevation动画，比如Button按下的动画效果就是这样实现的。</p><h1 id="自定义阴影轮廓"><a href="#自定义阴影轮廓" class="headerlink" title="自定义阴影轮廓"></a>自定义阴影轮廓</h1><p>View的背景形状决定了阴影的轮廓，所以，可以使用shape标签自定义形状作为View的background属性，从而自定义阴影的轮廓。</p><p>另外，还可以通过代码自定义View的阴影轮廓，一般需要以下几个步骤：</p><ul><li>新建一个继承于ViewOutlineProvider的类；</li><li>重载getOutline()方法自定义轮廓；</li><li>使用View.setOutlineProvider()方法为View设置自定义的轮廓；</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewOutlineProvider outlineProvider = <span class="keyword">new</span> ViewOutlineProvider() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutline</span><span class="params">(View view, Outline outline)</span> </span>&#123;</span><br><span class="line">        outline.setRoundRect(<span class="number">0</span>, <span class="number">0</span>, view.getWidth() + <span class="number">10</span>, view.getHeight() + <span class="number">10</span>, <span class="number">30f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">view.setOutlineProvider(outlineProvider);</span><br></pre></td></tr></table></figure><p>默认的ViewOutlineProvider类从View的background属性获取阴影轮廓，如果View不需要阴影效果，可以通过setOutlineProvider()将其设置为null。</p><h1 id="裁剪View"><a href="#裁剪View" class="headerlink" title="裁剪View"></a>裁剪View</h1><p>裁剪(Clip)View可以很容易改变View的形状，可以通过View.setClipToOutline()方法或android:clipToOutline属性将View裁剪至轮廓区域。</p><p>仅支持矩阵、椭圆和圆角矩阵的裁剪，这是由Outline.canClip()方法决定的。</p><p>如果要将视图的裁剪作用到Drawable背景对象上，首先使用View.setOutlineProvider()方法裁剪视图，然后调用View.setClipToOutline()方法，将裁剪作用到View的背景上。</p><p>裁剪视图操作比较耗费系统资源，所以，不要为裁剪视图的形状添加动画，如果要实现这样的动画效果，可以使用Reveal动画，具体可以参考<a href="/2018/01/22/MaterialDesign中的动画/">MaterialDesign中的动画</a>。</p><h1 id="Drawable着色"><a href="#Drawable着色" class="headerlink" title="Drawable着色"></a>Drawable着色</h1><p>从Android5.0开始，可以为Drawable图片资源着色(Tint)，这样可以让图片资源与APP的主题匹配。</p><p>可以通过setTint()方法为BitmapDrawable、NinePatchDrawable以及VectorDrawable对象着色，也可以在XML布局文件中使用android:tint和android:tintMode属性设置着色的颜色和模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阴影效果&quot;&gt;&lt;a href=&quot;#阴影效果&quot; class=&quot;headerlink&quot; title=&quot;阴影效果&quot;&gt;&lt;/a&gt;阴影效果&lt;/h1&gt;&lt;p&gt;Android5.0以前，通常用X和Y两个属性表示View的平面位置，而在Android5.0中，增加了一个新属性Z，对应于
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>使用Palette提取颜色</title>
    <link href="http://yoursite.com/2018/01/23/%E4%BD%BF%E7%94%A8Palette%E6%8F%90%E5%8F%96%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2018/01/23/使用Palette提取颜色/</id>
    <published>2018-01-23T10:59:44.000Z</published>
    <updated>2018-01-23T12:36:37.592Z</updated>
    
    <content type="html"><![CDATA[<p>使用Palette提取当前图片的颜色，然后根据提取的颜色去设置当前主题的颜色，可以让主题动态适应当前页面的色调，做到整个APP颜色基调统一。</p><h1 id="使用支持库"><a href="#使用支持库" class="headerlink" title="使用支持库"></a>使用支持库</h1><p>使用Palette要配置对应的Support Library。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion <span class="number">24</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  implementation <span class="string">'com.android.support:palette-v7:24.2.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建Palette"><a href="#创建Palette" class="headerlink" title="创建Palette"></a>创建Palette</h1><p>下面介绍如何根据一个Bitmap创建一个Palette。</p><h2 id="生成Palette实例"><a href="#生成Palette实例" class="headerlink" title="生成Palette实例"></a>生成Palette实例</h2><p>生成Palette有同步和异步两种方式，同步方式是在当前UI线程中操作，如果想优化UI性能，可以使用异步方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate palette synchronously and return it</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Palette <span class="title">createPaletteSync</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  Palette p = Palette.from(bitmap).generate();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate palette asynchronously and use it on a different</span></span><br><span class="line"><span class="comment">// thread using onGenerated()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPaletteAsync</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  Palette.from(bitmap).generate(<span class="keyword">new</span> PaletteAsyncListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGenerated</span><span class="params">(Palette p)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Use generated instance</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Palette"><a href="#自定义Palette" class="headerlink" title="自定义Palette"></a>自定义Palette</h2><p>生成Palette的时可以使用Palette.Builder对象自定义Palette，比如，可以过滤掉图片中黑色，或者只是用图片的上半部分生成Palette。</p><p>可以使用以下方法跳转Palette的大小和颜色：</p><ul><li>addFilter()：添加颜色过滤器；</li><li>maximumColorCount()：设置生成Palette所使用的最大颜色位数，默认值是16位；</li><li>setRegion()：设置生成Palette的图片区域；</li><li>addTarget()：通过Target.Builder为Palette添加自定义的目标颜色配置；</li></ul><h1 id="获取颜色"><a href="#获取颜色" class="headerlink" title="获取颜色"></a>获取颜色</h1><p>一般Palette会抽取下面6中特征颜色：</p><ul><li>Light Vibrant：充满活力的亮</li><li>Vibrant：充满活力的</li><li>Dark Vibrant：充满活力的黑</li><li>Light Muted：柔和的亮</li><li>Muted：柔和的</li><li>Dark Muted：柔和的黑</li></ul><p>下面以一张图说明这些颜色特征：</p><p><img src="/uploads/android/palette-color-profiles.png" alt="palette-color-profiles"></p><p>具体获取某个特征颜色使用Palette.getXXXColor()方法，比如getMutedColor()。并不是所有的图片都会返回这些颜色特效，所以，在获取颜色时，还需要提供一个默认的返回颜色。</p><h2 id="使用Swatch创建配色方案"><a href="#使用Swatch创建配色方案" class="headerlink" title="使用Swatch创建配色方案"></a>使用Swatch创建配色方案</h2><p>对于每个颜色特征，Palette都提供了一个Palette.Swatch对象用于生产对应的配色方案，获取Palette.Swatch模板代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a palette's vibrant swatch after checking that it exists</span></span><br><span class="line"><span class="keyword">private</span> Palette.<span class="function">Swatch <span class="title">checkVibrantSwatch</span><span class="params">(Palette p)</span> </span>&#123;</span><br><span class="line">  Palette.Swatch vibrant = p.getVibrantSwatch();</span><br><span class="line">  <span class="keyword">if</span> (vibrant != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> vibrant;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Throw error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要检查返回的Swatch是否为空，因为getXXXSwatch()方法没有像getXXXColor()方法那样设置默认的颜色。</p><p>获取了Swatch后，就可以根据Swatch创建主题的配色方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the background and text colors of a toolbar given a</span></span><br><span class="line"><span class="comment">// bitmap image to match</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToolbarColor</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Generate the palette and get the vibrant swatch</span></span><br><span class="line">  <span class="comment">// See the createPaletteSync() and checkVibrantSwatch() methods</span></span><br><span class="line">  <span class="comment">// from the code snippets above</span></span><br><span class="line">  Palette p = createPaletteSync(bitmap);</span><br><span class="line">  Palette.Swatch vibrantSwatch = checkVibrantSwatch(p);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set the toolbar background and text colors</span></span><br><span class="line">  Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">  toolbar.setBackgroundColor(vibrantSwatch.getRgb());</span><br><span class="line">  toolbar.setTitleTextColor(vibrantSwatch.getTitleTextColor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是使用Vibrant特征颜色生成的Toolbar配色方法：</p><p><img src="/uploads/android/palette-color-scheme.png" alt="palette-color-scheme"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Palette提取当前图片的颜色，然后根据提取的颜色去设置当前主题的颜色，可以让主题动态适应当前页面的色调，做到整个APP颜色基调统一。&lt;/p&gt;
&lt;h1 id=&quot;使用支持库&quot;&gt;&lt;a href=&quot;#使用支持库&quot; class=&quot;headerlink&quot; title=&quot;使用支持
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>Material主题</title>
    <link href="http://yoursite.com/2018/01/23/Material%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/23/Material主题/</id>
    <published>2018-01-23T08:52:45.000Z</published>
    <updated>2018-01-23T10:48:51.135Z</updated>
    
    <content type="html"><![CDATA[<p>Material主题能够提供以下功能：</p><ul><li>自定义系统区域的颜色。比如可以修改Status Bar的颜色，使APP的颜色风格和系统的颜色风格保持统一。</li><li>为系统Widget提供触摸反馈动画。具体看以参考<a href="/2018/01/22/MaterialDesign中的动画/">MaterialDesign中的动画</a>。</li><li>提供Activity&amp;Fragment过渡动画。具体可以参考<a href="/2018/01/18/Activity&amp;Fragment过渡动画/">Activity&amp;Fragment过渡动画</a>。</li></ul><p>系统提供了以下默认的Material主题：</p><ul><li>@android:style/Theme.Material (dark version)</li><li>@android:style/Theme.Material.Light (light version)</li><li>@android:style/Theme.Material.Light.DarkActionBar</li></ul><p>Material Dark版本的样式如下图所示：</p><p><img src="/uploads/android/MaterialDark.png" alt="MaterialDark"></p><p>Material Light版本的样式如下图所示：</p><p><img src="/uploads/android/MaterialLight.png" alt="MaterialLight"></p><h1 id="自定义调色板"><a href="#自定义调色板" class="headerlink" title="自定义调色板"></a>自定义调色板</h1><p>继承Material主题后，可以在styles文件中自定义调色板(Color Palette)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- inherit from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Main theme colors --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- your app branding color for the app bar --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimary"</span>&gt;</span>@color/primary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- darker variant for the status bar and contextual app bars --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;</span>@color/primary_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- theme UI controls like checkboxes and text fields --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorAccent"</span>&gt;</span>@color/accent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面属性对应的APP界面的颜色如下图所示：</p><p><img src="/uploads/android/ThemeColors.png" alt="ThemeColors"></p><h1 id="自定义StatusBar颜色"><a href="#自定义StatusBar颜色" class="headerlink" title="自定义StatusBar颜色"></a>自定义StatusBar颜色</h1><p>在Material主题中，使用<em>android:statusBarColor</em>属性定义状态栏的颜色，默认情况下，<em>android:statusBarColor</em>使用<em>android:colorPrimaryDark</em>对应的颜色。还可以通过Window.setStatusBarColor()动态设置状态栏的颜色。</p><h1 id="单个View的主题"><a href="#单个View的主题" class="headerlink" title="单个View的主题"></a>单个View的主题</h1><p>在XML布局文件中，可以为View使用<em>android:theme</em>属性指定特定的主题，这个主题修改只对View及其子View起作用，通常用于改变部分UI的主题颜色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Material主题能够提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义系统区域的颜色。比如可以修改Status Bar的颜色，使APP的颜色风格和系统的颜色风格保持统一。&lt;/li&gt;
&lt;li&gt;为系统Widget提供触摸反馈动画。具体看以参考&lt;a href=&quot;/2018/01
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>SVG和矢量动画</title>
    <link href="http://yoursite.com/2018/01/23/SVG%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/23/SVG和矢量动画/</id>
    <published>2018-01-23T02:37:21.000Z</published>
    <updated>2018-01-23T08:04:03.626Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0(API Level 21)中开始支持SVG的绘制，SVG有以下几个特点：</p><ul><li>可伸缩的矢量图形(Scalable Vector Graphics)</li><li>使用XML格式定义图形</li><li>图形在放大或改变尺寸时，图像不会失真</li><li>基于W3C标准，与Web中的矢量图通用</li></ul><p>Android中可以使用&#60;path&#62;标签绘制SVG，相比Bitmap，SVG最大的优点是缩放不会失真，这样不需要为不同的分辨率设计多套图标，从而缩小APK的体积。</p><h1 id="path标签和SVG指令"><a href="#path标签和SVG指令" class="headerlink" title="path标签和SVG指令"></a>path标签和SVG指令</h1><p>使用&#60;path&#62;标签创建SVG，类似于用指令的方式控制一只画笔绘制图像。&#60;path&#62;标签支持的SVG指令有：</p><ul><li>M = moveto(M X,Y)：将画笔移动到指定的坐标位置，但未发生绘制</li><li>L = lineto(L X,Y)：画直线到指定的坐标位置</li><li>H = horizontal lineto(H X)：画水平线到指定的X坐标位置</li><li>V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置</li><li>C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝塞尔曲线</li><li>S = smooth curveto(S X2,Y2,ENDX,ENDY)：三次贝塞尔曲线，一般跟在C或S命令后面</li><li>Q = quadratic curveto(Q X,Y,ENDX,ENDY)：二次贝塞尔曲线</li><li>T = smooth quadratic curveto(T ENDX,ENDY)：二次贝塞尔曲线，一般跟在Q或T命令后面</li><li>A = elliptical arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线</li><li>Z = closepath()：关闭路径</li></ul><p>使用以上指令时，需要注意：</p><ul><li>坐标轴为以(0,0)为中心，X轴水平向右，Y轴水平向下。</li><li>所有指令大小写均可。大写绝对定位，参照全局坐标系；小写相对定位，参照父容器坐标系。</li><li>指令和数据间的空格可以省略。</li><li>同一指令连续出现多次可以只声明一次。</li></ul><p>指令的详细解释可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="noopener">MDN文档</a>。</p><p>SVG指令的写法固定，并且比较复杂，一般可以通过SVG编辑器来绘制SVG图像，然后将其转换为SVG代码。常用的SVG编辑器有在线的<a href="http://editor.method.ac/" target="_blank" rel="noopener">Method Draw</a>和离线的<a href="https://inkscape.org/en/" target="_blank" rel="noopener">Inkscape</a>。</p><h1 id="SVG绘制"><a href="#SVG绘制" class="headerlink" title="SVG绘制"></a>SVG绘制</h1><p>在Android中，可以使用VectorDrawable创建基于XML的SVG。在XML中创建SVG时，path标签是SVG的最小单位，而group标签将不同的path标签进行组合，最终形成一棵SVG树。</p><p>下面是一个“心形”矢量图的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/drawable/heart.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line">        &lt;!-- SVG的实际大小 --&gt;</span><br><span class="line">        android:width="256dp"</span><br><span class="line">        android:height="256dp"</span><br><span class="line">        <span class="comment">&lt;!-- SVG的划分比例，绘制path时使用的参数就是相对这两个值进行换算的 --&gt;</span></span><br><span class="line">        android:viewportHeight="32"</span><br><span class="line">        android:viewportWidth="32"&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"heart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:rotation</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- draw a path --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"#8fff"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"M20.5,9.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c-1.955,0,-3.83,1.268,-4.5,3</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c-0.67,-1.732,-2.547,-3,-4.5,-3</span></span></span><br><span class="line"><span class="tag"><span class="string">                        C8.957,9.5,7,11.432,7,14</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c0,3.53,3.793,6.257,9,11.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c5.207,-5.242,9,-7.97,9,-11.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        C25,11.432,23.043,9.5,20.5,9.5z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="矢量动画"><a href="#矢量动画" class="headerlink" title="矢量动画"></a>矢量动画</h1><p>在Android中，可以使用AnimatedVectorDrawable实现矢量动画。AnimatedVectorDrawable的主要功能是将静态的VectorDrawable和动态的ObjectAnimator连接起来，产生动画效果。因此，矢量动画最终还是通过属性动画实现的。</p><p>使用矢量动画一般有以下几个步骤：</p><ul><li>在res/drawable/路径下利用vector标签定义要进行动画的矢量图</li><li>在res/drawable/路径下利用animated-vector标签定义矢量动画</li><li>在res/anim/路径下利用objectAnimator标签定义矢量动画使用的属性动画</li></ul><p>矢量图中能够产生动画效果的元素是path和group元素，在定义矢量动画时，需要进行动画的元素必须要定义唯一的<em>android:name</em>属性。</p><p>矢量动画的具体示例如下：</p><p>定义矢量图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/vectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"600"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:rotation</span>=<span class="string">"45.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据name属性定义矢量动画：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/animvectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:drawable</span>=<span class="string">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@anim/rotation"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@anim/path_morph"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义矢量动画对应的属性动画：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/animator/rotation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:duration</span>=<span class="string">"6000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:propertyName</span>=<span class="string">"rotation"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueFrom</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueTo</span>=<span class="string">"360"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/animator/path_morph.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"M300,70 l 0,-70 70,0 0,140 -70,0z"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"pathType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，对pathData属性进行动画时，valueTo和valueFrom值必须要兼容，即要有同样数量的命令，并且命令的参数数量要相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0(API Level 21)中开始支持SVG的绘制，SVG有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可伸缩的矢量图形(Scalable Vector Graphics)&lt;/li&gt;
&lt;li&gt;使用XML格式定义图形&lt;/li&gt;
&lt;li&gt;图形在放大或改变尺寸
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MaterialDesign中的动画</title>
    <link href="http://yoursite.com/2018/01/22/MaterialDesign%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/22/MaterialDesign中的动画/</id>
    <published>2018-01-22T11:43:58.000Z</published>
    <updated>2018-01-23T02:45:04.577Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0(API Level 21)以后，可以使用Material Design(MD)中的动画可以给用户提供触摸反馈和一致性交互体验。<a href="/2018/01/18/Activity&amp;Fragment过渡动画/">Activity&amp;Fragment过渡动画</a>就是MD中动画的一种，接下来介绍MD中其它类型的动画。</p><h1 id="Ripple-Animation"><a href="#Ripple-Animation" class="headerlink" title="Ripple Animation"></a>Ripple Animation</h1><p>MD大量使用了Ripple效果，即点击后View后，产生波纹效果，这个效果主要用于触摸反馈。</p><p>可以通过如下代码设置View的波纹背景：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 有边界波纹</span><br><span class="line">android:background="?android:attr/selectableItemBackground"</span><br><span class="line"></span><br><span class="line">// 无边界波纹</span><br><span class="line">android:foreground="?android:attr/selectableItemBackgroundBorderless"</span><br></pre></td></tr></table></figure><p>如果要修改默认波纹的颜色，可以使用主题中<em>android:colorControlHighlight</em>属性进行设置。</p><p>还可以在XML文件中，直接创建Ripple效果的背景资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/drawable/ripple_sample --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"@color/colorPrimary"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"oval"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Reveal-Animation"><a href="#Reveal-Animation" class="headerlink" title="Reveal Animation"></a>Reveal Animation</h1><p>Reveal动画为显示或隐藏一组UI元素提供视觉一致性体验，具体表现为一个View以圆的形式展开。使用ViewAnimationUtils.createCircularReveal()方法创建Reveal动画。</p><p>展现隐藏的View：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// previously invisible view</span></span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the center for the clipping circle</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the final radius for the clipping circle</span></span><br><span class="line"><span class="keyword">float</span> finalRadius = (<span class="keyword">float</span>) Math.hypot(cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the animator for this view (the start radius is zero)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the view visible and start the animation</span></span><br><span class="line">myView.setVisibility(View.VISIBLE);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><p>隐藏可见的View：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// previously visible view</span></span><br><span class="line"><span class="keyword">final</span> View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the center for the clipping circle</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the initial radius for the clipping circle</span></span><br><span class="line"><span class="keyword">float</span> initialRadius = (<span class="keyword">float</span>) Math.hypot(cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the animation (the final radius is zero)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the view invisible when the animation is done</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the animation</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h1 id="View-State-Changes-Animation"><a href="#View-State-Changes-Animation" class="headerlink" title="View State Changes Animation"></a>View State Changes Animation</h1><p>在Android5.0以后，可以为View的状态改变设置一个状态切换动画。</p><h2 id="StateListAnimator"><a href="#StateListAnimator" class="headerlink" title="StateListAnimator"></a>StateListAnimator</h2><p>StateListAnimator作为视图改变时的动画效果时，通常使用Selector进行设置。示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- animate the translationZ property of a view when pressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"@android:integer/config_shortAnimTime"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- you could have other objectAnimator elements</span></span><br><span class="line"><span class="comment">             here for "x" and "y", or other properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_pressed</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_focused</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义好对应的XML文件后，将其作为View的<em>android:stateListAnimator</em>属性，就可以使用对应的动画。</p><p>同样的，可以在代码中调用AnimatorInflater.loadStateListAnimator()方法加载XML文件，然后通过View.setStateListAnimator()方法将动画设置到对应的View上。</p><p>当时用Material主题时，Button默认带有<em>translationZ</em>的动画，如果不需要这个动画，可以将<em>android:stateListAnimator</em>属性设置为<em>@null</em>。</p><h2 id="AnimatedStateListDrawable"><a href="#AnimatedStateListDrawable" class="headerlink" title="AnimatedStateListDrawable"></a>AnimatedStateListDrawable</h2><p>AnimatedStateListDrawable可以为View的状态切换设置<a href="/2018/01/17/可绘制动画/">可绘制动画</a>，Android5.0中很多系统组件就使用了这样的的动画效果，具体可以通过animated-selector进行定义，示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-selector</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provide a different drawable for each state--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/pressed"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableP"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/focused"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_focused</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@id/default"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableD"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- specify a transition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">android:fromId</span>=<span class="string">"@+id/default"</span> <span class="attr">android:toId</span>=<span class="string">"@+id/pressed"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animation-list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt2"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0(API Level 21)以后，可以使用Material Design(MD)中的动画可以给用户提供触摸反馈和一致性交互体验。&lt;a href=&quot;/2018/01/18/Activity&amp;amp;Fragment过渡动画/&quot;&gt;Activity&amp;amp;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>过渡动画框架</title>
    <link href="http://yoursite.com/2018/01/22/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/01/22/过渡动画框架/</id>
    <published>2018-01-22T02:54:49.000Z</published>
    <updated>2018-01-22T07:38:11.791Z</updated>
    
    <content type="html"><![CDATA[<p>当用户通过键盘输入或者触发其他事件时界面需要做出变化，比如，某个Activity包含一个搜索框，当用户输入数据并提交的时候，Activity会隐藏搜索框同时显示搜索的结果。</p><p>在这种应用场景(Scenes)下，可以通过在不同的View树上运行动画，来提供连续的视觉效果。这些动画不仅仅响应了用户的操作，也帮助用户学习应用是如何工作的。</p><p>Android的过渡动画框架(Transitions Framework)可以方便的实现两个View树之间的动画。它通过动态的改变View的属性从而达到动画变换的效果。Android系统内置了常用的动画效果，也可以自定义过渡动画和过渡生命周期。</p><p>在Android4.4之前可以使用<a href="/2018/01/18/布局动画/">布局动画</a>实现简单过渡动画效果，但是对于复杂的场景，布局动画使用起来不太方便，所以，Android4.4引入了过渡动画框架来方便实现这样的应用场景。</p><p>过渡动画的本质还是属性动画，只不过是对属性动画做了一层封装，目的是方便开发者实现ViewGroup的过渡动画效果。</p><h1 id="场景和过渡动画"><a href="#场景和过渡动画" class="headerlink" title="场景和过渡动画"></a>场景和过渡动画</h1><p>过渡动画框架可以在两个不同的View树之间运行过渡动画，它对View树中的所有View执行一个或者多个动画，框架的有如下特性：</p><ul><li>GroupView级别的动画：对View树中的所有View执行动画</li><li>基于变化的动画：动画的运行是基于View属性的开始值和结束值</li><li>内置动画：包含了一些预置的动画，比如淡入淡出和移动</li><li>支持资源文件：可以通过布局文件中加载View树和内置动画</li><li>声明周期回调：通过回调可以控制动画的执行过程</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>过渡动画框架和动画的关系如下所示：</p><p><img src="/uploads/android/过渡动画框架原理.png" alt="过渡动画框架原理"></p><p>Transitions框架和View动画是平行关系。Transitions框架主要用于存储View树的状态，在切换View树时执行定义的动画，从而实现过渡效果。</p><p>Transitions框架提供了抽象的Scenes、Transition以及TransitionManagers。使用过程中，首先，为执行动画的View树创建初始Scene；然后，为动画创建Transition；最后，使用TransitionManager对象启动动画，并传入创建的Transition和结束Scene。</p><h2 id="场景-Scenes"><a href="#场景-Scenes" class="headerlink" title="场景(Scenes)"></a>场景(Scenes)</h2><p>Scene存储了View树的状态，即View树中所有View的属性值，这样就可以通过改变属性值，从当前Scene变换到指定的Scene。</p><p>创建Scene可以通过Layout文件或者在代码中使用GroupView对象。通过代码创建Scene，用于动态生成View树，或者在运行时改变View树。</p><p>通常情况下，并不需要创建开始Scene。当使用Transition时，系统会使用上一个Transition的结束Scene作为下一个Transition的开始Scene；如果之前没有使用过Transition，系统会收集View树的当前状态作为开始Scene。</p><p>可以定义Scene变化的Action。比如，在Scene变化后，清除View的设置。</p><p>Scene除了存储View树的属性值，同时也存储了View树的父视图引用，这个引用称为Scene Root，Scene的变换和动画都发生在Scene Root中。</p><h2 id="过渡动画-Transition"><a href="#过渡动画-Transition" class="headerlink" title="过渡动画(Transition)"></a>过渡动画(Transition)</h2><p>在Transitions框架中，创建了一系列的帧去描述View树从开始Scene到结束Scene的变化。动画的信息都存储在Transition对象中，可以使用TransitionManager对象为动画指定一个Transition。Transition可以用于两个不同的Scene，或者同一个Scene的不同状态。</p><p>系统内置了一组常用的Transition，比如淡入淡出，缩放等。可以根据框架中提供的API自定义一个Transition来创建想要动画的效果。也可以组合自定义或者内置Transition，作为一个Transition集合，达到不同的动画效果。</p><p>系统会监听Transition整个生命周期，这一点和Activity相似。每个重要的生命周期状态，都会执行一个回调函数，在函数中你可以根据不同的状态调整用户界面。</p><h2 id="限制-Limitation"><a href="#限制-Limitation" class="headerlink" title="限制(Limitation)"></a>限制(Limitation)</h2><ul><li>应用于SurfaceView的动画显示会有问题。SurfaceView的更新通过非UI线程，它的更新与动画中的其他View可能会不同步。</li><li>用于TextureView的某些特定Transition类型会产生一些不同与期望的动画效果。</li><li>继承于AdapterView的类，例如ListView，管理子View的方式与Transition框架不兼容。如果将动画应用于这些View，会出问题。</li><li>TextView执行缩放动画时，在动画完成前，文本会被放置到新得到位置。为了避免此问题，不要在包含文本的TextView中使用缩放的动画。</li></ul><h1 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h1><p>Transitions框架可以在开始和结束的Scene中执行过渡动画。开始Scene通常由用户界面的当前状态决定。结束Scene，可以通过资源文件或者使用代码创建。</p><p>注意：单个View树的变换可以不使用Scene，具体使用在下一节介绍。</p><h2 id="使用XML文件创建Scene"><a href="#使用XML文件创建Scene" class="headerlink" title="使用XML文件创建Scene"></a>使用XML文件创建Scene</h2><p>通过资源文件可以直接创建Scene对象。当View树不会变化时可以使用这种方式。生成的Scene代表当你创建Scene实例时View树的状态。如果改变了View树，必须重新创建Scene。创建的Scene包含整个资源文件，不允许从部分资源文件中创建Scene。</p><p>从布局文件中创建Scene，首先要从布局文件中获取ViewGroup类型Scene Root对象，接着调用Scene.getSceneForLayout()，参数为Scene Root和布局文件中作为Scene的View树的资源ID。</p><h3 id="为Scene定义Layout"><a href="#为Scene定义Layout" class="headerlink" title="为Scene定义Layout"></a>为Scene定义Layout</h3><p>下面介绍通过相同的Scene Root元素创建两个不同的Scene。通过代码同样可以看到，只需要加载两个不相关的Scene对象，并不需要定义他们的依赖关系。</p><p>示例中的布局为：</p><ul><li>Activity的主布局文件包含一个TextView和一个子布局</li><li>一个相对布局中包含了两个TextView作为第一个Scene</li><li>一个相对布局同样包含两个TextView但是顺序不同作为第二个Scene</li></ul><p>示例中所有的动画发生在Activity主布局文件的子布局中，而主布局文件中的TextView是不变的。</p><p>Activity主布局文件为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/master_layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/title"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Title"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/scene_root"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/a_scene"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该布局文件中定义了一个TextView和一个作为Scene Root的子布局。第一个Scene被包含在主布局文件中。App把它作为应用的初始界面，Scene也会把整个子布局加载起来，因为Transition框架是不能够加载部分布局到Scene中。</p><p>Scene 1的布局定义如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/a_scene.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/scene_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view1</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">1</span>" /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view2</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">2</span>" /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Scene 2包含相同的两个TextView（一样的资源ID），但是他们的顺序和Scene 1不一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/scene_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view2</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">2</span>" /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view1</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">1</span>" /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从Layout文件中生成Scene"><a href="#从Layout文件中生成Scene" class="headerlink" title="从Layout文件中生成Scene"></a>从Layout文件中生成Scene</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scene mAScene;</span><br><span class="line">Scene mAnotherScene;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the scene root for the scenes in this app</span></span><br><span class="line">mSceneRoot = (ViewGroup) findViewById(R.id.scene_root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the scenes</span></span><br><span class="line">mAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, <span class="keyword">this</span>);</span><br><span class="line">mAnotherScene =</span><br><span class="line">    Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这样，应用就包含了两个基于View树的Scene对象。两个Scene使用同样Scene Root，它通过activity_main.xml中的FrameLayout元素定义。</p><h2 id="使用Java代码创建Scene"><a href="#使用Java代码创建Scene" class="headerlink" title="使用Java代码创建Scene"></a>使用Java代码创建Scene</h2><p>在代码中通过ViewGroup对象同样可以创建Scene实例。当你在代码中需要修改View树的结构或者动态的生成View树时，可以使用这种方式。</p><p>在代码中利用View树创建Scene，使用Scene(sceneRoot, viewHierarchy)构造函数。这个构造函数和Scene.getSceneForLayout()有同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scene mScene;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain the scene root element</span></span><br><span class="line">mSceneRoot = (ViewGroup) mSomeLayoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain the view hierarchy to add as a child of</span></span><br><span class="line"><span class="comment">// the scene root when this scene is entered</span></span><br><span class="line">mViewHierarchy = (ViewGroup) someOtherLayoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a scene</span></span><br><span class="line">mScene = <span class="keyword">new</span> Scene(mSceneRoot, mViewHierarchy);</span><br></pre></td></tr></table></figure><h2 id="创建Scene-Actions"><a href="#创建Scene-Actions" class="headerlink" title="创建Scene Actions"></a>创建Scene Actions</h2><p>当Scene进入和退出时，系统允许自定义Scene Action。通常情况下自定义Action是没有必要的，因为系统会自动处理Scene间的变换。</p><p>Scene Action用于下面几个情况：</p><ul><li>执行动画的View不在Scene的View树里，其执行动画的时机可能在Scene开始或者结束时。</li><li>Transitions框架不支持的View，比如ListView。</li></ul><p>可以将Scene Action定义成Runnable对象，然后作为参数调用Scene.setExitAction()和Scene.setEnterAction()方法。在Transition动画运行之前，开始Scene会调用setExitAction()方法，在Transition动画运行之后，结束Scene会调用setEnterAction()方法。</p><p>注意：不要在开始Scene和结束Scene中的View之间使用Scene Action传递数据。因为结束View树直到动画结束才会被初始化。</p><h1 id="使用过渡动画"><a href="#使用过渡动画" class="headerlink" title="使用过渡动画"></a>使用过渡动画</h1><p>在Transitions框架中，动画创建了一系列的帧描述View树从开始Scene到结束Scene之间的变化。这些变化在Transition框架中使用Transition对象来表示，所有动画的信息都包含在其中。通过TransitionManager对象启动动画，具体使用时，需要传入Transition对象和结束Scene。</p><h2 id="创建Transition"><a href="#创建Transition" class="headerlink" title="创建Transition"></a>创建Transition</h2><p>内置Transition对象的创建方式有两种，可以资源文件定义，也可以直接用代码创建。</p><p>系统提供的内置Transition类型如下所示：</p><table><thead><tr><th>Class</th><th>Tag</th><th>Effect</th></tr></thead><tbody><tr><td>AutoTransition</td><td>&#60;autoTransition/&#62;</td><td>Default transition. Fade out, move and resize, and fade in views, in that order.</td></tr><tr><td>Fade</td><td>&#60;fade/&#62;</td><td>fade_in fades in views;<br> fade_out fades out views;<br> fade_in_out (default) does a fade_out followed by a fade_in.</td></tr><tr><td>ChangeBounds</td><td>&#60;changeBounds/&#62;</td><td>Moves and resizes views.</td></tr></tbody></table><h3 id="通过资源文件中创建Transition"><a href="#通过资源文件中创建Transition" class="headerlink" title="通过资源文件中创建Transition"></a>通过资源文件中创建Transition</h3><p>在资源文件中创建Transition的好处是当你需要修改Transition的定义的时候不用修改Activity中的代码，另一个好处就是将复杂的Transition定义和代码分离。</p><ul><li>创建Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/transition/fade_transition.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fade</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>从资源文件中获取Transition对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transition mFadeTransition =</span><br><span class="line">        TransitionInflater.from(<span class="keyword">this</span>).</span><br><span class="line">        inflateTransition(R.transition.fade_transition);</span><br></pre></td></tr></table></figure><h3 id="通过代码中创建Transition"><a href="#通过代码中创建Transition" class="headerlink" title="通过代码中创建Transition"></a>通过代码中创建Transition</h3><p>这种方式的好处是可以动态的创建Transition对象（如果你在代码中需要修改用户界面），而且创建内置Transition需要很少的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transition mFadeTransition = <span class="keyword">new</span> Fade();</span><br></pre></td></tr></table></figure><h2 id="使用Transition"><a href="#使用Transition" class="headerlink" title="使用Transition"></a>使用Transition</h2><p>Transition通常用于切换不同的View树，来响应用户操作等事件。例如：当用户输入搜索关键字并点击搜索按钮，应用切换到搜索结果布局，此时搜索界面执行淡出效果，搜索结果界面执行淡入效果。</p><p>在Activity中利用Transition切换Scene，通过调用静态方法TransitionManager.go()，并传入结束的Scene和代表动画效果的Transition实例，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransitionManager.go(mEndingScene, mFadeTransition);</span><br></pre></td></tr></table></figure><p>当运行Transition实例指定的动画时，系统会将Scene Root中的View树切换成结束Scene中的View树。上一个Transition结束的Scene作为开始的Scene，如果不存在上一个Transition，用户界面的当前状态就是开始Scene。</p><p>如果没有指定Transition实例，TransitionManager会使用AutoTransition对象，它会执行大多数情况下合理的动画效果。</p><h2 id="选择特定的Target-View"><a href="#选择特定的Target-View" class="headerlink" title="选择特定的Target View"></a>选择特定的Target View</h2><p>默认情况下系统对开始和结束Scene中所有的View执行动画。有些时候，只希望仅仅让Scene中的一个子View运行动画。例如，系统不支持ListView对象的动画，在Transition的过程中就必须排除ListView对象。Transition框架允许只让某个特定的View运行动画。</p><p>被选定运行动画的View叫Target。你只能选择Scene中View树的子View作为Target。</p><p>Target是被保存在列表中，从Target list中删除一个或者多个Target，调用removeTarget()方法，该方法必须在执行动画之前调用。调用addTarget()方法添加View到Target list中。</p><h2 id="定义Transition集合"><a href="#定义Transition集合" class="headerlink" title="定义Transition集合"></a>定义Transition集合</h2><p>在Transition系统中可以绑定一系列内置或者自定义的动画到Transition集合中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:transitionOrdering</span>=<span class="string">"sequential"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fade</span> <span class="attr">android:fadingMode</span>=<span class="string">"fade_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeBounds</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fade</span> <span class="attr">android:fadingMode</span>=<span class="string">"fade_in"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过在Activity中调用TransitionInflater.from()方法在代码中获取XML声明的TransitionSet对象。TransitionSet继承自Transition类，所以TransitionManager可以和使用Transition对象一样使用TransitionSet。</p><h2 id="不使用Scene的情况下使用Transition"><a href="#不使用Scene的情况下使用Transition" class="headerlink" title="不使用Scene的情况下使用Transition"></a>不使用Scene的情况下使用Transition</h2><p>改变用户界面不仅仅只有通过切换View树这一种方式，还可以在当前View树中通过添加，修改，删除子View修改界面。</p><p>如果供选择的两个View树有相似的结构，则可以选择使用这种方式。不必为了用户界面的微小差别而创建和维护两个不同的资源文件，可以在资源文件中定义View树然后在代码中修改它的结构。</p><p>如果只是在一个View树改动，则不必创建Scene。而是使用<em>delayed transition</em>的方式在一个View树的两个状态间创建和使用Transition。Transition框架记录View树的当前状态和View的变动，在系统重绘用户界面时对View的变化执行Transition动画。</p><p>在单一的View树中创建<em>delayed transition</em>，遵循以下步骤：</p><ul><li>当事件触发了Transition，调用TransitionManager.beginDelayedTransition()方法，传入待执行动画View的父View和Transition。系统会保存View的当前状态和属性值。</li><li>根据Transition改变子View。系统会记录哪些子View的哪些属性被改变了。</li><li>当系统根据你的变化重绘用户界面时，会在初始状态和最终状态间执行动画。</li></ul><p>下面的代码演示了如何使用<em>delayed transition</em>添加一个TextView到一个View树中：</p><ul><li>View树对应的资源文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/mainLayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/inputText"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加TextView时执行动画</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MainActivity.java */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView mLabelText;</span><br><span class="line"><span class="keyword">private</span> Fade mFade;</span><br><span class="line"><span class="keyword">private</span> ViewGroup mRootView;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the layout</span></span><br><span class="line"><span class="keyword">this</span>.setContentView(R.layout.activity_main);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new TextView and set some View properties</span></span><br><span class="line">mLabelText = <span class="keyword">new</span> TextView();</span><br><span class="line">mLabelText.setText(<span class="string">"Label"</span>).setId(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the root view and create a transition</span></span><br><span class="line">mRootView = (ViewGroup) findViewById(R.id.mainLayout);</span><br><span class="line">mFade = <span class="keyword">new</span> Fade(IN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start recording changes to the view hierarchy</span></span><br><span class="line">TransitionManager.beginDelayedTransition(mRootView, mFade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the new TextView to the view hierarchy</span></span><br><span class="line">mRootView.addView(mLabelText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// When the system redraws the screen to show this update,</span></span><br><span class="line"><span class="comment">// the framework will animate the addition as a fade in</span></span><br></pre></td></tr></table></figure><h2 id="定义Transition的生命周期回调"><a href="#定义Transition的生命周期回调" class="headerlink" title="定义Transition的生命周期回调"></a>定义Transition的生命周期回调</h2><p>Transition的生命周期和Activity相似。它代表从调用TransitionManager.go()方法到动画运行结束过程中的状态。重要的生命状态，系统会执行TransitionListener中的回调方法。</p><p>Transition的生命周期回调是非常有用的，比如，在Scene变化过程中将某个View的属性值从开始View树中复制到结束View树中。由于结束View树直到动画结束才会被初始化，所以简单的复制值会出问题。这种情况下，可以先将值存储在一个变量中，然后当动画结束后再复制它到结束View树中。获取动画结束事件可以在Activity中实现TransitionListener.onTransitionEnd()回调方法。</p><blockquote><p>参考资料</p></blockquote><p><a href="https://developer.android.com/training/transitions/index.html" target="_blank" rel="noopener">Animating Views Using Scenes and Transitions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当用户通过键盘输入或者触发其他事件时界面需要做出变化，比如，某个Activity包含一个搜索框，当用户输入数据并提交的时候，Activity会隐藏搜索框同时显示搜索的结果。&lt;/p&gt;
&lt;p&gt;在这种应用场景(Scenes)下，可以通过在不同的View树上运行动画，来提供连续的视
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Activity&amp;Fragment过渡动画</title>
    <link href="http://yoursite.com/2018/01/18/Activity&amp;Fragment%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/18/Activity&amp;Fragment过渡动画/</id>
    <published>2018-01-18T08:17:36.000Z</published>
    <updated>2018-01-22T08:55:51.964Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0以前，切换Activity或者Fragment时可以通过Activity#overridePendingTransition()或FragmentTransaction#setCustomAnimation()方法增加过场动画，不过效果比较单调，并且只能针对页面中的所有元素，具体使用可参考<a href="https://www.jianshu.com/p/19cc20e6d8a9" target="_blank" rel="noopener">Android转场动画</a>。</p><p>在Android5.0以后，切换Activity或者Fragment时使用过渡动画(Transition Animation)，它是Material Design的一部分，能为页面元素在不同状态之间的移动和转换提供视觉切换效果。过渡动画不但能够提供更加丰富的切换效果，并且在进行切换时，排除特定的页面元素不参与动画，以及对两个页面的共享元素设置动画。</p><p>Android5.0提供了三种过渡类型：</p><ul><li>Enter Transition：进入过渡，决定Activity&amp;Fragment中的视图如何进入屏幕；</li><li>Exit Transition：退出过渡，决定Activity&amp;Fragment中的视图如何退出屏幕；</li><li>Shared Elements Transition：共享元素过渡，决定两个Activity&amp;Fragment之间的共享视图元素如何转换；</li></ul><p>进入和退出效果包括：</p><ul><li>explode：分解，视图从屏幕中间进入或退出；</li><li>slide：滑动，视图从屏幕边缘进入或退出；</li><li>fade：淡出，通过改变视图的透明度，控制视图显示或消失；</li></ul><p>共享元素效果包括：</p><ul><li>changeBounds：改变目标视图的布局边界；</li><li>changeClipBounds：裁剪目标视图边界；</li><li>changeTransform：改变目标视图的缩放比例和旋转角度；</li><li>changeImageTransform：改变目标图片的大小和缩放比例；</li></ul><p>Enter/Exit Transition 确定了非共享元素如何 进入/退出 页面视图；<br>Shared Elements Transition 确定了两个页面共享元素的动画效果。</p><h1 id="Activity进入和退出动画"><a href="#Activity进入和退出动画" class="headerlink" title="Activity进入和退出动画"></a>Activity进入和退出动画</h1><h2 id="通过XML文件设置"><a href="#通过XML文件设置" class="headerlink" title="通过XML文件设置"></a>通过XML文件设置</h2><ul><li>定义Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_explode.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">explode</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 顶部的状态栏以及底部的导航栏不执行动画 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:excludeId</span>=<span class="string">"@android:id/statusBarBackground"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:excludeId</span>=<span class="string">"@android:id/navigationBarBackground"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_fade.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fade</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BaseAppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- enable activity transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowActivityTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 启动新Activity ，当前页面退出的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;</span>@transition/transition_explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Activity首次进入显示的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;</span>@transition/transition_fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 调用finishAfterTransition()时，当前页面返回退出的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 如果没有定Return动画，Return时会使用“反Enter”动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReturnTransition"</span>&gt;</span>@transition/transition_explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 从其它页面返回，重新进入的动画，即第二次进入，可以和首次进入不一样 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 如果没有定Reenter动画，Reenter时会使用“反Exit”动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReenterTransition"</span>&gt;</span>@transition/transition_fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 是否覆盖执行，可以理解成前后两个页面的Transition是同步执行还是顺序执行 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAllowEnterTransitionOverlap"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAllowReturnTransitionOverlap"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过Java代码设置"><a href="#通过Java代码设置" class="headerlink" title="通过Java代码设置"></a>通过Java代码设置</h2><ul><li>定义Transition</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Explode explode = <span class="keyword">new</span> Explode();</span><br><span class="line">explode.setDuration(<span class="number">2000</span>);</span><br><span class="line">explode.setInterpolator(<span class="keyword">new</span> BounceInterpolator());</span><br><span class="line"><span class="comment">// 顶部的状态栏以及底部的导航栏不执行动画</span></span><br><span class="line">explode.excludeTarget(android.R.id.navigationBarBackground, <span class="keyword">true</span>);</span><br><span class="line">explode.excludeTarget(android.R.id.statusBarBackground, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Fade fade = <span class="keyword">new</span> Fade();</span><br><span class="line">fade.setDuration(<span class="number">2000</span>);</span><br><span class="line">fade.setInterpolator(<span class="keyword">new</span> BounceInterpolator());</span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><p>在第一个页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set transition</span></span><br><span class="line">getWindow().setExitTransition(explode);</span><br><span class="line">getWindow().setReenterTransition(fade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set overlap</span></span><br><span class="line">getWindow().setAllowEnterTransitionOverlap(<span class="keyword">false</span>);</span><br><span class="line">getWindow().setAllowReturnTransitionOverlap(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在第二个页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set transition</span></span><br><span class="line">getWindow().setEnterTransition(fade);</span><br><span class="line">getWindow().setReturnTransition(explode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set overlap</span></span><br><span class="line">getWindow().setAllowEnterTransitionOverlap(<span class="keyword">false</span>);</span><br><span class="line">getWindow().setAllowReturnTransitionOverlap(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这样可以达到上面XML文件同样的效果，可以看出，使用代码方式相对比较繁琐，不过，代码方式可以为Transition提供更多属性，比如为Transition添加Listener等。</p><h2 id="为Activity添加动画"><a href="#为Activity添加动画" class="headerlink" title="为Activity添加动画"></a>为Activity添加动画</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个页面启动第二个页面</span></span><br><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>);</span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个页面从第一个页面返回</span></span><br><span class="line"><span class="comment">// 按系统Back键时，会默认调用这个方法</span></span><br><span class="line">finishAfterTransition();</span><br></pre></td></tr></table></figure><h1 id="Activity共享元素动画"><a href="#Activity共享元素动画" class="headerlink" title="Activity共享元素动画"></a>Activity共享元素动画</h1><p>共享元素的过渡动画用于给两个Activity中共享的View添加过渡效果，其使用和进入和退出过的渡动画类似，这里只介绍XML方式添加共享元素过渡动画。</p><ul><li>定义Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_change_bounds.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">changeBounds</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BaseAppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Enable Activity transitions in your theme --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowActivityTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- specify shared element transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        @transition/transition_change_bounds</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        @transition/transition_change_bounds</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 共享元素Enter和Exit的Transition动画是否叠加执行 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementsUseOverlay"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>为两个Activity的layout文件中的共享View添加同样<strong>android:transitionName</strong>属性</p></li><li><p>添加过渡动画</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>,</span><br><span class="line">        Pair.create(view1, <span class="string">"shared_elements1"</span>),</span><br><span class="line">        Pair.create(view2, <span class="string">"shared_elements2"</span>));</span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure><h1 id="Fragment过渡动画"><a href="#Fragment过渡动画" class="headerlink" title="Fragment过渡动画"></a>Fragment过渡动画</h1><p>Fragment的过渡动画使用与Activity基本相同，但是会有一些小区别：</p><ul><li><p>进入和退出效果过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。</p></li><li><p>共享元素的过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。</p></li><li><p>Activity的Transition是通过调用startActivity()和finishAfterTransition()直接启动的，Fragment的Transition是在Fragment被add, remove, attach, detach, show或hidden后由FragmentTransaction自动启动的。</p></li><li><p>共享元素应该在transaction(事务)提交前调用addSharedElement(View, String)方法，声明为FragmentTransaction的一部分。</p></li></ul><blockquote><p>参考资料</p></blockquote><p><a href="https://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="noopener">Getting Started with Activity &amp; Fragment Transitions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0以前，切换Activity或者Fragment时可以通过Activity#overridePendingTransition()或FragmentTransaction#setCustomAnimation()方法增加过场动画，不过效果比较单调，并且只
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>布局动画</title>
    <link href="http://yoursite.com/2018/01/18/%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/18/布局动画/</id>
    <published>2018-01-18T02:22:24.000Z</published>
    <updated>2018-01-18T04:32:40.643Z</updated>
    
    <content type="html"><![CDATA[<p>Android动画机制提供了视图动画、属性动画和可绘制动画，这些动画都是针对单个View对象的，而布局动画(Layout Animation)作用的对象是ViewGroup，它可以在ViewGroup布局子View时，为子View添加相应的动画效果。</p><h1 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h1><p>LayoutAnimation在API Level 1就已经提供了，它对ViewGroup所有的子View都产生动画效果。LayoutAnimation有XML文件和Java代码两种使用方式。</p><h2 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h2><ul><li>定义layoutAnimation</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">animation: 指定动画资源animation, 注意不能使用animator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">animationOrder: 动画执行顺序, normal(正序)、reverse(倒序)、random(随机)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delay: ViewGroup中单个子View动画的开始延时, 取值是android:animation所指定动画时长的倍数,</span></span><br><span class="line"><span class="comment">    可以是float, 也可以是百分数, 默认0.5; 比如anim_rotation中定义的动画时长是500ms, 这里delay=1,</span></span><br><span class="line"><span class="comment">    那么在上一个子View的动画执行之后延时500ms执行下一个子View的动画。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/anim_rotation"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"0.5"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在ViewGroup中加载动画</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layoutAnimation="@anim/layout_animation"</span><br></pre></td></tr></table></figure><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载动画</span></span><br><span class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.anim_rotation);</span><br><span class="line"><span class="comment">// 设置布局动画</span></span><br><span class="line">LayoutAnimationController animationController =</span><br><span class="line">        <span class="keyword">new</span> LayoutAnimationController(animation, <span class="number">1f</span>);</span><br><span class="line">animationController.setInterpolator(<span class="keyword">new</span> AccelerateDecelerateInterpolator());</span><br><span class="line">animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line"><span class="comment">// 加载布局动画</span></span><br><span class="line">viewGroup.setLayoutAnimation(animationController);</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><ol><li>系统提供了gridLayoutAnimation用于给Gridview设置布局动画，对应的XML标签为 gridLayoutAnimation，对应的类为GridLayoutAnimationController；</li><li>LayoutAnimation只在在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的；</li></ol></blockquote><h1 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h1><p>LayoutTransition是API Level 11才出现的，其动画效果只有当ViewGroup添加、删除、隐藏、显示子View的时候才会展示出来，所以，LayoutTransition是一个布局改变动画。LayoutTransition也有XML文件和Java代码两种使用方式。</p><h2 id="XML文件-1"><a href="#XML文件-1" class="headerlink" title="XML文件"></a>XML文件</h2><p>使用XML文件只能使用系统默认的LayoutTransition动画效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用系统默认的LayoutTransition动画 --&gt;</span></span><br><span class="line">android:animateLayoutChanges="true"</span><br></pre></td></tr></table></figure><h2 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h2><p>使用Java代码可以自定义LayoutTransition动画效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义LayoutTransition动画</span></span><br><span class="line">LayoutTransition transition = <span class="keyword">new</span> LayoutTransition();</span><br><span class="line">Animator animator = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.animator_rotation);</span><br><span class="line">transition.setAnimator(LayoutTransition.APPEARING, animator);</span><br><span class="line">transition.setDuration(<span class="number">2000</span>);</span><br><span class="line">viewGroup.setLayoutTransition(transition);</span><br></pre></td></tr></table></figure><p>设置自定义动画时，有以下几种方式：</p><ul><li>LayoutTransition.APPEARING：View添加时的动画。</li><li>LayoutTransition.CHANGE_APPEARING：View添加导致布局改变时整个布局容器的动画。</li><li>LayoutTransition.DISAPPEARING：View消失时的动画。</li><li>LayoutTransition.CHANGE_DISAPPEARING：View消失导致布局容改变时整个布局容器的动画。</li><li>LayoutTransition.CHANGE：不是由于View出现或消失造成改变的时候整个布局容器的动画。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android动画机制提供了视图动画、属性动画和可绘制动画，这些动画都是针对单个View对象的，而布局动画(Layout Animation)作用的对象是ViewGroup，它可以在ViewGroup布局子View时，为子View添加相应的动画效果。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>可绘制动画</title>
    <link href="http://yoursite.com/2018/01/17/%E5%8F%AF%E7%BB%98%E5%88%B6%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/17/可绘制动画/</id>
    <published>2018-01-17T10:57:04.000Z</published>
    <updated>2018-01-17T11:01:19.181Z</updated>
    
    <content type="html"><![CDATA[<p>可绘制动画(Drawable Animation)可以按顺序加载一系列的Drawable资源产生动画效果，它的原理类似于播放动画片，一帧一帧展示图片，具体播放使用AnimationDrawable类。</p><p>使用可绘制动画时，首先需要定义其XML文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust1"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust2"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust3"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意要将android:oneshot属性设置为true，这样动画会播放一次，否则，动画会循环播放。定义好的XML文件可作为View的背景图片，具体播放过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable rocketAnimation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">  ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);</span><br><span class="line">  rocketImage.setBackgroundResource(R.drawable.rocket_thrust);</span><br><span class="line">  rocketAnimation = (AnimationDrawable) rocketImage.getBackground();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    rocketAnimation.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意动画的播放方法start()不能在onCreate()方法执行，因为这个时候动画还没被加载到Activity的Window上。如果需要在没有交互的情况下播放可绘制动画，可以在Activity的onWindowFocusChanged()中进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可绘制动画(Drawable Animation)可以按顺序加载一系列的Drawable资源产生动画效果，它的原理类似于播放动画片，一帧一帧展示图片，具体播放使用AnimationDrawable类。&lt;/p&gt;
&lt;p&gt;使用可绘制动画时，首先需要定义其XML文件：&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
