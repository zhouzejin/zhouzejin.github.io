<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou Zejin&#39;s Home</title>
  
  <subtitle>想象力比知识更重要！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-26T07:57:34.529Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhou Zejin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity任务栈和启动模式</title>
    <link href="http://yoursite.com/2018/01/24/Activity%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/24/Activity任务栈和启动模式/</id>
    <published>2018-01-24T08:25:50.000Z</published>
    <updated>2018-01-26T07:57:34.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity任务栈"><a href="#Activity任务栈" class="headerlink" title="Activity任务栈"></a>Activity任务栈</h1><p>一个APP通常有多个Activity，这些Activity通过栈结构保存，栈底是整个任务栈(Task)的发起者。</p><p>当一个APP启动时，如果系统中不存在该APP的任务栈，那么系统会为其创建一个任务栈，此后，这个APP启动的所有Activity都将在这个任务栈中被管理。需要注意的是，一个Task中的Activity可以来自不同的APP，同一个APP的Activity也可能存在于多个Task中。</p><p>在Task中，一个Activity启动另一个Activity时，新的Activity会被置于栈顶，并处于活动状态，而启动它的Activity依然保留在Task中，处于停止状态，当用户按返回键或者调用finish()方法时，系统会弹出栈顶的Activity，让后面的Activity从停止状态恢复到活动状态。以上是Task管理Activity的一般流程，当需要特殊处理时，就需要使用Activity的启动模式。</p><h1 id="通过Manifest声明启动模式"><a href="#通过Manifest声明启动模式" class="headerlink" title="通过Manifest声明启动模式"></a>通过Manifest声明启动模式</h1><p>可以在AndroidManifest文件中，为Activity声明启动模式，一共能声明四种启动模式：standard、singleTop、singleTask、singleInstance，下面分别进行介绍。</p><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>默认的启动模式，每次启动Activity都会创建一个新的实例。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个Task，也可以位于不同的Task。</p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>在singleTop模式下，启动一个Activity时，系统会判断当前Task中的栈顶Activity是否是要启动的Activity，如果是则不创建新的Activity，然后直接引用这个Activity，并调用其<strong>onNewIntent()</strong>方法；如果不是，则新建该Activity的实例，并将其置于栈顶。</p><p>因此，在同一个Task中，声明为singleTop模式的Activity也会存在多个实例，只不过这些实例不会相邻。</p><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>在singleTask模式下，只允许<strong>一个</strong>包含该Activity实例的Task存在。</p><p>singleTask模式下，Activity的启动方式与<em>android:taskAffinity</em>相关。当B是singleTask模式时，以A启动B来说：</p><ul><li><p>当A和B的taskAffinity相同时：第一次创建B的实例时，<strong>并不会启动新的Task</strong>，而是直接将B添加到A所在的Task；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其<strong>onNewIntent()</strong>方法。</p></li><li><p>当A和B的taskAffinity不同时：第一次创建B的实例时，<strong>会启动新的Task</strong>，然后将B添加到新建的Task中；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其<strong>onNewIntent()</strong>方法。</p></li></ul><p>注意，当要启动的Activity在其它APP的Task中，会在返回栈(Back Stack)中将要启动Activity所在的Task置于当前Task之前，具体过程如下图所示：</p><p><img src="/uploads/android/singletask_backstack.png" alt="singleTask启动模式"></p><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>singleInstance模式下，任意时刻只允许存在唯一的Activity实例，而且该Activity所在的Task不能容纳除该Activity之外的其他Activity实例。其它Activity要启动该Activity，只需要打开这个分离的Task，并调用其<strong>onNewIntent()</strong>方法。</p><p>singleInstance模式经常用于需要与应用分离的界面，该模式的Activity实例即使启动其它Activity，这些Activity也会自动运行于另一个Task中。</p><p>singleInstance与singleTask一个明显区别是：singleTask所在的Task中能有其它的Activity，而singleInstance的Task中不能有其他Activity。</p><p><strong>注意</strong></p><blockquote><p>如果ActivityA处于singleTask或singleInstance启动模式，当ActivityA通过startActivityForResult()方法启动另一个ActivityB时，将会直接返回RESULT_CANCELED，而不会等待ActivityB返回。因为Android系统不允许不同的Task之间直接传递数据，如果有这样的需要，只能通过onNewIntent()方法使用Intent传递。</p></blockquote><h1 id="通过Intent-Flags声明启动模式"><a href="#通过Intent-Flags声明启动模式" class="headerlink" title="通过Intent Flags声明启动模式"></a>通过Intent Flags声明启动模式</h1><p>除了在AndroidManifest文件中声明启动模式，还可以在启动Activity时，通过Intent中声明启动模式，这种Flag存在多个，下面介绍几个常用的启动Flag。</p><ul><li>Intent.FLAG_ACTIVITY_NO_HISTORY</li></ul><p>如果一个Activity是由该模式启动，当这个Activity再去启动其它Activity后，这个Activity就会被销毁，不会保留在Task中。</p><ul><li>Intent.FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>这个Flag的效果与singleTop启动模式的效果相同。</p><ul><li>Intent.FLAG_ACTIVITY_NEW_TASK</li></ul><p>这个Flag的效果会受到<strong>taskAffinity</strong>属性影响，当B声明为该模式，以A启动B来说：</p><p>当A和B的taskAffinity相同时，与standard模式效果一样，每次都在当前Task新建B的实例。</p><p>当A和B的taskAffinity不同时，如果是首次启动，会新建一个Task，并将该Activity实例添加到Task中；如果再次启动，只会把该Activity所在Task置于前台，但是<strong>不会</strong>将该Activity置于栈顶，也<strong>不会</strong>调用其onNewIntent()方法。</p><p>该Flag通常用于其它组件启动一个Activity，因为其它组件不存在任何Task中，<strong>可能</strong>需要新建一个Task管理Activity实例，比如，使用Service启动Activity的场景。不过，当系统存在一个与其taskAffinity属性相同的Task时，这时就不会新建Task，而会直接在这个Task中新建Activity实例。</p><ul><li>Intent.FLAG_ACTIVITY_CLEAR_TOP</li></ul><p>如果要启动的Activity在<strong>当前</strong>的Task中，会销毁该Activity之上的所有其它Activity，从而将其置于栈顶；否则，在当前Task新建Activity实例。</p><p>不过，当要启动的Activity同时被声明为<strong>standard模式</strong>时，该Activity实例也会跟着其它Activity从栈顶弹出，然后重新创建该Activity。之所以这样，是因为standard模式下，总是创建新实例响应Intent。</p><p>总的来说，该模式只会清空栈顶，是通过新建实例还是通过onNewIntent()响应Intent启动消息，要看该Activity的其它启动模式。</p><p>通常将FLAG_ACTIVITY_CLEAR_TOP与FLAG_ACTIVITY_NEW_TASK混合使用，来定位存在于其他Task中的Activity实例，并将其置于栈顶。</p><ul><li>Intent.FLAG_ACTIVITY_CLEAR_TASK</li></ul><p>这个Flag用来清空Task，单独使用没有什么效果，通常与FLAG_ACTIVITY_NEW_TASK混合使用，这时会受到<strong>taskAffinity</strong>属性影响，当B声明为该模式，以A启动B来说：</p><p>当A和B的taskAffinity相同时，清空当前Task，并在当前Task中新建Activity实例。</p><p>当A和B的taskAffinity不同时，如果首次启动，新建Task，并在新Task新建Activity实例；如果再次启动，则清空实例所在的Task，再新建Activity。</p><p><strong>注意</strong></p><blockquote><p>通过Intent Flags声明的启动模式能够覆盖通过Manifest文件声明的启动模式，因此，如果它们之间有冲突时，以Flags为准。</p></blockquote><h1 id="Task相关的属性"><a href="#Task相关的属性" class="headerlink" title="Task相关的属性"></a>Task相关的属性</h1><p>除了用启动模式可以控制Task，还可以使用Task相关的属性控制Task，这些属性在Manifest文件的Activity节点声明，常用的有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:taskAffinity="string"</span><br><span class="line">android:allowTaskReparenting=["true" | "false"]</span><br><span class="line">android:alwaysRetainTaskState=["true" | "false"]</span><br><span class="line">android:clearTaskOnLaunch=["true" | "false"]</span><br><span class="line">android:finishOnTaskLaunch=["true" | "false"]</span><br></pre></td></tr></table></figure><h2 id="处理Affinity"><a href="#处理Affinity" class="headerlink" title="处理Affinity"></a>处理Affinity</h2><ul><li>taskAffinity</li></ul><p>介绍启动模式的时候已经提到过这个属性。每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p><ul><li>allowTaskReparenting</li></ul><p>是否允许activity重新指定Task，默认值是false。</p><p>如果一个Activity的allowTaskReparenting设置为true，它进入后台后，当一个和它有相同taskAffinity属性的Task进入前台时，它会重新宿主，进入到该前台的Task中。</p><h2 id="清空任务栈"><a href="#清空任务栈" class="headerlink" title="清空任务栈"></a>清空任务栈</h2><p>一般来说，如果一个Task很长时间没有被用户使用，那么系统会清空这个Task中除了栈底Activity(Root Activity)之外的所有其它Activity，当用户重新进入这个Task时，只有Root Activity会被恢复。可以使用以下属性修改系统的这个默认行为。</p><ul><li>alwaysRetainTaskState</li></ul><p>默认值是false，如果将Root Activity的这个属性设置为true，那么该Activity所在的Task将不会被清空，即使很长时间不使用，这个Task中所有Activity的状态都会被保存。</p><ul><li>clearTaskOnLaunch</li></ul><p>默认值是false，如果将Root Activity的这个属性设置为true，不管用户什么时候离开该Activity所在的Task，系统会立刻清空这个Task中除了Root Activity之外的所有其它Activity，这个行为与alwaysRetainTaskState刚好相反。</p><ul><li>finishOnTaskLaunch</li></ul><p>默认值是false，如果某个Activity的finishOnTaskLaunch属性设置位true，只要你一离开该Activity所在的Task, 系统会立刻清除这个Activity, 不管这个Activity在Task的任何位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity任务栈&quot;&gt;&lt;a href=&quot;#Activity任务栈&quot; class=&quot;headerlink&quot; title=&quot;Activity任务栈&quot;&gt;&lt;/a&gt;Activity任务栈&lt;/h1&gt;&lt;p&gt;一个APP通常有多个Activity，这些Activity通过栈结构
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Activity状态和生命周期</title>
    <link href="http://yoursite.com/2018/01/24/Activity%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/01/24/Activity状态和生命周期/</id>
    <published>2018-01-24T06:10:06.000Z</published>
    <updated>2018-01-26T01:41:11.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity状态"><a href="#Activity状态" class="headerlink" title="Activity状态"></a>Activity状态</h1><p>Activity有多种状态，并且在这些状态之间可以相互切换，从而控制自己的生命周期。</p><ul><li>Resumed</li></ul><p>这个状态的Activity处于Activity任务栈的最顶层，对用户可见，并且具有焦点，能与用户进行交互。</p><ul><li>Paused</li></ul><p>当Activity失去焦点，被一个非全屏的或者透明的Activity覆盖时，Activity就处于Paused状态。这时，Activity不能与用户进行交互，但是，其状态信息、成员变量等还被系统保持着，只有在系统内存将要耗尽时，才会被系统回收。</p><ul><li>Stopped</li></ul><p>当Activity被另一个Activity完全覆盖时会进入到Stopped状态，这时，Activity不可见，但也保持了所有的状态信息和成员变量，不过，相比Paused状态，系统会优先回收Stopped状态的Activity。</p><ul><li>Destroyed</li></ul><p>当Activity被系统回收或调用finish()方法后，Activity就处于Destroyed状态。</p><h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><p>下面以一张图来展示Activity生命周期（来自于Android官方文档）：</p><p><img src="/uploads/android/activity_lifecycle.png" alt="Activity生命周期"></p><h2 id="Activity启动和销毁过程"><a href="#Activity启动和销毁过程" class="headerlink" title="Activity启动和销毁过程"></a>Activity启动和销毁过程</h2><p>当系统启动Activity时，首先调用onCreate()之后，接着调用onStart()，然后调用onResume()进入Active/Running状态。</p><p>当系统销毁Activity时，如果是正常的销毁流程，会依次调用onPause()、onStop()和onDestory()，让Activity回到Destroyed状态；如果是系统回收内存资源进行的销毁，可能不会调用onDestory()甚至onStop()方法。</p><p>根据Activity启动和销毁过程，可以在相关方法中做一些特定操作：</p><ul><li>onCreate()：创建UI并加载数据，开启后台线程，初始化成员变量。</li><li>onDestory()：释放所有还保留着的系统资源，特别注意要关闭开启的后台线程（对象引用在Activity销毁时会自动清除，但是线程不会）。</li></ul><h2 id="Activity暂停和恢复过程"><a href="#Activity暂停和恢复过程" class="headerlink" title="Activity暂停和恢复过程"></a>Activity暂停和恢复过程</h2><p>Activity暂停时会调用onPause()方法，暂停结束后，会调用onResume()方法恢复Activity的状态。</p><p>根据Activity暂停和恢复过程，可以在相关方法中做一些特定操作：</p><ul><li>onPause()：暂停不需要在Paused状态运行的操作，比如Music、Video和Animation等，释放不需要在Paused状态使用的系统资源，比如Camera、Sensor、Receivers等；注意onPause()方法运行时间比较短，不要在里面做耗时操作，比如保存数据、请求网络、执行数据库事务等，不过，可以在onStop()方法中做这些耗时的操作。</li><li>onResume()：开启onPause()中暂停的操作，重新初始化onPause()中释放的资源。</li></ul><h2 id="Activity停止和重新启动过程"><a href="#Activity停止和重新启动过程" class="headerlink" title="Activity停止和重新启动过程"></a>Activity停止和重新启动过程</h2><p>当Activity处于Paused状态时，通常会有两种可能：调用onResume()方法恢复Activity；调用onStop()方法，停止Activity。</p><p>Activity停止后会处于后台，如果要重新启动，会调用onReStart()和onStart()方法。</p><p>根据Activity停止和重新启动过程，可以在相关方法中做一些特定操作：</p><ul><li>onStop()：释放几乎所有系统资源，因为大部分系统资源在Activity不可见时不会再使用，比如注销在onStart()中开启的，能够影响UI的Receivers；特别要注意释放那些可能造成内存泄露的系统资源，因为系统可能会在内存不足的时候跳过onDestory()方法销毁Activity；另外，还可以做一些耗时的关闭操作，比如保存用户的草稿数据到数据库中。</li><li>onReStart()：只有在从后台恢复到前台时才会调用onReStart()方法。</li><li>onStart()：初始化一些影响UI系统资源，比如注册能够影响UI的Receivers等。</li></ul><h2 id="Activity重新创建过程"><a href="#Activity重新创建过程" class="headerlink" title="Activity重新创建过程"></a>Activity重新创建过程</h2><p>当Activity处于Paused或Stopped状态时，系统会因为内存不足回收Activity，这时，系统会将Activity的状态通过onSaveInstanceState()方法保存到Bundle对象中。当重新创建Activity时，Bundle对象会被传递到onRestoreInstanceState()和onCreate()方法中，这样就可以通过Bundle对象恢复Activity的状态。Android系统已经默认实现了系统控件的状态保存和恢复，不过只支持提供了android:id属性的View。</p><p>只有当前Activity离开前台，并且有被销毁的可能时，才会调用onSaveInstanceState()方法，如果调用finish()方法正常结束Activity的时候，该方法不会被调用。另外，在横竖屏切换时，系统也会调用onSaveInstanceState()方法保存状态数据，然后再去恢复Activity的状态。</p><p>onSaveInstanceState()方法一般用来保存Activity的状态数据，如果要保存需要持久化的数据，应该在Activity在前台的时候，寻找合适的时机去保存，如果找不到合适的时机，可以在onStop()方法中进行。</p><p>onSaveInstanceState()方法会在onPause()方法之后、onStop()方法之前调用；onRestoreInstanceState()方法会在onStart()方法之后调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity状态&quot;&gt;&lt;a href=&quot;#Activity状态&quot; class=&quot;headerlink&quot; title=&quot;Activity状态&quot;&gt;&lt;/a&gt;Activity状态&lt;/h1&gt;&lt;p&gt;Activity有多种状态，并且在这些状态之间可以相互切换，从而控制自己的生
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>阴影和裁剪View及Drawable着色</title>
    <link href="http://yoursite.com/2018/01/23/%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A3%81%E5%89%AAView%E5%8F%8ADrawable%E7%9D%80%E8%89%B2/"/>
    <id>http://yoursite.com/2018/01/23/阴影和裁剪View及Drawable着色/</id>
    <published>2018-01-23T12:35:47.000Z</published>
    <updated>2018-01-24T05:46:15.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阴影效果"><a href="#阴影效果" class="headerlink" title="阴影效果"></a>阴影效果</h1><p>Android5.0以前，通常用X和Y两个属性表示View的平面位置，而在Android5.0中，增加了一个新属性Z，对应于垂直方向的位置，让View具有立体的效果，Z属性通过阴影的大小表示View的高低。</p><p>View的Z值有两部分组成：</p><ul><li>elevation：静态的，通过android:elevation或 View.setElevation()方法进行设置。</li><li>translationZ：动态的，用来实现动画效果，通过View.setTranslationZ()方法设置。</li></ul><p>Z = elevation + translationZ</p><p>可以使用 ViewPropertyAnimator.z()和ViewPropertyAnimator.translationZ()方法实现elevation属性的动画效果；</p><p>还可以使用StateListAnimator声明elevation动画，比如Button按下的动画效果就是这样实现的。</p><h1 id="自定义阴影轮廓"><a href="#自定义阴影轮廓" class="headerlink" title="自定义阴影轮廓"></a>自定义阴影轮廓</h1><p>View的背景形状决定了阴影的轮廓，所以，可以使用shape标签自定义形状作为View的background属性，从而自定义阴影的轮廓。</p><p>另外，还可以通过代码自定义View的阴影轮廓，一般需要以下几个步骤：</p><ul><li>新建一个继承于ViewOutlineProvider的类；</li><li>重载getOutline()方法自定义轮廓；</li><li>使用View.setOutlineProvider()方法为View设置自定义的轮廓；</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewOutlineProvider outlineProvider = <span class="keyword">new</span> ViewOutlineProvider() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutline</span><span class="params">(View view, Outline outline)</span> </span>&#123;</span><br><span class="line">        outline.setRoundRect(<span class="number">0</span>, <span class="number">0</span>, view.getWidth() + <span class="number">10</span>, view.getHeight() + <span class="number">10</span>, <span class="number">30f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">view.setOutlineProvider(outlineProvider);</span><br></pre></td></tr></table></figure><p>默认的ViewOutlineProvider类从View的background属性获取阴影轮廓，如果View不需要阴影效果，可以通过setOutlineProvider()将其设置为null。</p><h1 id="裁剪View"><a href="#裁剪View" class="headerlink" title="裁剪View"></a>裁剪View</h1><p>裁剪(Clip)View可以很容易改变View的形状，可以通过View.setClipToOutline()方法或android:clipToOutline属性将View裁剪至轮廓区域。</p><p>仅支持矩阵、椭圆和圆角矩阵的裁剪，这是由Outline.canClip()方法决定的。</p><p>如果要将视图的裁剪作用到Drawable背景对象上，首先使用View.setOutlineProvider()方法裁剪视图，然后调用View.setClipToOutline()方法，将裁剪作用到View的背景上。</p><p>裁剪视图操作比较耗费系统资源，所以，不要为裁剪视图的形状添加动画，如果要实现这样的动画效果，可以使用Reveal动画，具体可以参考<a href="/2018/01/22/MaterialDesign中的动画/">MaterialDesign中的动画</a>。</p><h1 id="Drawable着色"><a href="#Drawable着色" class="headerlink" title="Drawable着色"></a>Drawable着色</h1><p>从Android5.0开始，可以为Drawable图片资源着色(Tint)，这样可以让图片资源与APP的主题匹配。</p><p>可以通过setTint()方法为BitmapDrawable、NinePatchDrawable以及VectorDrawable对象着色，也可以在XML布局文件中使用android:tint和android:tintMode属性设置着色的颜色和模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阴影效果&quot;&gt;&lt;a href=&quot;#阴影效果&quot; class=&quot;headerlink&quot; title=&quot;阴影效果&quot;&gt;&lt;/a&gt;阴影效果&lt;/h1&gt;&lt;p&gt;Android5.0以前，通常用X和Y两个属性表示View的平面位置，而在Android5.0中，增加了一个新属性Z，对应于
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>使用Palette提取颜色</title>
    <link href="http://yoursite.com/2018/01/23/%E4%BD%BF%E7%94%A8Palette%E6%8F%90%E5%8F%96%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2018/01/23/使用Palette提取颜色/</id>
    <published>2018-01-23T10:59:44.000Z</published>
    <updated>2018-01-23T12:36:37.592Z</updated>
    
    <content type="html"><![CDATA[<p>使用Palette提取当前图片的颜色，然后根据提取的颜色去设置当前主题的颜色，可以让主题动态适应当前页面的色调，做到整个APP颜色基调统一。</p><h1 id="使用支持库"><a href="#使用支持库" class="headerlink" title="使用支持库"></a>使用支持库</h1><p>使用Palette要配置对应的Support Library。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion <span class="number">24</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  implementation <span class="string">'com.android.support:palette-v7:24.2.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建Palette"><a href="#创建Palette" class="headerlink" title="创建Palette"></a>创建Palette</h1><p>下面介绍如何根据一个Bitmap创建一个Palette。</p><h2 id="生成Palette实例"><a href="#生成Palette实例" class="headerlink" title="生成Palette实例"></a>生成Palette实例</h2><p>生成Palette有同步和异步两种方式，同步方式是在当前UI线程中操作，如果想优化UI性能，可以使用异步方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate palette synchronously and return it</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Palette <span class="title">createPaletteSync</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  Palette p = Palette.from(bitmap).generate();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate palette asynchronously and use it on a different</span></span><br><span class="line"><span class="comment">// thread using onGenerated()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPaletteAsync</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  Palette.from(bitmap).generate(<span class="keyword">new</span> PaletteAsyncListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGenerated</span><span class="params">(Palette p)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Use generated instance</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Palette"><a href="#自定义Palette" class="headerlink" title="自定义Palette"></a>自定义Palette</h2><p>生成Palette的时可以使用Palette.Builder对象自定义Palette，比如，可以过滤掉图片中黑色，或者只是用图片的上半部分生成Palette。</p><p>可以使用以下方法跳转Palette的大小和颜色：</p><ul><li>addFilter()：添加颜色过滤器；</li><li>maximumColorCount()：设置生成Palette所使用的最大颜色位数，默认值是16位；</li><li>setRegion()：设置生成Palette的图片区域；</li><li>addTarget()：通过Target.Builder为Palette添加自定义的目标颜色配置；</li></ul><h1 id="获取颜色"><a href="#获取颜色" class="headerlink" title="获取颜色"></a>获取颜色</h1><p>一般Palette会抽取下面6中特征颜色：</p><ul><li>Light Vibrant：充满活力的亮</li><li>Vibrant：充满活力的</li><li>Dark Vibrant：充满活力的黑</li><li>Light Muted：柔和的亮</li><li>Muted：柔和的</li><li>Dark Muted：柔和的黑</li></ul><p>下面以一张图说明这些颜色特征：</p><p><img src="/uploads/android/palette-color-profiles.png" alt="palette-color-profiles"></p><p>具体获取某个特征颜色使用Palette.getXXXColor()方法，比如getMutedColor()。并不是所有的图片都会返回这些颜色特效，所以，在获取颜色时，还需要提供一个默认的返回颜色。</p><h2 id="使用Swatch创建配色方案"><a href="#使用Swatch创建配色方案" class="headerlink" title="使用Swatch创建配色方案"></a>使用Swatch创建配色方案</h2><p>对于每个颜色特征，Palette都提供了一个Palette.Swatch对象用于生产对应的配色方案，获取Palette.Swatch模板代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a palette's vibrant swatch after checking that it exists</span></span><br><span class="line"><span class="keyword">private</span> Palette.<span class="function">Swatch <span class="title">checkVibrantSwatch</span><span class="params">(Palette p)</span> </span>&#123;</span><br><span class="line">  Palette.Swatch vibrant = p.getVibrantSwatch();</span><br><span class="line">  <span class="keyword">if</span> (vibrant != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> vibrant;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Throw error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要检查返回的Swatch是否为空，因为getXXXSwatch()方法没有像getXXXColor()方法那样设置默认的颜色。</p><p>获取了Swatch后，就可以根据Swatch创建主题的配色方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the background and text colors of a toolbar given a</span></span><br><span class="line"><span class="comment">// bitmap image to match</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToolbarColor</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Generate the palette and get the vibrant swatch</span></span><br><span class="line">  <span class="comment">// See the createPaletteSync() and checkVibrantSwatch() methods</span></span><br><span class="line">  <span class="comment">// from the code snippets above</span></span><br><span class="line">  Palette p = createPaletteSync(bitmap);</span><br><span class="line">  Palette.Swatch vibrantSwatch = checkVibrantSwatch(p);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set the toolbar background and text colors</span></span><br><span class="line">  Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">  toolbar.setBackgroundColor(vibrantSwatch.getRgb());</span><br><span class="line">  toolbar.setTitleTextColor(vibrantSwatch.getTitleTextColor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是使用Vibrant特征颜色生成的Toolbar配色方法：</p><p><img src="/uploads/android/palette-color-scheme.png" alt="palette-color-scheme"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Palette提取当前图片的颜色，然后根据提取的颜色去设置当前主题的颜色，可以让主题动态适应当前页面的色调，做到整个APP颜色基调统一。&lt;/p&gt;
&lt;h1 id=&quot;使用支持库&quot;&gt;&lt;a href=&quot;#使用支持库&quot; class=&quot;headerlink&quot; title=&quot;使用支持
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>Material主题</title>
    <link href="http://yoursite.com/2018/01/23/Material%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/23/Material主题/</id>
    <published>2018-01-23T08:52:45.000Z</published>
    <updated>2018-01-23T10:48:51.135Z</updated>
    
    <content type="html"><![CDATA[<p>Material主题能够提供以下功能：</p><ul><li>自定义系统区域的颜色。比如可以修改Status Bar的颜色，使APP的颜色风格和系统的颜色风格保持统一。</li><li>为系统Widget提供触摸反馈动画。具体看以参考<a href="/2018/01/22/MaterialDesign中的动画/">MaterialDesign中的动画</a>。</li><li>提供Activity&amp;Fragment过渡动画。具体可以参考<a href="/2018/01/18/Activity&amp;Fragment过渡动画/">Activity&amp;Fragment过渡动画</a>。</li></ul><p>系统提供了以下默认的Material主题：</p><ul><li>@android:style/Theme.Material (dark version)</li><li>@android:style/Theme.Material.Light (light version)</li><li>@android:style/Theme.Material.Light.DarkActionBar</li></ul><p>Material Dark版本的样式如下图所示：</p><p><img src="/uploads/android/MaterialDark.png" alt="MaterialDark"></p><p>Material Light版本的样式如下图所示：</p><p><img src="/uploads/android/MaterialLight.png" alt="MaterialLight"></p><h1 id="自定义调色板"><a href="#自定义调色板" class="headerlink" title="自定义调色板"></a>自定义调色板</h1><p>继承Material主题后，可以在styles文件中自定义调色板(Color Palette)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- inherit from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Main theme colors --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- your app branding color for the app bar --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimary"</span>&gt;</span>@color/primary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- darker variant for the status bar and contextual app bars --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;</span>@color/primary_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- theme UI controls like checkboxes and text fields --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorAccent"</span>&gt;</span>@color/accent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面属性对应的APP界面的颜色如下图所示：</p><p><img src="/uploads/android/ThemeColors.png" alt="ThemeColors"></p><h1 id="自定义StatusBar颜色"><a href="#自定义StatusBar颜色" class="headerlink" title="自定义StatusBar颜色"></a>自定义StatusBar颜色</h1><p>在Material主题中，使用<em>android:statusBarColor</em>属性定义状态栏的颜色，默认情况下，<em>android:statusBarColor</em>使用<em>android:colorPrimaryDark</em>对应的颜色。还可以通过Window.setStatusBarColor()动态设置状态栏的颜色。</p><h1 id="单个View的主题"><a href="#单个View的主题" class="headerlink" title="单个View的主题"></a>单个View的主题</h1><p>在XML布局文件中，可以为View使用<em>android:theme</em>属性指定特定的主题，这个主题修改只对View及其子View起作用，通常用于改变部分UI的主题颜色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Material主题能够提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义系统区域的颜色。比如可以修改Status Bar的颜色，使APP的颜色风格和系统的颜色风格保持统一。&lt;/li&gt;
&lt;li&gt;为系统Widget提供触摸反馈动画。具体看以参考&lt;a href=&quot;/2018/01
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>SVG和矢量动画</title>
    <link href="http://yoursite.com/2018/01/23/SVG%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/23/SVG和矢量动画/</id>
    <published>2018-01-23T02:37:21.000Z</published>
    <updated>2018-01-23T08:04:03.626Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0(API Level 21)中开始支持SVG的绘制，SVG有以下几个特点：</p><ul><li>可伸缩的矢量图形(Scalable Vector Graphics)</li><li>使用XML格式定义图形</li><li>图形在放大或改变尺寸时，图像不会失真</li><li>基于W3C标准，与Web中的矢量图通用</li></ul><p>Android中可以使用&#60;path&#62;标签绘制SVG，相比Bitmap，SVG最大的优点是缩放不会失真，这样不需要为不同的分辨率设计多套图标，从而缩小APK的体积。</p><h1 id="path标签和SVG指令"><a href="#path标签和SVG指令" class="headerlink" title="path标签和SVG指令"></a>path标签和SVG指令</h1><p>使用&#60;path&#62;标签创建SVG，类似于用指令的方式控制一只画笔绘制图像。&#60;path&#62;标签支持的SVG指令有：</p><ul><li>M = moveto(M X,Y)：将画笔移动到指定的坐标位置，但未发生绘制</li><li>L = lineto(L X,Y)：画直线到指定的坐标位置</li><li>H = horizontal lineto(H X)：画水平线到指定的X坐标位置</li><li>V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置</li><li>C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝塞尔曲线</li><li>S = smooth curveto(S X2,Y2,ENDX,ENDY)：三次贝塞尔曲线，一般跟在C或S命令后面</li><li>Q = quadratic curveto(Q X,Y,ENDX,ENDY)：二次贝塞尔曲线</li><li>T = smooth quadratic curveto(T ENDX,ENDY)：二次贝塞尔曲线，一般跟在Q或T命令后面</li><li>A = elliptical arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线</li><li>Z = closepath()：关闭路径</li></ul><p>使用以上指令时，需要注意：</p><ul><li>坐标轴为以(0,0)为中心，X轴水平向右，Y轴水平向下。</li><li>所有指令大小写均可。大写绝对定位，参照全局坐标系；小写相对定位，参照父容器坐标系。</li><li>指令和数据间的空格可以省略。</li><li>同一指令连续出现多次可以只声明一次。</li></ul><p>指令的详细解释可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="noopener">MDN文档</a>。</p><p>SVG指令的写法固定，并且比较复杂，一般可以通过SVG编辑器来绘制SVG图像，然后将其转换为SVG代码。常用的SVG编辑器有在线的<a href="http://editor.method.ac/" target="_blank" rel="noopener">Method Draw</a>和离线的<a href="https://inkscape.org/en/" target="_blank" rel="noopener">Inkscape</a>。</p><h1 id="SVG绘制"><a href="#SVG绘制" class="headerlink" title="SVG绘制"></a>SVG绘制</h1><p>在Android中，可以使用VectorDrawable创建基于XML的SVG。在XML中创建SVG时，path标签是SVG的最小单位，而group标签将不同的path标签进行组合，最终形成一棵SVG树。</p><p>下面是一个“心形”矢量图的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/drawable/heart.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line">        &lt;!-- SVG的实际大小 --&gt;</span><br><span class="line">        android:width="256dp"</span><br><span class="line">        android:height="256dp"</span><br><span class="line">        <span class="comment">&lt;!-- SVG的划分比例，绘制path时使用的参数就是相对这两个值进行换算的 --&gt;</span></span><br><span class="line">        android:viewportHeight="32"</span><br><span class="line">        android:viewportWidth="32"&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"heart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:rotation</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- draw a path --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"#8fff"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"M20.5,9.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c-1.955,0,-3.83,1.268,-4.5,3</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c-0.67,-1.732,-2.547,-3,-4.5,-3</span></span></span><br><span class="line"><span class="tag"><span class="string">                        C8.957,9.5,7,11.432,7,14</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c0,3.53,3.793,6.257,9,11.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        c5.207,-5.242,9,-7.97,9,-11.5</span></span></span><br><span class="line"><span class="tag"><span class="string">                        C25,11.432,23.043,9.5,20.5,9.5z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="矢量动画"><a href="#矢量动画" class="headerlink" title="矢量动画"></a>矢量动画</h1><p>在Android中，可以使用AnimatedVectorDrawable实现矢量动画。AnimatedVectorDrawable的主要功能是将静态的VectorDrawable和动态的ObjectAnimator连接起来，产生动画效果。因此，矢量动画最终还是通过属性动画实现的。</p><p>使用矢量动画一般有以下几个步骤：</p><ul><li>在res/drawable/路径下利用vector标签定义要进行动画的矢量图</li><li>在res/drawable/路径下利用animated-vector标签定义矢量动画</li><li>在res/anim/路径下利用objectAnimator标签定义矢量动画使用的属性动画</li></ul><p>矢量图中能够产生动画效果的元素是path和group元素，在定义矢量动画时，需要进行动画的元素必须要定义唯一的<em>android:name</em>属性。</p><p>矢量动画的具体示例如下：</p><p>定义矢量图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/vectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"600"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:rotation</span>=<span class="string">"45.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据name属性定义矢量动画：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/animvectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:drawable</span>=<span class="string">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@anim/rotation"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@anim/path_morph"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义矢量动画对应的属性动画：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/animator/rotation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:duration</span>=<span class="string">"6000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:propertyName</span>=<span class="string">"rotation"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueFrom</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueTo</span>=<span class="string">"360"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/animator/path_morph.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"M300,70 l 0,-70 70,0 0,140 -70,0z"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"pathType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，对pathData属性进行动画时，valueTo和valueFrom值必须要兼容，即要有同样数量的命令，并且命令的参数数量要相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0(API Level 21)中开始支持SVG的绘制，SVG有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可伸缩的矢量图形(Scalable Vector Graphics)&lt;/li&gt;
&lt;li&gt;使用XML格式定义图形&lt;/li&gt;
&lt;li&gt;图形在放大或改变尺寸
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MaterialDesign中的动画</title>
    <link href="http://yoursite.com/2018/01/22/MaterialDesign%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/22/MaterialDesign中的动画/</id>
    <published>2018-01-22T11:43:58.000Z</published>
    <updated>2018-01-23T02:45:04.577Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0(API Level 21)以后，可以使用Material Design(MD)中的动画可以给用户提供触摸反馈和一致性交互体验。<a href="/2018/01/18/Activity&amp;Fragment过渡动画/">Activity&amp;Fragment过渡动画</a>就是MD中动画的一种，接下来介绍MD中其它类型的动画。</p><h1 id="Ripple-Animation"><a href="#Ripple-Animation" class="headerlink" title="Ripple Animation"></a>Ripple Animation</h1><p>MD大量使用了Ripple效果，即点击后View后，产生波纹效果，这个效果主要用于触摸反馈。</p><p>可以通过如下代码设置View的波纹背景：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 有边界波纹</span><br><span class="line">android:background="?android:attr/selectableItemBackground"</span><br><span class="line"></span><br><span class="line">// 无边界波纹</span><br><span class="line">android:foreground="?android:attr/selectableItemBackgroundBorderless"</span><br></pre></td></tr></table></figure><p>如果要修改默认波纹的颜色，可以使用主题中<em>android:colorControlHighlight</em>属性进行设置。</p><p>还可以在XML文件中，直接创建Ripple效果的背景资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/drawable/ripple_sample --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"@color/colorPrimary"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"oval"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Reveal-Animation"><a href="#Reveal-Animation" class="headerlink" title="Reveal Animation"></a>Reveal Animation</h1><p>Reveal动画为显示或隐藏一组UI元素提供视觉一致性体验，具体表现为一个View以圆的形式展开。使用ViewAnimationUtils.createCircularReveal()方法创建Reveal动画。</p><p>展现隐藏的View：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// previously invisible view</span></span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the center for the clipping circle</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the final radius for the clipping circle</span></span><br><span class="line"><span class="keyword">float</span> finalRadius = (<span class="keyword">float</span>) Math.hypot(cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the animator for this view (the start radius is zero)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the view visible and start the animation</span></span><br><span class="line">myView.setVisibility(View.VISIBLE);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><p>隐藏可见的View：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// previously visible view</span></span><br><span class="line"><span class="keyword">final</span> View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the center for the clipping circle</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the initial radius for the clipping circle</span></span><br><span class="line"><span class="keyword">float</span> initialRadius = (<span class="keyword">float</span>) Math.hypot(cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the animation (the final radius is zero)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the view invisible when the animation is done</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the animation</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h1 id="View-State-Changes-Animation"><a href="#View-State-Changes-Animation" class="headerlink" title="View State Changes Animation"></a>View State Changes Animation</h1><p>在Android5.0以后，可以为View的状态改变设置一个状态切换动画。</p><h2 id="StateListAnimator"><a href="#StateListAnimator" class="headerlink" title="StateListAnimator"></a>StateListAnimator</h2><p>StateListAnimator作为视图改变时的动画效果时，通常使用Selector进行设置。示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- animate the translationZ property of a view when pressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"@android:integer/config_shortAnimTime"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- you could have other objectAnimator elements</span></span><br><span class="line"><span class="comment">             here for "x" and "y", or other properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_pressed</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_focused</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义好对应的XML文件后，将其作为View的<em>android:stateListAnimator</em>属性，就可以使用对应的动画。</p><p>同样的，可以在代码中调用AnimatorInflater.loadStateListAnimator()方法加载XML文件，然后通过View.setStateListAnimator()方法将动画设置到对应的View上。</p><p>当时用Material主题时，Button默认带有<em>translationZ</em>的动画，如果不需要这个动画，可以将<em>android:stateListAnimator</em>属性设置为<em>@null</em>。</p><h2 id="AnimatedStateListDrawable"><a href="#AnimatedStateListDrawable" class="headerlink" title="AnimatedStateListDrawable"></a>AnimatedStateListDrawable</h2><p>AnimatedStateListDrawable可以为View的状态切换设置<a href="/2018/01/17/可绘制动画/">可绘制动画</a>，Android5.0中很多系统组件就使用了这样的的动画效果，具体可以通过animated-selector进行定义，示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-selector</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provide a different drawable for each state--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/pressed"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableP"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/focused"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_focused</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@id/default"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableD"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- specify a transition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">android:fromId</span>=<span class="string">"@+id/default"</span> <span class="attr">android:toId</span>=<span class="string">"@+id/pressed"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animation-list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt2"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0(API Level 21)以后，可以使用Material Design(MD)中的动画可以给用户提供触摸反馈和一致性交互体验。&lt;a href=&quot;/2018/01/18/Activity&amp;amp;Fragment过渡动画/&quot;&gt;Activity&amp;amp;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>过渡动画框架</title>
    <link href="http://yoursite.com/2018/01/22/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/01/22/过渡动画框架/</id>
    <published>2018-01-22T02:54:49.000Z</published>
    <updated>2018-01-22T07:38:11.791Z</updated>
    
    <content type="html"><![CDATA[<p>当用户通过键盘输入或者触发其他事件时界面需要做出变化，比如，某个Activity包含一个搜索框，当用户输入数据并提交的时候，Activity会隐藏搜索框同时显示搜索的结果。</p><p>在这种应用场景(Scenes)下，可以通过在不同的View树上运行动画，来提供连续的视觉效果。这些动画不仅仅响应了用户的操作，也帮助用户学习应用是如何工作的。</p><p>Android的过渡动画框架(Transitions Framework)可以方便的实现两个View树之间的动画。它通过动态的改变View的属性从而达到动画变换的效果。Android系统内置了常用的动画效果，也可以自定义过渡动画和过渡生命周期。</p><p>在Android4.4之前可以使用<a href="/2018/01/18/布局动画/">布局动画</a>实现简单过渡动画效果，但是对于复杂的场景，布局动画使用起来不太方便，所以，Android4.4引入了过渡动画框架来方便实现这样的应用场景。</p><p>过渡动画的本质还是属性动画，只不过是对属性动画做了一层封装，目的是方便开发者实现ViewGroup的过渡动画效果。</p><h1 id="场景和过渡动画"><a href="#场景和过渡动画" class="headerlink" title="场景和过渡动画"></a>场景和过渡动画</h1><p>过渡动画框架可以在两个不同的View树之间运行过渡动画，它对View树中的所有View执行一个或者多个动画，框架的有如下特性：</p><ul><li>GroupView级别的动画：对View树中的所有View执行动画</li><li>基于变化的动画：动画的运行是基于View属性的开始值和结束值</li><li>内置动画：包含了一些预置的动画，比如淡入淡出和移动</li><li>支持资源文件：可以通过布局文件中加载View树和内置动画</li><li>声明周期回调：通过回调可以控制动画的执行过程</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>过渡动画框架和动画的关系如下所示：</p><p><img src="/uploads/android/过渡动画框架原理.png" alt="过渡动画框架原理"></p><p>Transitions框架和View动画是平行关系。Transitions框架主要用于存储View树的状态，在切换View树时执行定义的动画，从而实现过渡效果。</p><p>Transitions框架提供了抽象的Scenes、Transition以及TransitionManagers。使用过程中，首先，为执行动画的View树创建初始Scene；然后，为动画创建Transition；最后，使用TransitionManager对象启动动画，并传入创建的Transition和结束Scene。</p><h2 id="场景-Scenes"><a href="#场景-Scenes" class="headerlink" title="场景(Scenes)"></a>场景(Scenes)</h2><p>Scene存储了View树的状态，即View树中所有View的属性值，这样就可以通过改变属性值，从当前Scene变换到指定的Scene。</p><p>创建Scene可以通过Layout文件或者在代码中使用GroupView对象。通过代码创建Scene，用于动态生成View树，或者在运行时改变View树。</p><p>通常情况下，并不需要创建开始Scene。当使用Transition时，系统会使用上一个Transition的结束Scene作为下一个Transition的开始Scene；如果之前没有使用过Transition，系统会收集View树的当前状态作为开始Scene。</p><p>可以定义Scene变化的Action。比如，在Scene变化后，清除View的设置。</p><p>Scene除了存储View树的属性值，同时也存储了View树的父视图引用，这个引用称为Scene Root，Scene的变换和动画都发生在Scene Root中。</p><h2 id="过渡动画-Transition"><a href="#过渡动画-Transition" class="headerlink" title="过渡动画(Transition)"></a>过渡动画(Transition)</h2><p>在Transitions框架中，创建了一系列的帧去描述View树从开始Scene到结束Scene的变化。动画的信息都存储在Transition对象中，可以使用TransitionManager对象为动画指定一个Transition。Transition可以用于两个不同的Scene，或者同一个Scene的不同状态。</p><p>系统内置了一组常用的Transition，比如淡入淡出，缩放等。可以根据框架中提供的API自定义一个Transition来创建想要动画的效果。也可以组合自定义或者内置Transition，作为一个Transition集合，达到不同的动画效果。</p><p>系统会监听Transition整个生命周期，这一点和Activity相似。每个重要的生命周期状态，都会执行一个回调函数，在函数中你可以根据不同的状态调整用户界面。</p><h2 id="限制-Limitation"><a href="#限制-Limitation" class="headerlink" title="限制(Limitation)"></a>限制(Limitation)</h2><ul><li>应用于SurfaceView的动画显示会有问题。SurfaceView的更新通过非UI线程，它的更新与动画中的其他View可能会不同步。</li><li>用于TextureView的某些特定Transition类型会产生一些不同与期望的动画效果。</li><li>继承于AdapterView的类，例如ListView，管理子View的方式与Transition框架不兼容。如果将动画应用于这些View，会出问题。</li><li>TextView执行缩放动画时，在动画完成前，文本会被放置到新得到位置。为了避免此问题，不要在包含文本的TextView中使用缩放的动画。</li></ul><h1 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h1><p>Transitions框架可以在开始和结束的Scene中执行过渡动画。开始Scene通常由用户界面的当前状态决定。结束Scene，可以通过资源文件或者使用代码创建。</p><p>注意：单个View树的变换可以不使用Scene，具体使用在下一节介绍。</p><h2 id="使用XML文件创建Scene"><a href="#使用XML文件创建Scene" class="headerlink" title="使用XML文件创建Scene"></a>使用XML文件创建Scene</h2><p>通过资源文件可以直接创建Scene对象。当View树不会变化时可以使用这种方式。生成的Scene代表当你创建Scene实例时View树的状态。如果改变了View树，必须重新创建Scene。创建的Scene包含整个资源文件，不允许从部分资源文件中创建Scene。</p><p>从布局文件中创建Scene，首先要从布局文件中获取ViewGroup类型Scene Root对象，接着调用Scene.getSceneForLayout()，参数为Scene Root和布局文件中作为Scene的View树的资源ID。</p><h3 id="为Scene定义Layout"><a href="#为Scene定义Layout" class="headerlink" title="为Scene定义Layout"></a>为Scene定义Layout</h3><p>下面介绍通过相同的Scene Root元素创建两个不同的Scene。通过代码同样可以看到，只需要加载两个不相关的Scene对象，并不需要定义他们的依赖关系。</p><p>示例中的布局为：</p><ul><li>Activity的主布局文件包含一个TextView和一个子布局</li><li>一个相对布局中包含了两个TextView作为第一个Scene</li><li>一个相对布局同样包含两个TextView但是顺序不同作为第二个Scene</li></ul><p>示例中所有的动画发生在Activity主布局文件的子布局中，而主布局文件中的TextView是不变的。</p><p>Activity主布局文件为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/master_layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/title"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Title"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/scene_root"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/a_scene"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该布局文件中定义了一个TextView和一个作为Scene Root的子布局。第一个Scene被包含在主布局文件中。App把它作为应用的初始界面，Scene也会把整个子布局加载起来，因为Transition框架是不能够加载部分布局到Scene中。</p><p>Scene 1的布局定义如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/a_scene.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/scene_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view1</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">1</span>" /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view2</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">2</span>" /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Scene 2包含相同的两个TextView（一样的资源ID），但是他们的顺序和Scene 1不一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/scene_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view2</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">2</span>" /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text_view1</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:text="</span><span class="attr">Text</span> <span class="attr">Line</span> <span class="attr">1</span>" /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从Layout文件中生成Scene"><a href="#从Layout文件中生成Scene" class="headerlink" title="从Layout文件中生成Scene"></a>从Layout文件中生成Scene</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scene mAScene;</span><br><span class="line">Scene mAnotherScene;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the scene root for the scenes in this app</span></span><br><span class="line">mSceneRoot = (ViewGroup) findViewById(R.id.scene_root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the scenes</span></span><br><span class="line">mAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, <span class="keyword">this</span>);</span><br><span class="line">mAnotherScene =</span><br><span class="line">    Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这样，应用就包含了两个基于View树的Scene对象。两个Scene使用同样Scene Root，它通过activity_main.xml中的FrameLayout元素定义。</p><h2 id="使用Java代码创建Scene"><a href="#使用Java代码创建Scene" class="headerlink" title="使用Java代码创建Scene"></a>使用Java代码创建Scene</h2><p>在代码中通过ViewGroup对象同样可以创建Scene实例。当你在代码中需要修改View树的结构或者动态的生成View树时，可以使用这种方式。</p><p>在代码中利用View树创建Scene，使用Scene(sceneRoot, viewHierarchy)构造函数。这个构造函数和Scene.getSceneForLayout()有同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scene mScene;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain the scene root element</span></span><br><span class="line">mSceneRoot = (ViewGroup) mSomeLayoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain the view hierarchy to add as a child of</span></span><br><span class="line"><span class="comment">// the scene root when this scene is entered</span></span><br><span class="line">mViewHierarchy = (ViewGroup) someOtherLayoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a scene</span></span><br><span class="line">mScene = <span class="keyword">new</span> Scene(mSceneRoot, mViewHierarchy);</span><br></pre></td></tr></table></figure><h2 id="创建Scene-Actions"><a href="#创建Scene-Actions" class="headerlink" title="创建Scene Actions"></a>创建Scene Actions</h2><p>当Scene进入和退出时，系统允许自定义Scene Action。通常情况下自定义Action是没有必要的，因为系统会自动处理Scene间的变换。</p><p>Scene Action用于下面几个情况：</p><ul><li>执行动画的View不在Scene的View树里，其执行动画的时机可能在Scene开始或者结束时。</li><li>Transitions框架不支持的View，比如ListView。</li></ul><p>可以将Scene Action定义成Runnable对象，然后作为参数调用Scene.setExitAction()和Scene.setEnterAction()方法。在Transition动画运行之前，开始Scene会调用setExitAction()方法，在Transition动画运行之后，结束Scene会调用setEnterAction()方法。</p><p>注意：不要在开始Scene和结束Scene中的View之间使用Scene Action传递数据。因为结束View树直到动画结束才会被初始化。</p><h1 id="使用过渡动画"><a href="#使用过渡动画" class="headerlink" title="使用过渡动画"></a>使用过渡动画</h1><p>在Transitions框架中，动画创建了一系列的帧描述View树从开始Scene到结束Scene之间的变化。这些变化在Transition框架中使用Transition对象来表示，所有动画的信息都包含在其中。通过TransitionManager对象启动动画，具体使用时，需要传入Transition对象和结束Scene。</p><h2 id="创建Transition"><a href="#创建Transition" class="headerlink" title="创建Transition"></a>创建Transition</h2><p>内置Transition对象的创建方式有两种，可以资源文件定义，也可以直接用代码创建。</p><p>系统提供的内置Transition类型如下所示：</p><table><thead><tr><th>Class</th><th>Tag</th><th>Effect</th></tr></thead><tbody><tr><td>AutoTransition</td><td>&#60;autoTransition/&#62;</td><td>Default transition. Fade out, move and resize, and fade in views, in that order.</td></tr><tr><td>Fade</td><td>&#60;fade/&#62;</td><td>fade_in fades in views;<br> fade_out fades out views;<br> fade_in_out (default) does a fade_out followed by a fade_in.</td></tr><tr><td>ChangeBounds</td><td>&#60;changeBounds/&#62;</td><td>Moves and resizes views.</td></tr></tbody></table><h3 id="通过资源文件中创建Transition"><a href="#通过资源文件中创建Transition" class="headerlink" title="通过资源文件中创建Transition"></a>通过资源文件中创建Transition</h3><p>在资源文件中创建Transition的好处是当你需要修改Transition的定义的时候不用修改Activity中的代码，另一个好处就是将复杂的Transition定义和代码分离。</p><ul><li>创建Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/transition/fade_transition.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fade</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>从资源文件中获取Transition对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transition mFadeTransition =</span><br><span class="line">        TransitionInflater.from(<span class="keyword">this</span>).</span><br><span class="line">        inflateTransition(R.transition.fade_transition);</span><br></pre></td></tr></table></figure><h3 id="通过代码中创建Transition"><a href="#通过代码中创建Transition" class="headerlink" title="通过代码中创建Transition"></a>通过代码中创建Transition</h3><p>这种方式的好处是可以动态的创建Transition对象（如果你在代码中需要修改用户界面），而且创建内置Transition需要很少的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transition mFadeTransition = <span class="keyword">new</span> Fade();</span><br></pre></td></tr></table></figure><h2 id="使用Transition"><a href="#使用Transition" class="headerlink" title="使用Transition"></a>使用Transition</h2><p>Transition通常用于切换不同的View树，来响应用户操作等事件。例如：当用户输入搜索关键字并点击搜索按钮，应用切换到搜索结果布局，此时搜索界面执行淡出效果，搜索结果界面执行淡入效果。</p><p>在Activity中利用Transition切换Scene，通过调用静态方法TransitionManager.go()，并传入结束的Scene和代表动画效果的Transition实例，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransitionManager.go(mEndingScene, mFadeTransition);</span><br></pre></td></tr></table></figure><p>当运行Transition实例指定的动画时，系统会将Scene Root中的View树切换成结束Scene中的View树。上一个Transition结束的Scene作为开始的Scene，如果不存在上一个Transition，用户界面的当前状态就是开始Scene。</p><p>如果没有指定Transition实例，TransitionManager会使用AutoTransition对象，它会执行大多数情况下合理的动画效果。</p><h2 id="选择特定的Target-View"><a href="#选择特定的Target-View" class="headerlink" title="选择特定的Target View"></a>选择特定的Target View</h2><p>默认情况下系统对开始和结束Scene中所有的View执行动画。有些时候，只希望仅仅让Scene中的一个子View运行动画。例如，系统不支持ListView对象的动画，在Transition的过程中就必须排除ListView对象。Transition框架允许只让某个特定的View运行动画。</p><p>被选定运行动画的View叫Target。你只能选择Scene中View树的子View作为Target。</p><p>Target是被保存在列表中，从Target list中删除一个或者多个Target，调用removeTarget()方法，该方法必须在执行动画之前调用。调用addTarget()方法添加View到Target list中。</p><h2 id="定义Transition集合"><a href="#定义Transition集合" class="headerlink" title="定义Transition集合"></a>定义Transition集合</h2><p>在Transition系统中可以绑定一系列内置或者自定义的动画到Transition集合中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:transitionOrdering</span>=<span class="string">"sequential"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fade</span> <span class="attr">android:fadingMode</span>=<span class="string">"fade_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeBounds</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fade</span> <span class="attr">android:fadingMode</span>=<span class="string">"fade_in"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过在Activity中调用TransitionInflater.from()方法在代码中获取XML声明的TransitionSet对象。TransitionSet继承自Transition类，所以TransitionManager可以和使用Transition对象一样使用TransitionSet。</p><h2 id="不使用Scene的情况下使用Transition"><a href="#不使用Scene的情况下使用Transition" class="headerlink" title="不使用Scene的情况下使用Transition"></a>不使用Scene的情况下使用Transition</h2><p>改变用户界面不仅仅只有通过切换View树这一种方式，还可以在当前View树中通过添加，修改，删除子View修改界面。</p><p>如果供选择的两个View树有相似的结构，则可以选择使用这种方式。不必为了用户界面的微小差别而创建和维护两个不同的资源文件，可以在资源文件中定义View树然后在代码中修改它的结构。</p><p>如果只是在一个View树改动，则不必创建Scene。而是使用<em>delayed transition</em>的方式在一个View树的两个状态间创建和使用Transition。Transition框架记录View树的当前状态和View的变动，在系统重绘用户界面时对View的变化执行Transition动画。</p><p>在单一的View树中创建<em>delayed transition</em>，遵循以下步骤：</p><ul><li>当事件触发了Transition，调用TransitionManager.beginDelayedTransition()方法，传入待执行动画View的父View和Transition。系统会保存View的当前状态和属性值。</li><li>根据Transition改变子View。系统会记录哪些子View的哪些属性被改变了。</li><li>当系统根据你的变化重绘用户界面时，会在初始状态和最终状态间执行动画。</li></ul><p>下面的代码演示了如何使用<em>delayed transition</em>添加一个TextView到一个View树中：</p><ul><li>View树对应的资源文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/activity_main.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/mainLayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/inputText"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加TextView时执行动画</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MainActivity.java */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView mLabelText;</span><br><span class="line"><span class="keyword">private</span> Fade mFade;</span><br><span class="line"><span class="keyword">private</span> ViewGroup mRootView;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the layout</span></span><br><span class="line"><span class="keyword">this</span>.setContentView(R.layout.activity_main);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new TextView and set some View properties</span></span><br><span class="line">mLabelText = <span class="keyword">new</span> TextView();</span><br><span class="line">mLabelText.setText(<span class="string">"Label"</span>).setId(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the root view and create a transition</span></span><br><span class="line">mRootView = (ViewGroup) findViewById(R.id.mainLayout);</span><br><span class="line">mFade = <span class="keyword">new</span> Fade(IN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start recording changes to the view hierarchy</span></span><br><span class="line">TransitionManager.beginDelayedTransition(mRootView, mFade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the new TextView to the view hierarchy</span></span><br><span class="line">mRootView.addView(mLabelText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// When the system redraws the screen to show this update,</span></span><br><span class="line"><span class="comment">// the framework will animate the addition as a fade in</span></span><br></pre></td></tr></table></figure><h2 id="定义Transition的生命周期回调"><a href="#定义Transition的生命周期回调" class="headerlink" title="定义Transition的生命周期回调"></a>定义Transition的生命周期回调</h2><p>Transition的生命周期和Activity相似。它代表从调用TransitionManager.go()方法到动画运行结束过程中的状态。重要的生命状态，系统会执行TransitionListener中的回调方法。</p><p>Transition的生命周期回调是非常有用的，比如，在Scene变化过程中将某个View的属性值从开始View树中复制到结束View树中。由于结束View树直到动画结束才会被初始化，所以简单的复制值会出问题。这种情况下，可以先将值存储在一个变量中，然后当动画结束后再复制它到结束View树中。获取动画结束事件可以在Activity中实现TransitionListener.onTransitionEnd()回调方法。</p><blockquote><p>参考资料</p></blockquote><p><a href="https://developer.android.com/training/transitions/index.html" target="_blank" rel="noopener">Animating Views Using Scenes and Transitions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当用户通过键盘输入或者触发其他事件时界面需要做出变化，比如，某个Activity包含一个搜索框，当用户输入数据并提交的时候，Activity会隐藏搜索框同时显示搜索的结果。&lt;/p&gt;
&lt;p&gt;在这种应用场景(Scenes)下，可以通过在不同的View树上运行动画，来提供连续的视
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Activity&amp;Fragment过渡动画</title>
    <link href="http://yoursite.com/2018/01/18/Activity&amp;Fragment%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/18/Activity&amp;Fragment过渡动画/</id>
    <published>2018-01-18T08:17:36.000Z</published>
    <updated>2018-01-22T08:55:51.964Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0以前，切换Activity或者Fragment时可以通过Activity#overridePendingTransition()或FragmentTransaction#setCustomAnimation()方法增加过场动画，不过效果比较单调，并且只能针对页面中的所有元素，具体使用可参考<a href="https://www.jianshu.com/p/19cc20e6d8a9" target="_blank" rel="noopener">Android转场动画</a>。</p><p>在Android5.0以后，切换Activity或者Fragment时使用过渡动画(Transition Animation)，它是Material Design的一部分，能为页面元素在不同状态之间的移动和转换提供视觉切换效果。过渡动画不但能够提供更加丰富的切换效果，并且在进行切换时，排除特定的页面元素不参与动画，以及对两个页面的共享元素设置动画。</p><p>Android5.0提供了三种过渡类型：</p><ul><li>Enter Transition：进入过渡，决定Activity&amp;Fragment中的视图如何进入屏幕；</li><li>Exit Transition：退出过渡，决定Activity&amp;Fragment中的视图如何退出屏幕；</li><li>Shared Elements Transition：共享元素过渡，决定两个Activity&amp;Fragment之间的共享视图元素如何转换；</li></ul><p>进入和退出效果包括：</p><ul><li>explode：分解，视图从屏幕中间进入或退出；</li><li>slide：滑动，视图从屏幕边缘进入或退出；</li><li>fade：淡出，通过改变视图的透明度，控制视图显示或消失；</li></ul><p>共享元素效果包括：</p><ul><li>changeBounds：改变目标视图的布局边界；</li><li>changeClipBounds：裁剪目标视图边界；</li><li>changeTransform：改变目标视图的缩放比例和旋转角度；</li><li>changeImageTransform：改变目标图片的大小和缩放比例；</li></ul><p>Enter/Exit Transition 确定了非共享元素如何 进入/退出 页面视图；<br>Shared Elements Transition 确定了两个页面共享元素的动画效果。</p><h1 id="Activity进入和退出动画"><a href="#Activity进入和退出动画" class="headerlink" title="Activity进入和退出动画"></a>Activity进入和退出动画</h1><h2 id="通过XML文件设置"><a href="#通过XML文件设置" class="headerlink" title="通过XML文件设置"></a>通过XML文件设置</h2><ul><li>定义Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_explode.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">explode</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 顶部的状态栏以及底部的导航栏不执行动画 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:excludeId</span>=<span class="string">"@android:id/statusBarBackground"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:excludeId</span>=<span class="string">"@android:id/navigationBarBackground"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_fade.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fade</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BaseAppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- enable activity transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowActivityTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 启动新Activity ，当前页面退出的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;</span>@transition/transition_explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Activity首次进入显示的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;</span>@transition/transition_fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 调用finishAfterTransition()时，当前页面返回退出的动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 如果没有定Return动画，Return时会使用“反Enter”动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReturnTransition"</span>&gt;</span>@transition/transition_explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 从其它页面返回，重新进入的动画，即第二次进入，可以和首次进入不一样 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 如果没有定Reenter动画，Reenter时会使用“反Exit”动画 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReenterTransition"</span>&gt;</span>@transition/transition_fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 是否覆盖执行，可以理解成前后两个页面的Transition是同步执行还是顺序执行 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAllowEnterTransitionOverlap"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAllowReturnTransitionOverlap"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过Java代码设置"><a href="#通过Java代码设置" class="headerlink" title="通过Java代码设置"></a>通过Java代码设置</h2><ul><li>定义Transition</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Explode explode = <span class="keyword">new</span> Explode();</span><br><span class="line">explode.setDuration(<span class="number">2000</span>);</span><br><span class="line">explode.setInterpolator(<span class="keyword">new</span> BounceInterpolator());</span><br><span class="line"><span class="comment">// 顶部的状态栏以及底部的导航栏不执行动画</span></span><br><span class="line">explode.excludeTarget(android.R.id.navigationBarBackground, <span class="keyword">true</span>);</span><br><span class="line">explode.excludeTarget(android.R.id.statusBarBackground, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Fade fade = <span class="keyword">new</span> Fade();</span><br><span class="line">fade.setDuration(<span class="number">2000</span>);</span><br><span class="line">fade.setInterpolator(<span class="keyword">new</span> BounceInterpolator());</span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><p>在第一个页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set transition</span></span><br><span class="line">getWindow().setExitTransition(explode);</span><br><span class="line">getWindow().setReenterTransition(fade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set overlap</span></span><br><span class="line">getWindow().setAllowEnterTransitionOverlap(<span class="keyword">false</span>);</span><br><span class="line">getWindow().setAllowReturnTransitionOverlap(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在第二个页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set transition</span></span><br><span class="line">getWindow().setEnterTransition(fade);</span><br><span class="line">getWindow().setReturnTransition(explode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set overlap</span></span><br><span class="line">getWindow().setAllowEnterTransitionOverlap(<span class="keyword">false</span>);</span><br><span class="line">getWindow().setAllowReturnTransitionOverlap(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这样可以达到上面XML文件同样的效果，可以看出，使用代码方式相对比较繁琐，不过，代码方式可以为Transition提供更多属性，比如为Transition添加Listener等。</p><h2 id="为Activity添加动画"><a href="#为Activity添加动画" class="headerlink" title="为Activity添加动画"></a>为Activity添加动画</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个页面启动第二个页面</span></span><br><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>);</span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个页面从第一个页面返回</span></span><br><span class="line"><span class="comment">// 按系统Back键时，会默认调用这个方法</span></span><br><span class="line">finishAfterTransition();</span><br></pre></td></tr></table></figure><h1 id="Activity共享元素动画"><a href="#Activity共享元素动画" class="headerlink" title="Activity共享元素动画"></a>Activity共享元素动画</h1><p>共享元素的过渡动画用于给两个Activity中共享的View添加过渡效果，其使用和进入和退出过的渡动画类似，这里只介绍XML方式添加共享元素过渡动画。</p><ul><li>定义Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- res/transition/transition_change_bounds.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">changeBounds</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">android:interpolator</span>=<span class="string">"@android:interpolator/bounce"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置Transition</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BaseAppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Enable Activity transitions in your theme --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowActivityTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- specify shared element transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        @transition/transition_change_bounds</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        @transition/transition_change_bounds</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 共享元素Enter和Exit的Transition动画是否叠加执行 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementsUseOverlay"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>为两个Activity的layout文件中的共享View添加同样<strong>android:transitionName</strong>属性</p></li><li><p>添加过渡动画</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>,</span><br><span class="line">        Pair.create(view1, <span class="string">"shared_elements1"</span>),</span><br><span class="line">        Pair.create(view2, <span class="string">"shared_elements2"</span>));</span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure><h1 id="Fragment过渡动画"><a href="#Fragment过渡动画" class="headerlink" title="Fragment过渡动画"></a>Fragment过渡动画</h1><p>Fragment的过渡动画使用与Activity基本相同，但是会有一些小区别：</p><ul><li><p>进入和退出效果过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。</p></li><li><p>共享元素的过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。</p></li><li><p>Activity的Transition是通过调用startActivity()和finishAfterTransition()直接启动的，Fragment的Transition是在Fragment被add, remove, attach, detach, show或hidden后由FragmentTransaction自动启动的。</p></li><li><p>共享元素应该在transaction(事务)提交前调用addSharedElement(View, String)方法，声明为FragmentTransaction的一部分。</p></li></ul><blockquote><p>参考资料</p></blockquote><p><a href="https://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="noopener">Getting Started with Activity &amp; Fragment Transitions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0以前，切换Activity或者Fragment时可以通过Activity#overridePendingTransition()或FragmentTransaction#setCustomAnimation()方法增加过场动画，不过效果比较单调，并且只
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>布局动画</title>
    <link href="http://yoursite.com/2018/01/18/%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/18/布局动画/</id>
    <published>2018-01-18T02:22:24.000Z</published>
    <updated>2018-01-18T04:32:40.643Z</updated>
    
    <content type="html"><![CDATA[<p>Android动画机制提供了视图动画、属性动画和可绘制动画，这些动画都是针对单个View对象的，而布局动画(Layout Animation)作用的对象是ViewGroup，它可以在ViewGroup布局子View时，为子View添加相应的动画效果。</p><h1 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h1><p>LayoutAnimation在API Level 1就已经提供了，它对ViewGroup所有的子View都产生动画效果。LayoutAnimation有XML文件和Java代码两种使用方式。</p><h2 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h2><ul><li>定义layoutAnimation</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">animation: 指定动画资源animation, 注意不能使用animator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">animationOrder: 动画执行顺序, normal(正序)、reverse(倒序)、random(随机)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delay: ViewGroup中单个子View动画的开始延时, 取值是android:animation所指定动画时长的倍数,</span></span><br><span class="line"><span class="comment">    可以是float, 也可以是百分数, 默认0.5; 比如anim_rotation中定义的动画时长是500ms, 这里delay=1,</span></span><br><span class="line"><span class="comment">    那么在上一个子View的动画执行之后延时500ms执行下一个子View的动画。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/anim_rotation"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"0.5"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在ViewGroup中加载动画</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layoutAnimation="@anim/layout_animation"</span><br></pre></td></tr></table></figure><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载动画</span></span><br><span class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.anim_rotation);</span><br><span class="line"><span class="comment">// 设置布局动画</span></span><br><span class="line">LayoutAnimationController animationController =</span><br><span class="line">        <span class="keyword">new</span> LayoutAnimationController(animation, <span class="number">1f</span>);</span><br><span class="line">animationController.setInterpolator(<span class="keyword">new</span> AccelerateDecelerateInterpolator());</span><br><span class="line">animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line"><span class="comment">// 加载布局动画</span></span><br><span class="line">viewGroup.setLayoutAnimation(animationController);</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><ol><li>系统提供了gridLayoutAnimation用于给Gridview设置布局动画，对应的XML标签为 gridLayoutAnimation，对应的类为GridLayoutAnimationController；</li><li>LayoutAnimation只在在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的；</li></ol></blockquote><h1 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h1><p>LayoutTransition是API Level 11才出现的，其动画效果只有当ViewGroup添加、删除、隐藏、显示子View的时候才会展示出来，所以，LayoutTransition是一个布局改变动画。LayoutTransition也有XML文件和Java代码两种使用方式。</p><h2 id="XML文件-1"><a href="#XML文件-1" class="headerlink" title="XML文件"></a>XML文件</h2><p>使用XML文件只能使用系统默认的LayoutTransition动画效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用系统默认的LayoutTransition动画 --&gt;</span></span><br><span class="line">android:animateLayoutChanges="true"</span><br></pre></td></tr></table></figure><h2 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h2><p>使用Java代码可以自定义LayoutTransition动画效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义LayoutTransition动画</span></span><br><span class="line">LayoutTransition transition = <span class="keyword">new</span> LayoutTransition();</span><br><span class="line">Animator animator = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.animator_rotation);</span><br><span class="line">transition.setAnimator(LayoutTransition.APPEARING, animator);</span><br><span class="line">transition.setDuration(<span class="number">2000</span>);</span><br><span class="line">viewGroup.setLayoutTransition(transition);</span><br></pre></td></tr></table></figure><p>设置自定义动画时，有以下几种方式：</p><ul><li>LayoutTransition.APPEARING：View添加时的动画。</li><li>LayoutTransition.CHANGE_APPEARING：View添加导致布局改变时整个布局容器的动画。</li><li>LayoutTransition.DISAPPEARING：View消失时的动画。</li><li>LayoutTransition.CHANGE_DISAPPEARING：View消失导致布局容改变时整个布局容器的动画。</li><li>LayoutTransition.CHANGE：不是由于View出现或消失造成改变的时候整个布局容器的动画。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android动画机制提供了视图动画、属性动画和可绘制动画，这些动画都是针对单个View对象的，而布局动画(Layout Animation)作用的对象是ViewGroup，它可以在ViewGroup布局子View时，为子View添加相应的动画效果。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>可绘制动画</title>
    <link href="http://yoursite.com/2018/01/17/%E5%8F%AF%E7%BB%98%E5%88%B6%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/01/17/可绘制动画/</id>
    <published>2018-01-17T10:57:04.000Z</published>
    <updated>2018-01-17T11:01:19.181Z</updated>
    
    <content type="html"><![CDATA[<p>可绘制动画(Drawable Animation)可以按顺序加载一系列的Drawable资源产生动画效果，它的原理类似于播放动画片，一帧一帧展示图片，具体播放使用AnimationDrawable类。</p><p>使用可绘制动画时，首先需要定义其XML文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust1"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust2"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/rocket_thrust3"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意要将android:oneshot属性设置为true，这样动画会播放一次，否则，动画会循环播放。定义好的XML文件可作为View的背景图片，具体播放过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable rocketAnimation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">  ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);</span><br><span class="line">  rocketImage.setBackgroundResource(R.drawable.rocket_thrust);</span><br><span class="line">  rocketAnimation = (AnimationDrawable) rocketImage.getBackground();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    rocketAnimation.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意动画的播放方法start()不能在onCreate()方法执行，因为这个时候动画还没被加载到Activity的Window上。如果需要在没有交互的情况下播放可绘制动画，可以在Activity的onWindowFocusChanged()中进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可绘制动画(Drawable Animation)可以按顺序加载一系列的Drawable资源产生动画效果，它的原理类似于播放动画片，一帧一帧展示图片，具体播放使用AnimationDrawable类。&lt;/p&gt;
&lt;p&gt;使用可绘制动画时，首先需要定义其XML文件：&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>属性动画框架</title>
    <link href="http://yoursite.com/2018/01/17/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/01/17/属性动画框架/</id>
    <published>2018-01-17T06:35:52.000Z</published>
    <updated>2018-01-17T08:50:15.081Z</updated>
    
    <content type="html"><![CDATA[<p>属性动画(Property Animation)框架可以弥补视图动画交互上的不足，实现更加丰富的动画效果。</p><p>在使用属性动画时，经常将ObjectAnimator和AnimatorSet配合使用，ObjectAnimator用来控制对象的一个属性值的变化，多个ObjectAnimator可以组合到AnimatorSet中，并且ObjectAnimator能够自驱动，还可以调用setFrameDelay()方法设置动画帧之间的间隙时间来调整帧率，减少频繁绘制达到节约CPU资源消耗的效果。</p><p>属性动画是通过调用属性的get、set方法真实地改变了View的属性值，所以，属性动画框架能满足在动画过程中的交互需求，实现基本上所有的动画效果。</p><h1 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h1><p>ObjectAnimator是属性框架中最重要的实行类，具体通过其静态工厂类进行创建。参数包括进行动画的对象和对象的属性名，这个属性必须要有get和set方法，因为ObjectAnimator会通过Java反射机制调用set方法修改属性值， 从而产生具体的动画效果。</p><p>下面利用ObjectAnimator实现一个简单的平移动画：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(</span><br><span class="line">        view,</span><br><span class="line">        <span class="string">"translationX"</span>,</span><br><span class="line">        <span class="number">200f</span></span><br><span class="line">);</span><br><span class="line">animator.setDuration(<span class="number">2000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><p>在使用ObjectAnimator时，要注意需要操纵的属性必须要有get和set方法，下面是一些常用的可使用的属性值：</p><ul><li>translationX和translationY：控制View从坐标原点的偏移位置。</li><li>rotation、rotationX和rotationY：控制View围绕支点进行旋转。</li><li>scaleX和scaleY：控制View围绕支点进行缩放。</li><li>pivotX和pivotY：控制View的支点位置，默认情况，支点位置时View的中心点。</li><li>x和y：描述View在它的容器的最终位置，是最初的坐标位置与translationX和translationY的累计和。</li><li>alpha：控制View的透明度。</li></ul><p>视图动画的所有动画效果，都可以使用上面介绍的属性值实现。</p><p>如果View的某个属性没有提供get和set方法，也可以为其实现动画效果。具体有两种方案：一个是自定义属性类或包装类，间接地给属性增加get和set方法；另一个是通过ValueAnimator实现。ValueAnimator的具体使用在后面介绍，这里介绍如何使用前一种方法：</p><ul><li>自定义包装类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> View mTarget;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperView</span><span class="params">(View target)</span> </span>&#123;</span><br><span class="line">        mTarget = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTarget.getLayoutParams().width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        mTarget.getLayoutParams().width = width;</span><br><span class="line">        mTarget.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作包装类实现动画</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WrapperView wrapper = <span class="keyword">new</span> WrapperView(view);</span><br><span class="line">ObjectAnimator.ofInt(</span><br><span class="line">        wrapper,</span><br><span class="line">        <span class="string">"width"</span>,</span><br><span class="line">        <span class="number">200</span>, <span class="number">500</span></span><br><span class="line">).setDuration(<span class="number">3000</span>).start();</span><br></pre></td></tr></table></figure><h1 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h1><p>类似于视图动画中的AnimationSet，在属性动画中，如果要对同一个对象的多个属性同时产生动画，可以使用PropertyValuesHolder实现，具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pvh1 = PropertyValuesHolder</span><br><span class="line">        .ofFloat(<span class="string">"translationX"</span>, <span class="number">300f</span>);</span><br><span class="line">PropertyValuesHolder pvh2 = PropertyValuesHolder</span><br><span class="line">        .ofFloat(<span class="string">"scaleX"</span>, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line">PropertyValuesHolder pvh3 = PropertyValuesHolder</span><br><span class="line">        .ofFloat(<span class="string">"scaleY"</span>, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line">ObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3)</span><br><span class="line">        .setDuration(<span class="number">2000</span>)</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure><h1 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h1><p>ValueAnimator是属性动画的核心类，ObjectAnimator就是它的子类。</p><p>ValueAnimator本身不提供任何动画效果，它像一个数值发生器，产生具有一定规律的数值，让调用者使用这些数值实现动画效果。</p><p>通常情况下，在ValueAnimator的AnimatorUpdateListener中监听数值变化，完成动画效果。具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animator = ValueAnimator.ofInt(<span class="number">200</span>, <span class="number">500</span>);</span><br><span class="line">animator.setDuration(<span class="number">3000</span>);</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        Integer value = (Integer) animation.getAnimatedValue();</span><br><span class="line">        <span class="comment">// Use the value</span></span><br><span class="line">        view.getLayoutParams().width = value;</span><br><span class="line">        view.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><h1 id="监听动画事件"><a href="#监听动画事件" class="headerlink" title="监听动画事件"></a>监听动画事件</h1><p>属性动画的声明周期有Start、Repeat、End、Cancel四个过程，可以通过AnimatorListener监听这些事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">animator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>大部分时候，我们只关心特定的事件，这时可以使用AnimatorListenerAdapter选择监听特定的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">animator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h1><p>对于一个View同时作用多个属性动画效果，除了用前面介绍的PropertyValuesHolder实现，还可以用AnimatorSet实现，同时，AnimatorSet还可以对动画的播放顺序进行精确地控制。具体使用如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator1 = ObjectAnimator</span><br><span class="line">        .ofFloat(view, <span class="string">"translationX"</span>, <span class="number">300f</span>);</span><br><span class="line">ObjectAnimator animator2 = ObjectAnimator</span><br><span class="line">        .ofFloat(view, <span class="string">"scaleX"</span>, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line">ObjectAnimator animator3 = ObjectAnimator</span><br><span class="line">        .ofFloat(view, <span class="string">"scaleY"</span>, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line">AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">animatorSet.setDuration(<span class="number">2000</span>);</span><br><span class="line">animatorSet.playTogether(animator1, animator2, animator3);</span><br><span class="line">animatorSet.start();</span><br></pre></td></tr></table></figure><p>AnimatorSet可以使用playTogether()、playSequentially()、play()、with()、before()、after()方法控制多个动画协同工作，从而对动画播放顺序进行精确控制。</p><h1 id="在XML中定义属性动画"><a href="#在XML中定义属性动画" class="headerlink" title="在XML中定义属性动画"></a>在XML中定义属性动画</h1><p>属性动画同视图动画一样，可以直接在XML文件中定义，这样可以方便多个组件共享动画效果，具体代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:propertyName</span>=<span class="string">"rotation"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueFrom</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueTo</span>=<span class="string">"360"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>定义完动画效果后，具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater</span><br><span class="line">        .loadAnimator(<span class="keyword">this</span>, R.animator.animator_sample);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><h1 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h1><p>可以使用ViewPropertyAnimator简化常用属性动画的使用，具体通过View的animate()方法实现，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">view.animate()</span><br><span class="line">        .alpha(<span class="number">0</span>)</span><br><span class="line">        .rotation(<span class="number">360</span>)</span><br><span class="line">        .setDuration(<span class="number">3000</span>)</span><br><span class="line">        .withStartAction(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .withEndAction(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure><p>ViewPropertyAnimator、ObjectAnimator、ValueAnimator这三种Animator其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。它们的性能是一样的，因为ViewPropertyAnimator和ObjectAnimator的内部实现都是ValueAnimator。它们的差别只是使用的便捷性以及功能的灵活性。在实际使用时候的选择，只要遵循一个原则：尽量用简单的。能用View.animate()实现就不用ObjectAnimator，能用ObjectAnimator就不用ValueAnimator。</p><h1 id="Interpolators"><a href="#Interpolators" class="headerlink" title="Interpolators"></a>Interpolators</h1><p>插值器(Interpolators)可以定义动画的变化速率，类似于物理学中的加速度，控制View的属性由起始值到目标值变化的方式。例如，对于位移动画，可以通过setInterpolator()方法设置AccelerateInterpolator，这样View的位移速度会越来越快。具体插值器的类别可以参考HenCoder的<a href="http://hencoder.com/ui-1-6/" target="_blank" rel="noopener">属性动画（上手篇）</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;属性动画(Property Animation)框架可以弥补视图动画交互上的不足，实现更加丰富的动画效果。&lt;/p&gt;
&lt;p&gt;在使用属性动画时，经常将ObjectAnimator和AnimatorSet配合使用，ObjectAnimator用来控制对象的一个属性值的变化，多个O
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>视图动画框架</title>
    <link href="http://yoursite.com/2018/01/17/%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/01/17/视图动画框架/</id>
    <published>2018-01-17T02:20:38.000Z</published>
    <updated>2018-01-17T02:30:30.380Z</updated>
    
    <content type="html"><![CDATA[<p>视图动画(View Animation)框架提供了透明度、旋转、缩放和位移这几种动画，它控制的是整个View，实现原理是每次绘制View时，在其ViewGroup中的drawChild()方法调用View的draw()方法，接着在draw()方法中获取Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())方法，通过矩阵运算实现动画帧，如果动画没有完成，就继续调用invalidate()方法，启动下次绘制来实现下一个动画帧，最终完成整个动画。</p><p>视图动画使用比较简单，提供了AlphaAnimation、RotateAnimation、ScaleAnimation、TranslateAnimation分别实现透明度、旋转、缩放和位移动画，还提供了AnimationSet实现动画集合，组合使用多种动画。不过，视图动画主要用于Android3.0之前，Android3.0之后一般使用属性动画。相比属性动画，视图动画最大的劣势是不具备交互性，当View通过视图动画产生移动后，其响应事件的位置依然还动画产生前的地方。所以，视图动画只能用来实现没有交互的动画效果，但是，它也有使用方便、效率高的优点。</p><p>具体使用视图动画时，可以通过XML文件描述动画过程，也可以使用Java代码实现同样的动画过程。</p><h1 id="透明度动画"><a href="#透明度动画" class="headerlink" title="透明度动画"></a>透明度动画</h1><p>为视图增加透明度动画的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AlphaAnimation animation = <span class="keyword">new</span> AlphaAnimation(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure><h1 id="旋转动画"><a href="#旋转动画" class="headerlink" title="旋转动画"></a>旋转动画</h1><p>为视图增加旋转动画的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RotateAnimation animation = <span class="keyword">new</span> RotateAnimation(<span class="number">0</span>, <span class="number">360</span>, </span><br><span class="line">    Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>, Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure><h1 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h1><p>为视图增加缩放动画的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScaleAnimation animation = <span class="keyword">new</span> ScaleAnimation(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, </span><br><span class="line">    Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>, Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure><h1 id="位移动画"><a href="#位移动画" class="headerlink" title="位移动画"></a>位移动画</h1><p>为视图增加位移动画的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TranslateAnimation animation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure><h1 id="动画集合"><a href="#动画集合" class="headerlink" title="动画集合"></a>动画集合</h1><p>通过AnimationSet可以将多个动画以组合的形式展现出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnimationSet animationSet = <span class="keyword">new</span> AnimationSet(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">AlphaAnimation aa = <span class="keyword">new</span> AlphaAnimation(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">aa.setDuration(<span class="number">3000</span>);</span><br><span class="line">animationSet.addAnimation(aa);</span><br><span class="line"></span><br><span class="line">TranslateAnimation ta = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">ta.setDuration(<span class="number">1000</span>);</span><br><span class="line">animationSet.addAnimation(ta);</span><br><span class="line"></span><br><span class="line">view.startAnimation(animationSet);</span><br></pre></td></tr></table></figure><h1 id="动画监听"><a href="#动画监听" class="headerlink" title="动画监听"></a>动画监听</h1><p>对于动画事件，Android系统提供了对应的监听回调方法， 通过监听，可以获取动画的开始、结束和重复事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">animationSet.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;视图动画(View Animation)框架提供了透明度、旋转、缩放和位移这几种动画，它控制的是整个View，实现原理是每次绘制View时，在其ViewGroup中的drawChild()方法调用View的draw()方法，接着在draw()方法中获取Animation的T
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="动画机制" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceView使用</title>
    <link href="http://yoursite.com/2018/01/16/SurfaceView%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/16/SurfaceView使用/</id>
    <published>2018-01-16T07:33:59.000Z</published>
    <updated>2018-01-16T08:45:25.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SurfaceView和View的区别"><a href="#SurfaceView和View的区别" class="headerlink" title="SurfaceView和View的区别"></a>SurfaceView和View的区别</h1><p>View通过刷新来重绘视图，两次刷新的间隔时间为16ms，如果在16ms内，View没有完成需要执行的操作，用户就会产生卡顿的感觉。为了避免这个问题，可以使用SurfaceView，它与View的主要区别如下：</p><ul><li>View主要用于主动刷新，而SurfaceView适用于被动刷新，比如拍照和游戏界面的频繁刷新；</li><li>View刷新在主线程中进行，而SurfaceView通常使用一个子线程进行刷新操作；</li><li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现了这个机制；</li></ul><p>因此，如果在自定义View的时候需要频繁刷新，或者刷新时数据处理量比较大时，可以考虑使用SurfaceView代替。</p><h1 id="SurfaceView使用模板"><a href="#SurfaceView使用模板" class="headerlink" title="SurfaceView使用模板"></a>SurfaceView使用模板</h1><p>在使用SurfaceView时，可以使用一套模板代码，大部分的SurfaceView绘图操作都可以使用这套模板代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceViewTemplate</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line">    <span class="keyword">private</span> Canvas mCanvas; <span class="comment">// 画布，用于绘图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsDrawing; <span class="comment">// 标志位，用于控制进行绘制的子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHolder = getHolder();</span><br><span class="line">        mHolder.addCallback(<span class="keyword">this</span>);</span><br><span class="line">        setFocusable(<span class="keyword">true</span>);</span><br><span class="line">        setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line">        setKeepScreenOn(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (mIsDrawing) &#123;</span><br><span class="line">            draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCanvas = mHolder.lockCanvas(); <span class="comment">// 获取上一次的Canvas，之前的绘图操作会被保留</span></span><br><span class="line">            <span class="comment">// To do drawing</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>)</span><br><span class="line">                mHolder.unlockCanvasAndPost(mCanvas); <span class="comment">// 提交绘制内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SurfaceView实例"><a href="#SurfaceView实例" class="headerlink" title="SurfaceView实例"></a>SurfaceView实例</h1><p>下面通过具体实例介绍如何使用SurfaceView进行频繁刷新的绘图。</p><h2 id="正弦曲线"><a href="#正弦曲线" class="headerlink" title="正弦曲线"></a>正弦曲线</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (mIsDrawing) &#123;</span><br><span class="line">        draw();</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        y = (<span class="keyword">float</span>) (<span class="number">100</span> * Math.sin(x * <span class="number">2</span> * Math.PI / <span class="number">180</span>) + getHeight() / <span class="number">2</span>);</span><br><span class="line">        mPath.lineTo(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCanvas = mHolder.lockCanvas(); <span class="comment">// 获取上一次的Canvas，之前的绘图操作会被保留</span></span><br><span class="line">        <span class="comment">// To do drawing</span></span><br><span class="line">        mCanvas.drawColor(Color.WHITE);</span><br><span class="line">        mCanvas.drawPath(mPath, mPaint);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>)</span><br><span class="line">            mHolder.unlockCanvasAndPost(mCanvas); <span class="comment">// 提交绘制内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘图板"><a href="#绘图板" class="headerlink" title="绘图板"></a>绘图板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            mPath.moveTo(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            mPath.lineTo(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (mIsDrawing) &#123;</span><br><span class="line">        draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCanvas = mHolder.lockCanvas(); <span class="comment">// 获取上一次的Canvas，之前的绘图操作会被保留</span></span><br><span class="line">        <span class="comment">// To do drawing</span></span><br><span class="line">        mCanvas.drawColor(Color.WHITE);</span><br><span class="line">        mCanvas.drawPath(mPath, mPaint);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>)</span><br><span class="line">            mHolder.unlockCanvasAndPost(mCanvas); <span class="comment">// 提交绘制内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SurfaceView和View的区别&quot;&gt;&lt;a href=&quot;#SurfaceView和View的区别&quot; class=&quot;headerlink&quot; title=&quot;SurfaceView和View的区别&quot;&gt;&lt;/a&gt;SurfaceView和View的区别&lt;/h1&gt;&lt;p&gt;Vi
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Paint使用</title>
    <link href="http://yoursite.com/2018/01/11/Paint%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/11/Paint使用/</id>
    <published>2018-01-11T11:09:35.000Z</published>
    <updated>2018-01-15T01:17:32.928Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2018/01/02/2D绘图/">2D绘图</a>中可以了解到Paint的基本使用，使用这些基本方法可以实现一般的绘制需求，如果要实现更加丰富的绘图效果，需要了解Paint的更详细使用。</p><p>Paint的方法按功能可以分为四类：颜色处理、绘制效果、文字绘制和初始化相关。</p><h1 id="颜色处理"><a href="#颜色处理" class="headerlink" title="颜色处理"></a>颜色处理</h1><p>颜色处理有三个层次：直接使用设置颜色的API给图形和文字设置颜色；使用setColorFilter()基于颜色进行过滤处理；使用setXfermode()处理源图像和Canvas已有内容的关系。</p><h2 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h2><p>Paint设置颜色的方法有两种：一种是直接用Paint.setColor/ARGB()来设置颜色，另一种是使用Shader来指定着色方案。</p><h3 id="直接设置颜色"><a href="#直接设置颜色" class="headerlink" title="直接设置颜色"></a>直接设置颜色</h3><ul><li>setColor(int color)</li><li>setARGB(int a, int r, int g, int b)</li></ul><h3 id="使用Shader"><a href="#使用Shader" class="headerlink" title="使用Shader"></a>使用Shader</h3><p>通过setShader(Shader shader)设置Shader后，Paint 在绘制图形和文字时就不使用setColor/ARGB()设置的颜色了，而是使用Shader中的颜色方案。系统提供的Shader有以下几类：</p><ul><li>LinearGradient 线性渐变</li><li>RadialGradient 辐射渐变</li><li>BitmapShader 用Bitmap的像素来作为图形或文字的填充</li></ul><p>上面三种Shader都有3种着色规则（TileMode）：CLAMP会在端点之外延续端点处的颜色；MIRROR是镜像模式；REPEAT是重复模式。</p><ul><li>SweepGradient 扫描渐变</li><li>ComposeShader 混合着色器，把两个Shader叠加使用<br>叠加使用时，需要用到叠加模式，它的类型是PorterDuff.Mode，决定shaderA和shaderB应该怎样共同绘制。</li></ul><h2 id="设置滤色器"><a href="#设置滤色器" class="headerlink" title="设置滤色器"></a>设置滤色器</h2><p>通过setColorFilter(ColorFilter colorFilter)设置滤色器，系统提供的ColorFilter有以下几类：</p><ul><li><p>LightingColorFilter<br>模拟简单的光照效果。</p></li><li><p>PorterDuffColorFilter<br>使用一个指定的颜色和一种指定的PorterDuff.Mode来与绘制对象进行合成。</p></li><li><p>ColorMatrixColorFilter<br>使用一个ColorMatrix来对颜色进行处理，具体使用可以查看<a href="/2018/01/02/图像特效/">图像特效</a>中的颜色特效。</p></li></ul><h2 id="设置TransferMode"><a href="#设置TransferMode" class="headerlink" title="设置TransferMode"></a>设置TransferMode</h2><p>通过setXfermode(Xfermode xfermode)设置TransferMode，”Xfermode”是”Transfer mode”的简写，指的是要绘制的内容和Canvas目标位置的内容进行颜色结合的模式，简单来说，就是以要绘制的内容作为源图像，以Canvas中已有的内容作为目标图像，选取一个PorterDuff.Mode作为绘制内容的颜色处理方案。</p><p>创建Xfermode的时候其实是创建的它的子类PorterDuffXfermode，而事实上，Xfermode只有这一个子类。</p><h1 id="绘制效果"><a href="#绘制效果" class="headerlink" title="绘制效果"></a>绘制效果</h1><p>绘制效果指的就是抗锯齿、填充/轮廓、线条宽度等等这些。</p><h2 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h2><p>使用setAntiAlias (boolean b)设置是否抗锯齿。</p><h2 id="绘制风格"><a href="#绘制风格" class="headerlink" title="绘制风格"></a>绘制风格</h2><p>使用setStyle(Paint.Style style)设置图形是线条风格还是填充风格的（或者二者并用）。</p><h2 id="线条形状"><a href="#线条形状" class="headerlink" title="线条形状"></a>线条形状</h2><ul><li><p>setStrokeWidth(float width)<br>设置线条宽度。单位为像素，默认值是 0。</p></li><li><p>setStrokeCap(Paint.Cap cap)<br>设置线头的形状。线头形状有三种：BUTT平头、ROUND圆头、SQUARE方头。默认为BUTT。</p></li><li><p>setStrokeJoin(Paint.Join join)<br>设置拐角的形状。有三个值可以选择：MITER尖角、 BEVEL平角和ROUND 圆角。默认为MITER。</p></li><li><p>setStrokeMiter(float miter)<br>这个方法是对于setStrokeJoin()的一个补充，它用于设置MITER型拐角的延长线的最大值，所谓“延长线的最大值”。</p></li></ul><h2 id="色彩优化"><a href="#色彩优化" class="headerlink" title="色彩优化"></a>色彩优化</h2><ul><li><p>setDither(boolean dither)<br>设置图像的抖动。</p></li><li><p>setFilterBitmap(boolean filter)<br>设置是否使用双线性过滤来绘制Bitmap。图像在放大绘制的时候，默认使用的是最近邻插值过滤，这种算法简单，但会出现马赛克现象；而如果开启了双线性过滤，就可以让结果图像显得更加平滑。</p></li></ul><h2 id="PathEffect"><a href="#PathEffect" class="headerlink" title="PathEffect"></a>PathEffect</h2><p>通过setPathEffect(PathEffect effect)给图形的轮廓设置效果，对Canvas所有的图形绘制有效，即对 drawLine() drawCircle() drawPath() 这些方法有效。</p><p>单一效果的PathEffect有：</p><ul><li><p>CornerPathEffect<br>把所有拐角变成圆角。</p></li><li><p>DiscretePathEffect<br>把线条进行随机的偏离，让轮廓变得乱七八糟。</p></li><li><p>DashPathEffect<br>使用虚线来绘制线条。</p></li><li><p>PathDashPathEffect<br>比DashPathEffect多一个前缀Path，顾名思义，它是使用一个Path来绘制“虚线”。</p></li></ul><p>组合效果类的PathEffect有：</p><ul><li><p>SumPathEffect<br>按照两种PathEffect分别对目标进行绘制。</p></li><li><p>ComposePathEffect<br>先对目标Path使用一个PathEffect，然后再对这个改变后的Path使用另一个PathEffect。</p></li></ul><h2 id="添加阴影"><a href="#添加阴影" class="headerlink" title="添加阴影"></a>添加阴影</h2><p>具体使用setShadowLayer(float radius, float dx, float dy, int shadowColor)方法。radius是阴影的模糊范围；dx dy是阴影的偏移量；shadowColor是阴影的颜色。</p><p>如果要清除阴影层，使用clearShadowLayer()方法。</p><h2 id="MaskFilter"><a href="#MaskFilter" class="headerlink" title="MaskFilter"></a>MaskFilter</h2><p>setShadowLayer()设置的是绘制层下方的附加效果；而MaskFilter和它相反，setMaskFilter(filter)设置的是绘制层上方的附加效果。</p><p>前面有一个setColorFilter(filter)方法，它对每个像素的颜色进行过滤；而setMaskFilter(filter)是基于整个画面来进行过滤。</p><ul><li>BlurMaskFilter 模糊效果</li><li>EmbossMaskFilter 浮雕效果</li></ul><h2 id="获取绘制的Path"><a href="#获取绘制的Path" class="headerlink" title="获取绘制的Path"></a>获取绘制的Path</h2><p>根据Paint的设置，计算出绘制Path或文字时的<strong>实际Path</strong>，所谓实际Path，指的就是drawPath()绘制内容的轮廓，要算上线条宽度和设置的PathEffect。</p><ul><li><p>getFillPath(Path src, Path dst)<br>src是原Path，而dst就是实际Path的保存位置。</p></li><li><p>getTextPath()<br>获取的就是目标文字所对应的Path。</p></li></ul><p>获取绘制的Path主要是用于图形和文字的装饰效果的位置计算，比如<a href="https://medium.com/google-developers/a-better-underline-for-android-90ba3a2e4fb" target="_blank" rel="noopener">自定义的下划线效果</a>。</p><h1 id="文字绘制"><a href="#文字绘制" class="headerlink" title="文字绘制"></a>文字绘制</h1><p>Paint有很多文字绘制相关的方法，即和drawText()相关的方法，这些方法可以设置文字大小、文字间隔、文字效果等。除此之外，Paint还有很多与文字绘制相关的设置或计算的方法，具体可以参考官方文档。</p><h1 id="初始化相关"><a href="#初始化相关" class="headerlink" title="初始化相关"></a>初始化相关</h1><p>这一类方法很简单，它们是用来初始化Paint对象，或者是批量设置Paint的多个属性的方法。</p><ul><li><p>reset()<br>重置Paint的所有属性为默认值。相当于重新new一个，不过性能相对要高。</p></li><li><p>set(Paint src)<br>把src的所有属性全部复制过来。相当于调用src所有的get方法，然后调用这个Paint的对应的set方法来设置它们。</p></li><li><p>setFlags(int flags)<br>批量设置flags。相当于依次调用它们的set方法。</p></li></ul><blockquote><p>这里只是简单介绍了Paint提供的绘制功能，详细介绍可以参考HenCoder的<a href="http://hencoder.com/ui-1-2/" target="_blank" rel="noopener">Paint详解</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;/2018/01/02/2D绘图/&quot;&gt;2D绘图&lt;/a&gt;中可以了解到Paint的基本使用，使用这些基本方法可以实现一般的绘制需求，如果要实现更加丰富的绘图效果，需要了解Paint的更详细使用。&lt;/p&gt;
&lt;p&gt;Paint的方法按功能可以分为四类：颜色处理、绘
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像特效</title>
    <link href="http://yoursite.com/2018/01/02/%E5%9B%BE%E5%83%8F%E7%89%B9%E6%95%88/"/>
    <id>http://yoursite.com/2018/01/02/图像特效/</id>
    <published>2018-01-02T11:58:44.000Z</published>
    <updated>2018-01-11T11:03:55.505Z</updated>
    
    <content type="html"><![CDATA[<p>图像特效按照处理对象一般可以分为颜色特效和图形特效两类，下面分别进行介绍。</p><h1 id="颜色特效"><a href="#颜色特效" class="headerlink" title="颜色特效"></a>颜色特效</h1><p>在Android系统中，通常使用Bitmap（位图）的数据结构来表示一张图片，它包含了图片的所有数据。Bitmap由点阵和颜色值组成，点阵是图片像素的矩阵，其中每个元素对应图片的一个像素；颜色值（ARGB）分别对应透明度、红、绿、蓝四个分量，它们共同决定每个像素点的颜色。</p><p>进行颜色处理时，通常使用以下三个角度来描述一个图像：</p><ul><li>色调——物体的颜色</li><li>饱和度——颜色的纯度，从0（灰）到100%（饱和）进行描述</li><li>亮度——颜色的明暗程度</li></ul><h2 id="颜色矩阵——ColorMatrix"><a href="#颜色矩阵——ColorMatrix" class="headerlink" title="颜色矩阵——ColorMatrix"></a>颜色矩阵——ColorMatrix</h2><p>Android中使用颜色矩阵（ColorMatrix）处理图像的颜色效果，ColorMatrix是一个4x5的矩阵，对于图像的每个像素点，都有一个4x1的颜色分量矩阵保存颜色的RGBA值。</p><p>具体对图像的颜色进行处理时，会通过一定的算法得到一个对应效果的ColorMatrix，接着把这个矩阵分别与每个像素点的颜色分量矩阵进行乘法运算得到新的颜色分量矩阵，最后为每个像素点设置新的颜色分量矩阵，从而达到颜色特效的处理效果，具体过程如下所示：</p><p><img src="/uploads/android/颜色矩阵处理过程.gif" alt="颜色矩阵处理过程"></p><p>根据上述过程，可以得到：</p><p><img src="/uploads/android/颜色处理结果.gif" alt="颜色处理结果"></p><p>根据处理结果可以知道，在4x5的ColorMatrix中：</p><ul><li>第一行r1 g1 b1 a1 o1的值决定新颜色值中的R（红色）</li><li>第二行r2 g2 b2 a2 o2的值决定新颜色值中的G（绿色）</li><li>第三行r3 g3 b3 a3 o3的值决定新颜色值中的B（蓝色）</li><li>第四行r4 g4 b4 a4 o4的值决定新颜色值中的A（透明度）</li><li>第五列o1 o2 o3 o4的值决定新颜色值中每个分量的偏移量（offset）</li></ul><p>因此，对图像的颜色进行处理时，通常有两种方法：一个是改变颜色的offset；另一个是改变对应RGBA值的系数。</p><h2 id="通过颜色矩阵进行颜色处理"><a href="#通过颜色矩阵进行颜色处理" class="headerlink" title="通过颜色矩阵进行颜色处理"></a>通过颜色矩阵进行颜色处理</h2><p>改变ColorMatrix方式通常有两种：一种是通过系统API修改；另一种是利用经典算法直接创建。</p><h3 id="通过系统API修改"><a href="#通过系统API修改" class="headerlink" title="通过系统API修改"></a>通过系统API修改</h3><p>通过系统API修改颜色矩阵可以改变图像的色调、饱和度和亮度。</p><ul><li><p>色调<br>使用setRotate(int axis, float degrees)方法设置颜色矩阵的色调。axis使用0，1，2来表示Red、Green、Blue三种颜色的处理；degrees表示处理的具体值。</p></li><li><p>饱和度<br>使用setSaturation(float sat)方法设置颜色矩阵的饱和度。当饱和度为0时，图像会变为灰色。</p></li><li><p>亮度<br>使用setScale(float rScale, float gScale, float bScale, float aScale)方法设置颜色矩阵的亮度。其本质是利用三原色以同比例混合会显示出白色的原理。当亮度为0时，图像会变为黑色。</p></li></ul><ul><li>效果叠加<br>除了上面三种处理方法外，还可以使用postConcat()方法将不同效果的矩阵进行混合，从而产生叠加效果。</li></ul><p>下面的示例代码展示了如何使用上面介绍的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">handleImageEffect</span><span class="params">(Bitmap bm, <span class="keyword">float</span> hue, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">float</span> saturation, <span class="keyword">float</span> lum)</span> </span>&#123;</span><br><span class="line">    Bitmap bitmap = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(),</span><br><span class="line">            Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line"></span><br><span class="line">    ColorMatrix hueMatrix = <span class="keyword">new</span> ColorMatrix();</span><br><span class="line">    hueMatrix.setRotate(<span class="number">0</span>, hue);</span><br><span class="line">    hueMatrix.setRotate(<span class="number">1</span>, hue);</span><br><span class="line">    hueMatrix.setRotate(<span class="number">2</span>, hue);</span><br><span class="line"></span><br><span class="line">    ColorMatrix saturationMatrix = <span class="keyword">new</span> ColorMatrix();</span><br><span class="line">    saturationMatrix.setSaturation(saturation);</span><br><span class="line"></span><br><span class="line">    ColorMatrix lumMatrix = <span class="keyword">new</span> ColorMatrix();</span><br><span class="line">    lumMatrix.setScale(lum, lum, lum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ColorMatrix imageMatrix = <span class="keyword">new</span> ColorMatrix();</span><br><span class="line">    imageMatrix.postConcat(hueMatrix);</span><br><span class="line">    imageMatrix.postConcat(saturationMatrix);</span><br><span class="line">    imageMatrix.postConcat(lumMatrix);</span><br><span class="line"></span><br><span class="line">    paint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(imageMatrix));</span><br><span class="line">    canvas.drawBitmap(bm, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用经典算法创建"><a href="#利用经典算法创建" class="headerlink" title="利用经典算法创建"></a>利用经典算法创建</h3><p>图像色彩处理，通常就是研究如何通过某种算法创建颜色矩阵，将其作用到图像上，形成新的色彩风格的图像。下面介绍一些经典算法对应的颜色矩阵。</p><ul><li>灰度效果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 灰度效果</span></span><br><span class="line"><span class="keyword">float</span>[] colorMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">        <span class="number">0.33f</span>,  <span class="number">0.59f</span>,  <span class="number">0.11f</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0.33f</span>,  <span class="number">0.59f</span>,  <span class="number">0.11f</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0.33f</span>,  <span class="number">0.59f</span>,  <span class="number">0.11f</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>图像反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像反转</span></span><br><span class="line"><span class="keyword">float</span>[] colorMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">        -<span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,  -<span class="number">1</span>, <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,  <span class="number">0</span>,  -<span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>怀旧效果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 怀旧效果</span></span><br><span class="line"><span class="keyword">float</span>[] colorMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">        <span class="number">0.393f</span>, <span class="number">0.769f</span>, <span class="number">0.189f</span>, <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0.349f</span>, <span class="number">0.686f</span>, <span class="number">0.168f</span>, <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0.272f</span>, <span class="number">0.534f</span>, <span class="number">0.131f</span>, <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>去色效果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去色效果</span></span><br><span class="line"><span class="keyword">float</span>[] colorMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">        <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">0</span>,  -<span class="number">1</span>,</span><br><span class="line">        <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">0</span>,  -<span class="number">1</span>,</span><br><span class="line">        <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">1.5f</span>,   <span class="number">0</span>,  -<span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">0</span>,      <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>高饱和度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高饱和度</span></span><br><span class="line"><span class="keyword">float</span>[] colorMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">        <span class="number">1.438f</span>,     -<span class="number">0.122f</span>,    -<span class="number">0.016f</span>,    <span class="number">0</span>,  -<span class="number">0.03f</span>,</span><br><span class="line">        -<span class="number">0.062f</span>,    <span class="number">1.378f</span>,     -<span class="number">0.016f</span>,    <span class="number">0</span>,  <span class="number">0.05f</span>,</span><br><span class="line">        -<span class="number">0.062f</span>,    -<span class="number">0.122f</span>,    <span class="number">1.483f</span>,     <span class="number">0</span>,  -<span class="number">0.02f</span>,</span><br><span class="line">        <span class="number">0</span>,          <span class="number">0</span>,          <span class="number">0</span>,          <span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="像素点分析"><a href="#像素点分析" class="headerlink" title="像素点分析"></a>像素点分析</h2><p>除了通过ColorMatrix改变图像的颜色，还可以直接改变每个像素点的ARGB值来改变图像的颜色，这种处理方式相对更加精确。用这种方式处理图片时，需要注意原始图片是不可变的（mutable），需要复制原始图片进行处理。</p><p>Android中使用Bitmap.getPixels(int[] pixels, int offset, int stride,int x, int y, int width, int height)方法获取图片的像素点的颜色值：</p><ul><li>pixels: 接收位图像素点颜色值的数组</li><li>offset: 写入到pixels[]中的第一个像素索引值</li><li>stride: pixels[]的行间距</li><li>x: 从bitmap中读取的第一个像素的x坐标值</li><li>y: 从bitmap中读取的第一个像素的y坐标值</li><li>width: 每行的像素个数</li><li>height: 读取的行数</li></ul><p>修改图像像素点的颜色值的关键代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取图片像素点的颜色值数组</span></span><br><span class="line">bitmap.getPixels(oldPx, <span class="number">0</span>, bitmap.getWidth(),</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取每个像素点具体的ARGB值</span></span><br><span class="line"><span class="keyword">int</span> color = oldPx[i];</span><br><span class="line">a = Color.alpha(color);</span><br><span class="line">r = Color.red(color);</span><br><span class="line">g = Color.green(color);</span><br><span class="line">b = Color.blue(color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据图像处理算法修改像素点的ARGB值</span></span><br><span class="line">rn = (<span class="keyword">int</span>) (<span class="number">0.393</span> * r + <span class="number">0.322</span> * g + <span class="number">0.189</span> * b);</span><br><span class="line">gn = (<span class="keyword">int</span>) (<span class="number">0.393</span> * r + <span class="number">0.322</span> * g + <span class="number">0.189</span> * b);</span><br><span class="line">bn = (<span class="keyword">int</span>) (<span class="number">0.393</span> * r + <span class="number">0.322</span> * g + <span class="number">0.189</span> * b);</span><br><span class="line">newPx[i] = Color.argb(a, rn, gn, bn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将修改后的颜色数组设置到位图上，完成颜色处理</span></span><br><span class="line">bitmap.setPixels(newPx, <span class="number">0</span>, bitmap.getWidth(),</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight());</span><br></pre></td></tr></table></figure><h2 id="通过像素点进行颜色处理"><a href="#通过像素点进行颜色处理" class="headerlink" title="通过像素点进行颜色处理"></a>通过像素点进行颜色处理</h2><p>通过Pixels进行颜色处理，就是通过特定的算法改变每个像素点的颜色值，从而得到相应的处理效果。下面介绍一些常用的处理算法。</p><ul><li>底片效果</li></ul><p>处理算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">255</span> - r;</span><br><span class="line">g = <span class="number">255</span> - g;</span><br><span class="line">b = <span class="number">255</span> - b;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">handleImagePixels</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = bitmap.getWidth();</span><br><span class="line">    <span class="keyword">int</span> height = bitmap.getHeight();</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">int</span> a, r, g, b;</span><br><span class="line"></span><br><span class="line">    Bitmap bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</span><br><span class="line">    <span class="keyword">int</span>[] oldPx = <span class="keyword">new</span> <span class="keyword">int</span>[width * height];</span><br><span class="line">    <span class="keyword">int</span>[] newPx = <span class="keyword">new</span> <span class="keyword">int</span>[width * height];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图片像素点的颜色值数组</span></span><br><span class="line">    bitmap.getPixels(oldPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取每个像素点具体的ARGB值</span></span><br><span class="line">        color = oldPx[i];</span><br><span class="line">        a = Color.alpha(color);</span><br><span class="line">        r = Color.red(color);</span><br><span class="line">        g = Color.green(color);</span><br><span class="line">        b = Color.blue(color);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据图像处理算法修改像素点的ARGB值</span></span><br><span class="line">        r = <span class="number">255</span> - r;</span><br><span class="line">        g = <span class="number">255</span> - g;</span><br><span class="line">        b = <span class="number">255</span> - b;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line">        newPx[i] = Color.argb(a, r, g, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将修改后的颜色数组设置到位图上，完成颜色处理</span></span><br><span class="line">    bmp.setPixels(newPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>老照片效果</li></ul><p>处理算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rn = (<span class="keyword">int</span>) (<span class="number">0.393</span> * r + <span class="number">0.769</span> * g + <span class="number">0.189</span> * b);</span><br><span class="line">gn = (<span class="keyword">int</span>) (<span class="number">0.349</span> * r + <span class="number">0.686</span> * g + <span class="number">0.168</span> * b);</span><br><span class="line">bn = (<span class="keyword">int</span>) (<span class="number">0.272</span> * r + <span class="number">0.534</span> * g + <span class="number">0.131</span> * b);</span><br></pre></td></tr></table></figure><p>示例代码和上面类似。</p><h1 id="图形特效"><a href="#图形特效" class="headerlink" title="图形特效"></a>图形特效</h1><p>可以将一张图像的形状进行处理，达到某种图形上的效果。Android中提供的常用处理方式有：平移、旋转、缩放和错切（skew），除了常用的处理方式，还可以通过变形矩阵自定义图形变换。</p><h2 id="变形矩阵——Matrix"><a href="#变形矩阵——Matrix" class="headerlink" title="变形矩阵——Matrix"></a>变形矩阵——Matrix</h2><p>类似于颜色矩阵，Android中使用变形矩阵（Matrix）处理图像的图形变换，变形矩阵是一个3x3的矩阵，对于图像的每个像素点，都有一个3x1的位置矩阵保存其X，Y的坐标值。</p><p>具体进行图形变换时，会将变形矩阵与每个像素的位置矩阵相乘，为每个像素设置新的位置，从而达到图像变换效果，具体过程如下所示：</p><p><img src="/uploads/android/变形矩阵处理过程.gif" alt="变形矩阵处理过程"></p><p>根据上述过程，可以得到：</p><p><img src="/uploads/android/变形处理结果.gif" alt="变形处理结果"></p><p>通常情况下为了保证 1 = gX + hY + i 成立，会令 g = h = 0，i = 1，这样，在处理图形变换时，只需要关注其它几个参数即可。</p><ul><li>平移变换（Translate）</li></ul><p>平移变换就是将所有像素点的坐标值进行平移，其变换过程如下：</p><p><img src="/uploads/android/平移变换过程.gif" alt="平移变换过程"></p><ul><li>旋转变换（Rotate）</li></ul><p>旋转变换是将像素点围绕一个中心点进行选择，以原点为中心旋转一定角度的变换过程如下：</p><p><img src="/uploads/android/旋转变换过程.gif" alt="旋转变换过程"></p><p>述变换过程是以坐标原点为中心旋转的，如果以任意点O为中心旋转通常需要：将坐标原点平移到O点；以原点为中心旋转；将坐标原点还原。</p><ul><li>缩放变换（Scale）</li></ul><p>缩放变换是对于多个像素点才会有效果，将图像沿X轴和Y轴按一定比例缩放的变换过程如下：</p><p><img src="/uploads/android/缩放变换过程.gif" alt="缩放变换过程"></p><ul><li>错切变换（Skew）</li></ul><p>错切变换是将所有像素点的X坐标（或Y坐标）保持不变，而对应的Y坐标（或X坐标）按比例发生平移，并且平移的大小和该点到X轴（或Y轴）的垂直距离成正比。</p><p>错切变换的示意图如下所示：</p><p><img src="/uploads/android/错切变换示意图.jpg" alt="错切变换示意图"></p><p>错切变换过程如下：</p><p><img src="/uploads/android/错切变换过程.gif" alt="错切变换过程"></p><h2 id="通过变形矩阵进行图形处理"><a href="#通过变形矩阵进行图形处理" class="headerlink" title="通过变形矩阵进行图形处理"></a>通过变形矩阵进行图形处理</h2><p>与颜色矩阵一样，变形矩阵也提供了相关API简化图形变换，其中Matrix提供的方法是进行2D变换的，而Camera提供的方法还可以进行3D变换。</p><h3 id="通过Matrix进行2D变换"><a href="#通过Matrix进行2D变换" class="headerlink" title="通过Matrix进行2D变换"></a>通过Matrix进行2D变换</h3><p>Matrix提供的变换API有：</p><ul><li>Matrix.setTranslate()：平移变换</li><li>Matrix.setRotate()：旋转变换</li><li>Matrix.setScale()：缩放变换</li><li>Matrix.setSkew()：错切变换</li><li>Matrix.setPolyToPoly() setRectToRect() setSinCos()：自定义变换</li><li>Matrix.preXXX()和Matrix.postXXX()：叠加变换</li></ul><p>当设置完Matrix后，把Matrix设置到Canvas上有两个方法：</p><ul><li>Canvas.setMatrix(matrix)：用Matrix直接替换Canvas当前的变换矩阵，即抛弃Canvas当前的变换，改用Matrix的变换</li><li>Canvas.concat(matrix)：用Canvas当前的变换矩阵和Matrix相乘，即基于Canvas当前的变换，叠加上Matrix中的变换</li></ul><h3 id="通过Camera进行3D变换"><a href="#通过Camera进行3D变换" class="headerlink" title="通过Camera进行3D变换"></a>通过Camera进行3D变换</h3><p>Camera提供的3D变换有三类：</p><ul><li>Camera.rotateXXX()：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行旋转，可以用来实现翻转效果。同时要注意，虚拟相机旋转的轴心是坐标原点。</li><li>Camera.translate(x, y, z)：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行移动，可以使用Canvas的translate()和scale()方法代替。</li><li>Camera.setLocation(x, y, z)：设置虚拟相机的位置，可以用来控制投影的图像大小。</li></ul><p>当设置完Camera后，把Camera的Matrix设置到Canvas需要使用Camera.applyToCanvas(canvas)方法。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(centerX, centerY); <span class="comment">// 旋转之前把绘制内容移动到轴心（原点）</span></span><br><span class="line"></span><br><span class="line">camera.save(); <span class="comment">// 保存 Camera 的状态</span></span><br><span class="line">camera.rotateX(<span class="number">30</span>); <span class="comment">// 旋转 Camera 的三维空间</span></span><br><span class="line">camera.applyToCanvas(canvas); <span class="comment">// 把旋转投影到 Canvas</span></span><br><span class="line">camera.restore(); <span class="comment">// 恢复 Camera 的状态</span></span><br><span class="line"></span><br><span class="line">canvas.translate(-centerX, -centerY); <span class="comment">// 旋转之后把投绘制内容动回来</span></span><br></pre></td></tr></table></figure><h2 id="像素块分析"><a href="#像素块分析" class="headerlink" title="像素块分析"></a>像素块分析</h2><p>类似于颜色处理，除了使用矩阵的方式，还可以使用基于像素的方式进行图形处理。具体处理的时候需要使用drawBitmapMesh()方法，该方法像一张网格，把图像分成一个个像素块，通过改变像素块间节点的坐标位置，使整个图像的图形发生变化。</p><p>该方法具体形式如下：<br>drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint)</p><p>其中关键参数有：</p><ul><li>bitmap：需要形变的图像</li><li>meshWidth：横向网格数目</li><li>meshHeight：纵向网格数目</li><li>verts：网格交叉点坐标数组</li><li>vertOffset：绘制的时候，verts数组跳过坐标对数目</li></ul><p>其中最重要的参数是verts数组，drawBitmapMesh()方法绘制前会将图像分成多个像素块，假如在图像上的横向和纵向各画N（N &gt; 1，线条从图像边缘开始）条线，这些线会交叉组成NxN个的点，那么，每个点的坐标值以 x1, y1, x2, y2, … , xn, yn 的形式保存在verts数组中，drawBitmapMesh()方法就是通过改变这些坐标值，重新定位每个像素块，从而改变图像形状。</p><p>drawBitmapMesh()方法基本上可以实现所有的图像特效，其使用关键在于计算去，确定新的交叉点坐标。</p><h2 id="通过像素块进行图形处理"><a href="#通过像素块进行图形处理" class="headerlink" title="通过像素块进行图形处理"></a>通过像素块进行图形处理</h2><p>这里使用drawBitmapMesh()方法使一张图片产生“旗帜飞扬”的效果。</p><p>要达到这个效果，需要保持交叉点的横坐标不变，并且交叉点纵坐标呈现一个三角函数的周期变化。</p><ul><li>获取交叉点坐标</li></ul><p>基本原理是通过遍历所有的交叉线，按比例获取交叉点坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网线数目 = 网格数目 + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> HEIGHT = <span class="number">19</span>; <span class="comment">// 纵向网格数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> WIDTH = <span class="number">29</span>; <span class="comment">// 横向网格数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取原始交叉点坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] getBitmapVerts(Bitmap bitmap) &#123;</span><br><span class="line">    <span class="keyword">float</span>[] verts = <span class="keyword">new</span> <span class="keyword">float</span>[(WIDTH + <span class="number">1</span>) * (HEIGHT + <span class="number">1</span>) * <span class="number">2</span>]; <span class="comment">// 坐标值数目 = 2 * 交点数目</span></span><br><span class="line">    <span class="keyword">float</span> bitmapHeight = bitmap.getHeight();</span><br><span class="line">    <span class="keyword">float</span> bitmapWidth = bitmap.getWidth();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= HEIGHT; y++) &#123;</span><br><span class="line">        <span class="keyword">float</span> fy = bitmapHeight * y / HEIGHT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= WIDTH; x++) &#123;</span><br><span class="line">            <span class="keyword">float</span> fx = bitmapWidth * x / WIDTH;</span><br><span class="line">            verts[index * <span class="number">2</span>] = fx;</span><br><span class="line">            verts[index * <span class="number">2</span> + <span class="number">1</span>] = fy + <span class="number">100</span>; <span class="comment">// 为了避免图像偏移后被遮挡，将纵坐标+100，使图像下移</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改变交叉点坐标值</li></ul><p>横坐标不变，使用正弦函数改变纵坐标值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据正选函数修改交叉点坐标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verts 交叉点坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> K 相位，用于动态改变偏移量，实现动态效果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A 振幅，用于改变偏移幅度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flagWave</span><span class="params">(<span class="keyword">float</span>[] verts, <span class="keyword">float</span> K, <span class="keyword">float</span> A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= HEIGHT; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WIDTH; i++) &#123;</span><br><span class="line">            <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) Math.sin(((<span class="keyword">float</span>) i / WIDTH + K) * <span class="number">2</span> * Math.PI);</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">2</span> * (j * (WIDTH + <span class="number">1</span>) + i);</span><br><span class="line">            verts[index] += <span class="number">0</span>;</span><br><span class="line">            verts[index + <span class="number">1</span>] += offsetY * A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据交叉点绘制图像</li></ul><p>这样绘制可以得到一个静态的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mVerts[] = getBitmapVerts(mBitmap);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> K = <span class="number">0f</span>, A = <span class="number">50f</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    flagWave(mVerts, K, A);</span><br><span class="line">    canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重绘产生动态效果</li></ul><p>每次重绘时，通过改变正弦函数的相位来改变纵坐标的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    flagWave(mVerts, K, A);</span><br><span class="line">    canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变相位后重绘，产生飘扬效果</span></span><br><span class="line">    K += <span class="number">0.1f</span>;</span><br><span class="line">    postInvalidateDelayed(<span class="number">50</span>); <span class="comment">// 延时重绘，避免飘扬太快</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图像特效按照处理对象一般可以分为颜色特效和图形特效两类，下面分别进行介绍。&lt;/p&gt;
&lt;h1 id=&quot;颜色特效&quot;&gt;&lt;a href=&quot;#颜色特效&quot; class=&quot;headerlink&quot; title=&quot;颜色特效&quot;&gt;&lt;/a&gt;颜色特效&lt;/h1&gt;&lt;p&gt;在Android系统中，通常使用B
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>XML绘图</title>
    <link href="http://yoursite.com/2018/01/02/XML%E7%BB%98%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/01/02/XML绘图/</id>
    <published>2018-01-02T02:03:01.000Z</published>
    <updated>2018-01-02T03:07:56.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>在XML中使用Bitmap的语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@[package:]drawable/drawable_resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:antialias</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:dither</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:filter</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">[</span>"<span class="attr">top</span>" | "<span class="attr">bottom</span>" | "<span class="attr">left</span>" | "<span class="attr">right</span>" | "<span class="attr">center_vertical</span>" |</span></span><br><span class="line"><span class="tag">                    "<span class="attr">fill_vertical</span>" | "<span class="attr">center_horizontal</span>" | "<span class="attr">fill_horizontal</span>" |</span></span><br><span class="line"><span class="tag">                    "<span class="attr">center</span>" | "<span class="attr">fill</span>" | "<span class="attr">clip_vertical</span>" | "<span class="attr">clip_horizontal</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:mipMap</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:tileMode</span>=<span class="string">[</span>"<span class="attr">disabled</span>" | "<span class="attr">clamp</span>" | "<span class="attr">repeat</span>" | "<span class="attr">mirror</span>"] /&gt;</span></span><br></pre></td></tr></table></figure><p>通过这种方式引用图片，可以直接将res中只读的图片资源转成Bitmap对象使用。</p><h1 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h1><p>在XML中使用Shape的语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">[</span>"<span class="attr">rectangle</span>" | "<span class="attr">oval</span>" | "<span class="attr">line</span>" | "<span class="attr">ring</span>"] &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:radius</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:topLeftRadius</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:topRightRadius</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomLeftRadius</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomRightRadius</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:angle</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerX</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerY</span>=<span class="string">"float"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerColor</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:endColor</span>=<span class="string">"color"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gradientRadius</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:startColor</span>=<span class="string">"color"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:type</span>=<span class="string">[</span>"<span class="attr">linear</span>" | "<span class="attr">radial</span>" | "<span class="attr">sweep</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:useLevel</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"] /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:left</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:top</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:right</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottom</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"color"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stroke</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"color"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashWidth</span>=<span class="string">"integer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashGap</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Shape是XML绘图的关键，无论是扁平化、拟物化还是渐变，它都可以实现。</p><h1 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h1><p>在XML中使用Layer的语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@[package:]drawable/drawable_resource"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@[+][package:]id/resource_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:top</span>=<span class="string">"dimension"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:right</span>=<span class="string">"dimension"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottom</span>=<span class="string">"dimension"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:left</span>=<span class="string">"dimension"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过Layer可以很方便地实现图层叠加的效果。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector用于定义的可绘制对象，它根据对象的状态，使用多个不同的图像来表示同一个图形。</p><p>在XML中使用Selector的语法如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:constantSize</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:dither</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:variablePadding</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"] &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@[package:]drawable/drawable_resource"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_pressed</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_focused</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_hovered</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_selected</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_checkable</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_checked</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_activated</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_window_focused</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"] /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过Selector可以快速实现View的触摸反馈。通过配置不同的触发事件，自动选择不同的图像作为背景图。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>以上只是介绍了常用的XML绘图方法，更多XML绘图方法可以参考<a href="https://developer.android.com/guide/topics/resources/drawable-resource.html" target="_blank" rel="noopener">官方文档</a>。</p><p>另外，上面介绍的XML绘图方法是可以配合使用的，比如在Selector中的Item中使用Shape实现圆角的背景图片。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bitmap&quot;&gt;&lt;a href=&quot;#Bitmap&quot; class=&quot;headerlink&quot; title=&quot;Bitmap&quot;&gt;&lt;/a&gt;Bitmap&lt;/h1&gt;&lt;p&gt;在XML中使用Bitmap的语法如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight xml
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2D绘图</title>
    <link href="http://yoursite.com/2018/01/02/2D%E7%BB%98%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/01/02/2D绘图/</id>
    <published>2018-01-02T01:42:10.000Z</published>
    <updated>2018-01-02T01:52:04.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h1><p>Android系统提供了Canvas和Paint对象进行绘图，类似于现实生活中的画板和画笔。</p><p>Canvas提供了绘制各种图形的API，常用的有：</p><ul><li>drawPoint(); 绘制点</li><li>drawLine(); 绘制线</li><li>drawRect(); 绘制矩形</li><li>drawRoundRect(); 绘制圆角矩形</li><li>drawVertices(); 绘制多边形</li><li>drawArc(); 绘制弧形和扇形</li><li>drawCircle(); 绘制圆</li><li>drawOval(); 绘制椭圆</li><li>drawText(); 绘制文本</li><li>drawColor(); 绘制颜色</li><li>drawPath(); 绘制路径（可以用于绘制自定义图形）</li><li>drawBitmap(); 绘制图像</li></ul><p>Paint提供了各种绘制效果的API，常用的有：</p><ul><li>setAntiAlias(); 设置画笔的锯齿效果</li><li>setColor(); 设置画笔的颜色</li><li>setARGB(); 设置画笔的A R G B值</li><li>setAlpha(); 设置画笔的透明度</li><li>setTextSize(); 设置字体的尺寸</li><li>setStyle(); 设置画笔的风格（实心或空心等）</li><li>setStrokeWidth(); 设置画笔的宽度</li></ul><p>具体绘制的时候，可以任意组合Canvas和Paint的API实现不同的绘制效果，比如绘制一个红色实心矩形。</p><h1 id="Canvas高级使用"><a href="#Canvas高级使用" class="headerlink" title="Canvas高级使用"></a>Canvas高级使用</h1><p>虽然通过Canvas的drawXXX()方法可以绘制各种图形，但是对于一些复杂的图形，会涉及到复杂的坐标运算，为了简化坐标运算，可以使用以下方法。</p><ul><li><p>Canvas.save()和Canvas.restore()<br>save()的作用是将之前已绘制的图像保存起来，这样，后续绘制操作相当于在一个新的图层上进行；<br>restore()方法作用是将save()之后绘制的图像与save()之前绘制的图像进行合并，即将新的图层绘制到Canvas上；<br>这两个方法一般是配合使用；</p></li><li><p>Canvas.translate()和Canvas.rotate()<br>translate(x, y)方法可以理解为将绘图的坐标原点(0, 0)移到(x, y)，后续的绘图操作都以(x, y)为原点进行；<br>rotate()方法可以理解为将绘图的坐标系旋转一定的角度，后续的绘图操作都以旋转后的坐标系为参照进行，这样可以减少坐标计算，例如，在原坐标系中的斜线，在旋转后的坐标系中只需要绘制成直线；</p></li></ul><p>Canvas还提供了clipXXX()方法对图像进行裁剪，比如clipRect()方法可以将绘制好的图像裁剪成为矩形。</p><h1 id="Layer图层"><a href="#Layer图层" class="headerlink" title="Layer图层"></a>Layer图层</h1><p>一张复杂的图像可以由多个图层叠加形成，多个图层就形成了一个栈的结构，Android系统对图层的管理就是通过栈的结构进行的。</p><p>saveLayer()和saveLayerAlpha()方法将一个图层入栈；restore()和restoreToCount()方法将一个图层出栈。</p><p>入栈的时候，后面所有的绘制操作都发生在这个图层上；出栈的时候，会把图层上的图像绘制到Canvas上。</p><p>通过控制图层的位置、透明度等，可以绘制出各种复杂的图像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绘图基础&quot;&gt;&lt;a href=&quot;#绘图基础&quot; class=&quot;headerlink&quot; title=&quot;绘图基础&quot;&gt;&lt;/a&gt;绘图基础&lt;/h1&gt;&lt;p&gt;Android系统提供了Canvas和Paint对象进行绘图，类似于现实生活中的画板和画笔。&lt;/p&gt;
&lt;p&gt;Canvas提供
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>屏幕信息</title>
    <link href="http://yoursite.com/2017/12/29/%E5%B1%8F%E5%B9%95%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/12/29/屏幕信息/</id>
    <published>2017-12-29T01:43:49.000Z</published>
    <updated>2018-01-02T02:59:51.061Z</updated>
    
    <content type="html"><![CDATA[<p>Android手机屏幕的尺寸、分辨率多种多样，这为绘图造成了一定的难度，想要在不同的屏幕上保持绘图的准确性，需要对屏幕的信息有充分了解。</p><h1 id="屏幕参数"><a href="#屏幕参数" class="headerlink" title="屏幕参数"></a>屏幕参数</h1><p>通常Android手机屏幕有下面几个参数：</p><ul><li><p>屏幕尺寸<br>指屏幕对角线的长度，通常使用“寸”表示，比如4.7寸手机。</p></li><li><p>分辨率<br>指屏幕像素点的个数，例如720 x 1280分辨率手机表示：宽有个720个像素点，高有1280个像素点。</p></li><li><p>ppi或dpi<br>指每英寸像素（Pixels Per Inch），又称dpi（Dots Per Inch），由对角线的像素点个数除以屏幕的尺寸得到。</p></li></ul><h1 id="Android系统屏幕密度"><a href="#Android系统屏幕密度" class="headerlink" title="Android系统屏幕密度"></a>Android系统屏幕密度</h1><p>虽然Android手机有各种尺寸和分辨率，但是Android系统定义了几个标准的dpi值，在具体适配时，只需要对下面表格里的标准dpi进行适配即可。</p><table><thead><tr><th>屏幕类型</th><th>ldpi</th><th>mdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th></tr></thead><tbody><tr><td>密度值</td><td>120</td><td>160</td><td>240</td><td>320</td><td>480</td></tr><tr><td>分辨率</td><td>240x320</td><td>320x480</td><td>480x800</td><td>720x1280</td><td>1080x1920</td></tr></tbody></table><h1 id="独立像素密度dp"><a href="#独立像素密度dp" class="headerlink" title="独立像素密度dp"></a>独立像素密度dp</h1><p>由于Android手机屏幕密度不同，因此，同样的像素点个数在不同屏幕上显示的长度也不同，因为高密度屏幕在同样的长度范围包含更多像素点。为了解决这个问题，Android系统使用dp（Device Independent Pixels，又称dip）表示屏幕长度，并规定在mdpi中，1dp = 1px，这样可以根据屏幕的密度值进行换算，得到每种屏幕密度对应的像素数目，例如，在xhdpi中，1dp = 320/160 * 1px = 2px。</p><h1 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h1><p>根据上面的分析，可以手动对像素单位进行转换，不过更好的方式是使用系统的TypedValue类，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dip to pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">dipToPixels</span><span class="params">(Context context, <span class="keyword">float</span> dipValue)</span> </span>&#123;</span><br><span class="line">    DisplayMetrics metrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">return</span> TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dipValue, metrics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sp to pixels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">spToPixels</span><span class="params">(Context context, <span class="keyword">float</span> spValue)</span> </span>&#123;</span><br><span class="line">    DisplayMetrics metrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">return</span> TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, metrics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android手机屏幕的尺寸、分辨率多种多样，这为绘图造成了一定的难度，想要在不同的屏幕上保持绘图的准确性，需要对屏幕的信息有充分了解。&lt;/p&gt;
&lt;h1 id=&quot;屏幕参数&quot;&gt;&lt;a href=&quot;#屏幕参数&quot; class=&quot;headerlink&quot; title=&quot;屏幕参数&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="绘图处理" scheme="http://yoursite.com/tags/%E7%BB%98%E5%9B%BE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实现滑动的方法</title>
    <link href="http://yoursite.com/2017/12/27/%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/27/实现滑动的方法/</id>
    <published>2017-12-27T10:26:58.000Z</published>
    <updated>2017-12-28T07:20:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>了解<a href="/2017/12/26/滑动实现原理/">滑动实现原理</a>后，可以总结出实现滑动效果的基本思想：当View被触摸时，记录当前触摸点的坐标；当触摸点移动时，记录移动后触摸点的坐标；根据两次获取的坐标计算出触摸点的偏移量，通过偏移量修改View的坐标；不断重复，实现滑动效果。</p><p>接下来介绍实现滑动效果的一些方法。</p><h1 id="layout方法"><a href="#layout方法" class="headerlink" title="layout方法"></a>layout方法</h1><p>在View进行绘制时，会调用onLayout()方法设置显示的位置，因此，可以通过修改View的left，top，right，bottom属性来控制View的坐标。具体在onTouchEvent()方法中实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据偏移量重新布局View，使View移动产生滑动效果</span></span><br><span class="line">            layout(getLeft() + offsetX, getTop() + offsetY,</span><br><span class="line">                    getRight() + offsetX, getBottom() + offsetY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面的示例代码是通过getX()和getY()方法获取触摸事件的坐标值，下面以getRawX()和getRawY()方法来获取坐标值实现滑动效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> rawX = (<span class="keyword">int</span>) event.getRawX();</span><br><span class="line">    <span class="keyword">int</span> rawY = (<span class="keyword">int</span>) event.getRawY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = rawX;</span><br><span class="line">            lastY = rawY;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = rawX - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = rawY - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据偏移量重新布局View，使View移动产生滑动效果</span></span><br><span class="line">            layout(getLeft() + offsetX, getTop() + offsetY,</span><br><span class="line">                    getRight() + offsetX, getBottom() + offsetY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新设置初始坐标</span></span><br><span class="line">            lastX = rawX;</span><br><span class="line">            lastY = rawY;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>使用绝对坐标系时，每次执行完ACTION_MOVE逻辑后，一定要重新设置初始坐标，这样才能准确获取连续移动时的偏移量。因为在相对坐标系中，ACTION_DOWN事件的坐标值对于View是不变的，而在绝对坐标系中，这个坐标值对于View是变化的。</p></blockquote><h1 id="offsetLeftAndRight和offsetTopAndBottom方法"><a href="#offsetLeftAndRight和offsetTopAndBottom方法" class="headerlink" title="offsetLeftAndRight和offsetTopAndBottom方法"></a>offsetLeftAndRight和offsetTopAndBottom方法</h1><p>这两个方法只需要偏移量就可以完成View的重新绘制，达到layout方法同样的效果，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据偏移量重新布局View，使View移动产生滑动效果</span></span><br><span class="line">            offsetLeftAndRight(offsetX);</span><br><span class="line">            offsetTopAndBottom(offsetY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h1><p>LayoutParams保存了View的布局参数，可以通过改变LayoutParams来动态修改View的位置参数，实现View的滑动效果。具体示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据偏移量重新布局View，使View移动产生滑动效果</span></span><br><span class="line">            ViewGroup.MarginLayoutParams layoutParams =</span><br><span class="line">                    (ViewGroup.MarginLayoutParams) getLayoutParams();</span><br><span class="line">            layoutParams.leftMargin += offsetX;</span><br><span class="line">            layoutParams.topMargin += offsetY;</span><br><span class="line">            setLayoutParams(layoutParams);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="scrollTo与scrollBy方法"><a href="#scrollTo与scrollBy方法" class="headerlink" title="scrollTo与scrollBy方法"></a>scrollTo与scrollBy方法</h1><p>View提供了scrollTo与scrollBy方法来改变View的位置，scrollTo(x,  y)表示移动到坐标点(x, y)，scrollBy(dx, dy)表示移动的增量为dx、dy。</p><p>scrollTo与scrollBy方法的本质是移动View，从而使View中content产生相对移动。以下示意图以scrollBy方法为例进行说明：</p><p><img src="/uploads/android/理解scrollBy方法.png" alt="理解scrollBy方法"></p><p>从示意图可以看出，content移动的方向和ViewGroup移动的方向是相反的，所以，如果以子View的偏移量来移动ViewGroup来达到子View的滑动效果，那么，scrollBy中的偏移量要使用负值。</p><p>根据以上分析，使用scrollBy方法实现滑动效果的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据偏移量重新布局View，使View移动产生滑动效果</span></span><br><span class="line">            ((View) getParent()).scrollBy(-offsetX, -offsetY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，在绝对坐标系中，可以使用scrollTo方法实现同样的滑动效果。</p><h1 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h1><p>在使用scrollTo与scrollBy方法移动时，View的移动都是瞬时完成的，为了产生平滑移动的效果，需要使用Scroller类。</p><p>Scroller的原理也是使用scrollTo与scrollBy方法来移动View，但是它会把移动的偏移量分为多个很小的偏移量，虽然在每个小的偏移量里面，移动是瞬时的，但是整体上会是一个平滑的移动效果。</p><p>使用Scroller类实现滑动效果需要以下几个步骤：</p><ul><li>初始化Scroller</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mScroller = <span class="keyword">new</span> Scroller(context);</span><br></pre></td></tr></table></figure><ul><li>重写computeScroll()方法，实现平滑移动</li></ul><p>系统绘制View的时候会在draw()方法中调用computeScroll()方法，可以在computeScroll()中使用scrollTo()方法进行小的偏移量的移动，接着调用invalidate()方法触发draw()方法，形成一个循环过程，最终实现平滑移动。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="comment">// 判断Scroller是否执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        <span class="comment">// 通过重绘不断调用computeScroll()，达到平滑移动的效果</span></span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动过程，用时提供了getCurX()、getCurY()方法获取当前的滑动坐标。</p><ul><li>执行startScroll()方法，执行滑动过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取触摸点坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 记录当前触摸点坐标</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行滑动过程</span></span><br><span class="line">            View viewGroup = (View) getParent();</span><br><span class="line">            mScroller.startScroll(viewGroup.getScrollX(), viewGroup.getScrollY(),</span><br><span class="line">                    -offsetX, -offsetY, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 通过重绘首次触发computeScroll()</span></span><br><span class="line">            invalidate();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常使用getScrollX()和getScrollY()方法获取滑动的起始坐标，由于是父视图在滑动，因此，偏移值的正负情况与scrollTo、scrollBy方法相同。同时，需要注意调用invalidate()触发computeScroll()方法进行滑动过程。</p><h1 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h1><p>Android的Support库中提供了DrawerLayout和SlidingPaneLayout方便实现侧滑菜单的效果，这两个布局就是通过ViewDragHelper类实现的。通过ViewDragHelper类，基本可以实现各种不同的Scroll、Drag需求。</p><p>ViewDragHelper功能比较强大，使用也相对比较复杂，具体使用可以搜索相关资料，这里就不详细介绍了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解&lt;a href=&quot;/2017/12/26/滑动实现原理/&quot;&gt;滑动实现原理&lt;/a&gt;后，可以总结出实现滑动效果的基本思想：当View被触摸时，记录当前触摸点的坐标；当触摸点移动时，记录移动后触摸点的坐标；根据两次获取的坐标计算出触摸点的偏移量，通过偏移量修改View的坐标；
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="滑动效果" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
</feed>
