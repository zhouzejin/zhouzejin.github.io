<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Paint使用]]></title>
    <url>%2F2018%2F01%2F11%2FPaint%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在2D绘图中可以了解到Paint的基本使用，使用这些基本方法可以实现一般的绘制需求，如果要实现更加丰富的绘图效果，需要了解Paint的更详细使用。 Paint的方法按功能可以分为四类：颜色处理、绘制效果、文字绘制和初始化相关。 颜色处理颜色处理有三个层次：直接使用设置颜色的API给图形和文字设置颜色；使用setColorFilter()基于颜色进行过滤处理；使用setXfermode()处理源图像和Canvas已有内容的关系。 颜色设置Paint设置颜色的方法有两种：一种是直接用Paint.setColor/ARGB()来设置颜色，另一种是使用Shader来指定着色方案。 直接设置颜色 setColor(int color) setARGB(int a, int r, int g, int b) 使用Shader通过setShader(Shader shader)设置Shader后，Paint 在绘制图形和文字时就不使用setColor/ARGB()设置的颜色了，而是使用Shader中的颜色方案。系统提供的Shader有以下几类： LinearGradient 线性渐变 RadialGradient 辐射渐变 BitmapShader 用Bitmap的像素来作为图形或文字的填充 上面三种Shader都有3种着色规则（TileMode）：CLAMP会在端点之外延续端点处的颜色；MIRROR是镜像模式；REPEAT是重复模式。 SweepGradient 扫描渐变 ComposeShader 混合着色器，把两个Shader叠加使用叠加使用时，需要用到叠加模式，它的类型是PorterDuff.Mode，决定shaderA和shaderB应该怎样共同绘制。 设置滤色器通过setColorFilter(ColorFilter colorFilter)设置滤色器，系统提供的ColorFilter有以下几类： LightingColorFilter模拟简单的光照效果。 PorterDuffColorFilter使用一个指定的颜色和一种指定的PorterDuff.Mode来与绘制对象进行合成。 ColorMatrixColorFilter使用一个ColorMatrix来对颜色进行处理，具体使用可以查看图像特效中的颜色特效。 设置TransferMode通过setXfermode(Xfermode xfermode)设置TransferMode，”Xfermode”是”Transfer mode”的简写，指的是要绘制的内容和Canvas目标位置的内容进行颜色结合的模式，简单来说，就是以要绘制的内容作为源图像，以Canvas中已有的内容作为目标图像，选取一个PorterDuff.Mode作为绘制内容的颜色处理方案。 创建Xfermode的时候其实是创建的它的子类PorterDuffXfermode，而事实上，Xfermode只有这一个子类。 绘制效果绘制效果指的就是抗锯齿、填充/轮廓、线条宽度等等这些。 抗锯齿使用setAntiAlias (boolean b)设置是否抗锯齿。 绘制风格使用setStyle(Paint.Style style)设置图形是线条风格还是填充风格的（或者二者并用）。 线条形状 setStrokeWidth(float width)设置线条宽度。单位为像素，默认值是 0。 setStrokeCap(Paint.Cap cap)设置线头的形状。线头形状有三种：BUTT平头、ROUND圆头、SQUARE方头。默认为BUTT。 setStrokeJoin(Paint.Join join)设置拐角的形状。有三个值可以选择：MITER尖角、 BEVEL平角和ROUND 圆角。默认为MITER。 setStrokeMiter(float miter)这个方法是对于setStrokeJoin()的一个补充，它用于设置MITER型拐角的延长线的最大值，所谓“延长线的最大值”。 色彩优化 setDither(boolean dither)设置图像的抖动。 setFilterBitmap(boolean filter)设置是否使用双线性过滤来绘制Bitmap。图像在放大绘制的时候，默认使用的是最近邻插值过滤，这种算法简单，但会出现马赛克现象；而如果开启了双线性过滤，就可以让结果图像显得更加平滑。 PathEffect通过setPathEffect(PathEffect effect)给图形的轮廓设置效果，对Canvas所有的图形绘制有效，即对 drawLine() drawCircle() drawPath() 这些方法有效。 单一效果的PathEffect有： CornerPathEffect把所有拐角变成圆角。 DiscretePathEffect把线条进行随机的偏离，让轮廓变得乱七八糟。 DashPathEffect使用虚线来绘制线条。 PathDashPathEffect比DashPathEffect多一个前缀Path，顾名思义，它是使用一个Path来绘制“虚线”。 组合效果类的PathEffect有： SumPathEffect按照两种PathEffect分别对目标进行绘制。 ComposePathEffect先对目标Path使用一个PathEffect，然后再对这个改变后的Path使用另一个PathEffect。 添加阴影具体使用setShadowLayer(float radius, float dx, float dy, int shadowColor)方法。radius是阴影的模糊范围；dx dy是阴影的偏移量；shadowColor是阴影的颜色。 如果要清除阴影层，使用clearShadowLayer()方法。 MaskFiltersetShadowLayer()设置的是绘制层下方的附加效果；而MaskFilter和它相反，setMaskFilter(filter)设置的是绘制层上方的附加效果。 前面有一个setColorFilter(filter)方法，它对每个像素的颜色进行过滤；而setMaskFilter(filter)是基于整个画面来进行过滤。 BlurMaskFilter 模糊效果 EmbossMaskFilter 浮雕效果 获取绘制的Path根据Paint的设置，计算出绘制Path或文字时的实际Path，所谓实际Path，指的就是drawPath()绘制内容的轮廓，要算上线条宽度和设置的PathEffect。 getFillPath(Path src, Path dst)src是原Path，而dst就是实际Path的保存位置。 getTextPath()获取的就是目标文字所对应的Path。 获取绘制的Path主要是用于图形和文字的装饰效果的位置计算，比如自定义的下划线效果。 文字绘制Paint有很多文字绘制相关的方法，即和drawText()相关的方法，这些方法可以设置文字大小、文字间隔、文字效果等。除此之外，Paint还有很多与文字绘制相关的设置或计算的方法，具体可以参考官方文档。 初始化相关这一类方法很简单，它们是用来初始化Paint对象，或者是批量设置Paint的多个属性的方法。 reset()重置Paint的所有属性为默认值。相当于重新new一个，不过性能相对要高。 set(Paint src)把src的所有属性全部复制过来。相当于调用src所有的get方法，然后调用这个Paint的对应的set方法来设置它们。 setFlags(int flags)批量设置flags。相当于依次调用它们的set方法。 这里只是简单介绍了Paint提供的绘制功能，详细介绍可以参考HenCoder的Paint详解。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像特效]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%9B%BE%E5%83%8F%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[图像特效按照处理对象一般可以分为颜色特效和图形特效两类，下面分别进行介绍。 颜色特效在Android系统中，通常使用Bitmap（位图）的数据结构来表示一张图片，它包含了图片的所有数据。Bitmap由点阵和颜色值组成，点阵是图片像素的矩阵，其中每个元素对应图片的一个像素；颜色值（ARGB）分别对应透明度、红、绿、蓝四个分量，它们共同决定每个像素点的颜色。 进行颜色处理时，通常使用以下三个角度来描述一个图像： 色调——物体的颜色 饱和度——颜色的纯度，从0（灰）到100%（饱和）进行描述 亮度——颜色的明暗程度 颜色矩阵——ColorMatrixAndroid中使用颜色矩阵（ColorMatrix）处理图像的颜色效果，ColorMatrix是一个4x5的矩阵，对于图像的每个像素点，都有一个4x1的颜色分量矩阵保存颜色的RGBA值。 具体对图像的颜色进行处理时，会通过一定的算法得到一个对应效果的ColorMatrix，接着把这个矩阵分别与每个像素点的颜色分量矩阵进行乘法运算得到新的颜色分量矩阵，最后为每个像素点设置新的颜色分量矩阵，从而达到颜色特效的处理效果，具体过程如下所示： 根据上述过程，可以得到： 根据处理结果可以知道，在4x5的ColorMatrix中： 第一行r1 g1 b1 a1 o1的值决定新颜色值中的R（红色） 第二行r2 g2 b2 a2 o2的值决定新颜色值中的G（绿色） 第三行r3 g3 b3 a3 o3的值决定新颜色值中的B（蓝色） 第四行r4 g4 b4 a4 o4的值决定新颜色值中的A（透明度） 第五列o1 o2 o3 o4的值决定新颜色值中每个分量的偏移量（offset） 因此，对图像的颜色进行处理时，通常有两种方法：一个是改变颜色的offset；另一个是改变对应RGBA值的系数。 通过颜色矩阵进行颜色处理改变ColorMatrix方式通常有两种：一种是通过系统API修改；另一种是利用经典算法直接创建。 通过系统API修改通过系统API修改颜色矩阵可以改变图像的色调、饱和度和亮度。 色调使用setRotate(int axis, float degrees)方法设置颜色矩阵的色调。axis使用0，1，2来表示Red、Green、Blue三种颜色的处理；degrees表示处理的具体值。 饱和度使用setSaturation(float sat)方法设置颜色矩阵的饱和度。当饱和度为0时，图像会变为灰色。 亮度使用setScale(float rScale, float gScale, float bScale, float aScale)方法设置颜色矩阵的亮度。其本质是利用三原色以同比例混合会显示出白色的原理。当亮度为0时，图像会变为黑色。 效果叠加除了上面三种处理方法外，还可以使用postConcat()方法将不同效果的矩阵进行混合，从而产生叠加效果。 下面的示例代码展示了如何使用上面介绍的方法： 123456789101112131415161718192021222324252627public static Bitmap handleImageEffect(Bitmap bm, float hue, float saturation, float lum) &#123; Bitmap bitmap = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); ColorMatrix hueMatrix = new ColorMatrix(); hueMatrix.setRotate(0, hue); hueMatrix.setRotate(1, hue); hueMatrix.setRotate(2, hue); ColorMatrix saturationMatrix = new ColorMatrix(); saturationMatrix.setSaturation(saturation); ColorMatrix lumMatrix = new ColorMatrix(); lumMatrix.setScale(lum, lum, lum, 1); ColorMatrix imageMatrix = new ColorMatrix(); imageMatrix.postConcat(hueMatrix); imageMatrix.postConcat(saturationMatrix); imageMatrix.postConcat(lumMatrix); paint.setColorFilter(new ColorMatrixColorFilter(imageMatrix)); canvas.drawBitmap(bm, 0, 0, paint); return bitmap;&#125; 利用经典算法创建图像色彩处理，通常就是研究如何通过某种算法创建颜色矩阵，将其作用到图像上，形成新的色彩风格的图像。下面介绍一些经典算法对应的颜色矩阵。 灰度效果 1234567// 灰度效果float[] colorMatrix = new float[] &#123; 0.33f, 0.59f, 0.11f, 0, 0, 0.33f, 0.59f, 0.11f, 0, 0, 0.33f, 0.59f, 0.11f, 0, 0, 0, 0, 0, 1, 0,&#125;; 图像反转 1234567// 图像反转float[] colorMatrix = new float[] &#123; -1, 0, 0, 1, 1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 0,&#125;; 怀旧效果 1234567// 怀旧效果float[] colorMatrix = new float[] &#123; 0.393f, 0.769f, 0.189f, 0, 0, 0.349f, 0.686f, 0.168f, 0, 0, 0.272f, 0.534f, 0.131f, 0, 0, 0, 0, 0, 1, 0,&#125;; 去色效果 1234567// 去色效果float[] colorMatrix = new float[] &#123; 1.5f, 1.5f, 1.5f, 0, -1, 1.5f, 1.5f, 1.5f, 0, -1, 1.5f, 1.5f, 1.5f, 0, -1, 0, 0, 0, 1, 0,&#125;; 高饱和度 1234567// 高饱和度float[] colorMatrix = new float[] &#123; 1.438f, -0.122f, -0.016f, 0, -0.03f, -0.062f, 1.378f, -0.016f, 0, 0.05f, -0.062f, -0.122f, 1.483f, 0, -0.02f, 0, 0, 0, 1, 0,&#125;; 像素点分析除了通过ColorMatrix改变图像的颜色，还可以直接改变每个像素点的ARGB值来改变图像的颜色，这种处理方式相对更加精确。用这种方式处理图片时，需要注意原始图片是不可变的（mutable），需要复制原始图片进行处理。 Android中使用Bitmap.getPixels(int[] pixels, int offset, int stride,int x, int y, int width, int height)方法获取图片的像素点的颜色值： pixels: 接收位图像素点颜色值的数组 offset: 写入到pixels[]中的第一个像素索引值 stride: pixels[]的行间距 x: 从bitmap中读取的第一个像素的x坐标值 y: 从bitmap中读取的第一个像素的y坐标值 width: 每行的像素个数 height: 读取的行数 修改图像像素点的颜色值的关键代码如下所示： 1234567891011121314151617181920// 获取图片像素点的颜色值数组bitmap.getPixels(oldPx, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());// 获取每个像素点具体的ARGB值int color = oldPx[i];a = Color.alpha(color);r = Color.red(color);g = Color.green(color);b = Color.blue(color);// 根据图像处理算法修改像素点的ARGB值rn = (int) (0.393 * r + 0.322 * g + 0.189 * b);gn = (int) (0.393 * r + 0.322 * g + 0.189 * b);bn = (int) (0.393 * r + 0.322 * g + 0.189 * b);newPx[i] = Color.argb(a, rn, gn, bn);// 将修改后的颜色数组设置到位图上，完成颜色处理bitmap.setPixels(newPx, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight()); 通过像素点进行颜色处理通过Pixels进行颜色处理，就是通过特定的算法改变每个像素点的颜色值，从而得到相应的处理效果。下面介绍一些常用的处理算法。 底片效果 处理算法： 123r = 255 - r;g = 255 - g;b = 255 - b; 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738public static Bitmap handleImagePixels(Bitmap bitmap) &#123; int width = bitmap.getWidth(); int height = bitmap.getHeight(); int color; int a, r, g, b; Bitmap bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); int[] oldPx = new int[width * height]; int[] newPx = new int[width * height]; // 获取图片像素点的颜色值数组 bitmap.getPixels(oldPx, 0, width, 0, 0, width, height); for (int i = 0; i &lt; width * height; i++) &#123; // 获取每个像素点具体的ARGB值 color = oldPx[i]; a = Color.alpha(color); r = Color.red(color); g = Color.green(color); b = Color.blue(color); // 根据图像处理算法修改像素点的ARGB值 r = 255 - r; g = 255 - g; b = 255 - b; if (r &gt; 255) r = 255; if (r &lt; 0) r = 0; if (g &gt; 255) g = 255; if (g &lt; 0) g = 0; if (b &gt; 255) b = 255; if (b &lt; 0) b = 0; newPx[i] = Color.argb(a, r, g, b); &#125; // 将修改后的颜色数组设置到位图上，完成颜色处理 bmp.setPixels(newPx, 0, width, 0, 0, width, height); return bmp;&#125; 老照片效果 处理算法： 123rn = (int) (0.393 * r + 0.769 * g + 0.189 * b);gn = (int) (0.349 * r + 0.686 * g + 0.168 * b);bn = (int) (0.272 * r + 0.534 * g + 0.131 * b); 示例代码和上面类似。 图形特效可以将一张图像的形状进行处理，达到某种图形上的效果。Android中提供的常用处理方式有：平移、旋转、缩放和错切（skew），除了常用的处理方式，还可以通过变形矩阵自定义图形变换。 变形矩阵——Matrix类似于颜色矩阵，Android中使用变形矩阵（Matrix）处理图像的图形变换，变形矩阵是一个3x3的矩阵，对于图像的每个像素点，都有一个3x1的位置矩阵保存其X，Y的坐标值。 具体进行图形变换时，会将变形矩阵与每个像素的位置矩阵相乘，为每个像素设置新的位置，从而达到图像变换效果，具体过程如下所示： 根据上述过程，可以得到： 通常情况下为了保证 1 = gX + hY + i 成立，会令 g = h = 0，i = 1，这样，在处理图形变换时，只需要关注其它几个参数即可。 平移变换（Translate） 平移变换就是将所有像素点的坐标值进行平移，其变换过程如下： 旋转变换（Rotate） 旋转变换是将像素点围绕一个中心点进行选择，以原点为中心旋转一定角度的变换过程如下： 述变换过程是以坐标原点为中心旋转的，如果以任意点O为中心旋转通常需要：将坐标原点平移到O点；以原点为中心旋转；将坐标原点还原。 缩放变换（Scale） 缩放变换是对于多个像素点才会有效果，将图像沿X轴和Y轴按一定比例缩放的变换过程如下： 错切变换（Skew） 错切变换是将所有像素点的X坐标（或Y坐标）保持不变，而对应的Y坐标（或X坐标）按比例发生平移，并且平移的大小和该点到X轴（或Y轴）的垂直距离成正比。 错切变换的示意图如下所示： 错切变换过程如下： 通过变形矩阵进行图形处理与颜色矩阵一样，变形矩阵也提供了相关API简化图形变换，其中Matrix提供的方法是进行2D变换的，而Camera提供的方法还可以进行3D变换。 通过Matrix进行2D变换Matrix提供的变换API有： Matrix.setTranslate()：平移变换 Matrix.setRotate()：旋转变换 Matrix.setScale()：缩放变换 Matrix.setSkew()：错切变换 Matrix.setPolyToPoly() setRectToRect() setSinCos()：自定义变换 Matrix.preXXX()和Matrix.postXXX()：叠加变换 当设置完Matrix后，把Matrix设置到Canvas上有两个方法： Canvas.setMatrix(matrix)：用Matrix直接替换Canvas当前的变换矩阵，即抛弃Canvas当前的变换，改用Matrix的变换 Canvas.concat(matrix)：用Canvas当前的变换矩阵和Matrix相乘，即基于Canvas当前的变换，叠加上Matrix中的变换 通过Camera进行3D变换Camera提供的3D变换有三类： Camera.rotateXXX()：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行旋转，可以用来实现翻转效果。同时要注意，虚拟相机旋转的轴心是坐标原点。 Camera.translate(x, y, z)：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行移动，可以使用Canvas的translate()和scale()方法代替。 Camera.setLocation(x, y, z)：设置虚拟相机的位置，可以用来控制投影的图像大小。 当设置完Camera后，把Camera的Matrix设置到Canvas需要使用Camera.applyToCanvas(canvas)方法。 示例代码如下： 12345678canvas.translate(centerX, centerY); // 旋转之前把绘制内容移动到轴心（原点）camera.save(); // 保存 Camera 的状态camera.rotateX(30); // 旋转 Camera 的三维空间camera.applyToCanvas(canvas); // 把旋转投影到 Canvascamera.restore(); // 恢复 Camera 的状态canvas.translate(-centerX, -centerY); // 旋转之后把投绘制内容动回来 像素块分析类似于颜色处理，除了使用矩阵的方式，还可以使用基于像素的方式进行图形处理。具体处理的时候需要使用drawBitmapMesh()方法，该方法像一张网格，把图像分成一个个像素块，通过改变像素块间节点的坐标位置，使整个图像的图形发生变化。 该方法具体形式如下：drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 其中关键参数有： bitmap：需要形变的图像 meshWidth：横向网格数目 meshHeight：纵向网格数目 verts：网格交叉点坐标数组 vertOffset：绘制的时候，verts数组跳过坐标对数目 其中最重要的参数是verts数组，drawBitmapMesh()方法绘制前会将图像分成多个像素块，假如在图像上的横向和纵向各画N（N &gt; 1，线条从图像边缘开始）条线，这些线会交叉组成NxN个的点，那么，每个点的坐标值以 x1, y1, x2, y2, … , xn, yn 的形式保存在verts数组中，drawBitmapMesh()方法就是通过改变这些坐标值，重新定位每个像素块，从而改变图像形状。 drawBitmapMesh()方法基本上可以实现所有的图像特效，其使用关键在于计算去，确定新的交叉点坐标。 通过像素块进行图形处理这里使用drawBitmapMesh()方法使一张图片产生“旗帜飞扬”的效果。 要达到这个效果，需要保持交叉点的横坐标不变，并且交叉点纵坐标呈现一个三角函数的周期变化。 获取交叉点坐标 基本原理是通过遍历所有的交叉线，按比例获取交叉点坐标。 12345678910111213141516171819202122232425// 网线数目 = 网格数目 + 1private static int HEIGHT = 19; // 纵向网格数目private static int WIDTH = 29; // 横向网格数目/** * 获取原始交叉点坐标 */private float[] getBitmapVerts(Bitmap bitmap) &#123; float[] verts = new float[(WIDTH + 1) * (HEIGHT + 1) * 2]; // 坐标值数目 = 2 * 交点数目 float bitmapHeight = bitmap.getHeight(); float bitmapWidth = bitmap.getWidth(); int index = 0; for (int y = 0; y &lt;= HEIGHT; y++) &#123; float fy = bitmapHeight * y / HEIGHT; for (int x = 0; x &lt;= WIDTH; x++) &#123; float fx = bitmapWidth * x / WIDTH; verts[index * 2] = fx; verts[index * 2 + 1] = fy + 100; // 为了避免图像偏移后被遮挡，将纵坐标+100，使图像下移 index++; &#125; &#125; return verts;&#125; 改变交叉点坐标值 横坐标不变，使用正弦函数改变纵坐标值。 1234567891011121314151617/** * 根据正选函数修改交叉点坐标 * * @param verts 交叉点坐标 * @param K 相位，用于动态改变偏移量，实现动态效果 * @param A 振幅，用于改变偏移幅度 */private void flagWave(float[] verts, float K, float A) &#123; for (int j = 0; j &lt;= HEIGHT; j++) &#123; for (int i = 0; i &lt;= WIDTH; i++) &#123; float offsetY = (float) Math.sin(((float) i / WIDTH + K) * 2 * Math.PI); int index = 2 * (j * (WIDTH + 1) + i); verts[index] += 0; verts[index + 1] += offsetY * A; &#125; &#125;&#125; 根据交叉点绘制图像 这样绘制可以得到一个静态的效果。 12345678910private float mVerts[] = getBitmapVerts(mBitmap);private static float K = 0f, A = 50f;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(mVerts, K, A); canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, 0, null, 0, null);&#125; 重绘产生动态效果 每次重绘时，通过改变正弦函数的相位来改变纵坐标的偏移量。 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(mVerts, K, A); canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, 0, null, 0, null); // 改变相位后重绘，产生飘扬效果 K += 0.1f; postInvalidateDelayed(50); // 延时重绘，避免飘扬太快&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML绘图]]></title>
    <url>%2F2018%2F01%2F02%2FXML%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Bitmap在XML中使用Bitmap的语法如下所示： 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:antialias=["true" | "false"] android:dither=["true" | "false"] android:filter=["true" | "false"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:mipMap=["true" | "false"] android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&gt; 通过这种方式引用图片，可以直接将res中只读的图片资源转成Bitmap对象使用。 Shape在XML中使用Shape的语法如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] &gt; &lt;corners android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" /&gt; &lt;gradient android:angle="integer" android:centerX="float" android:centerY="float" android:centerColor="integer" android:endColor="color" android:gradientRadius="integer" android:startColor="color" android:type=["linear" | "radial" | "sweep"] android:useLevel=["true" | "false"] /&gt; &lt;padding android:left="integer" android:top="integer" android:right="integer" android:bottom="integer" /&gt; &lt;size android:width="integer" android:height="integer" /&gt; &lt;solid android:color="color" /&gt; &lt;stroke android:width="integer" android:color="color" android:dashWidth="integer" android:dashGap="integer" /&gt;&lt;/shape&gt; Shape是XML绘图的关键，无论是扁平化、拟物化还是渐变，它都可以实现。 Layer在XML中使用Layer的语法如下所示： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:id="@[+][package:]id/resource_name" android:top="dimension" android:right="dimension" android:bottom="dimension" android:left="dimension" /&gt;&lt;/layer-list&gt; 通过Layer可以很方便地实现图层叠加的效果。 SelectorSelector用于定义的可绘制对象，它根据对象的状态，使用多个不同的图像来表示同一个图形。 在XML中使用Selector的语法如下所示： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"] android:dither=["true" | "false"] android:variablePadding=["true" | "false"] &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:state_pressed=["true" | "false"] android:state_focused=["true" | "false"] android:state_hovered=["true" | "false"] android:state_selected=["true" | "false"] android:state_checkable=["true" | "false"] android:state_checked=["true" | "false"] android:state_enabled=["true" | "false"] android:state_activated=["true" | "false"] android:state_window_focused=["true" | "false"] /&gt;&lt;/selector&gt; 通过Selector可以快速实现View的触摸反馈。通过配置不同的触发事件，自动选择不同的图像作为背景图。 更多以上只是介绍了常用的XML绘图方法，更多XML绘图方法可以参考官方文档。 另外，上面介绍的XML绘图方法是可以配合使用的，比如在Selector中的Item中使用Shape实现圆角的背景图片。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D绘图]]></title>
    <url>%2F2018%2F01%2F02%2F2D%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[绘图基础Android系统提供了Canvas和Paint对象进行绘图，类似于现实生活中的画板和画笔。 Canvas提供了绘制各种图形的API，常用的有： drawPoint(); 绘制点 drawLine(); 绘制线 drawRect(); 绘制矩形 drawRoundRect(); 绘制圆角矩形 drawVertices(); 绘制多边形 drawArc(); 绘制弧形和扇形 drawCircle(); 绘制圆 drawOval(); 绘制椭圆 drawText(); 绘制文本 drawColor(); 绘制颜色 drawPath(); 绘制路径（可以用于绘制自定义图形） drawBitmap(); 绘制图像 Paint提供了各种绘制效果的API，常用的有： setAntiAlias(); 设置画笔的锯齿效果 setColor(); 设置画笔的颜色 setARGB(); 设置画笔的A R G B值 setAlpha(); 设置画笔的透明度 setTextSize(); 设置字体的尺寸 setStyle(); 设置画笔的风格（实心或空心等） setStrokeWidth(); 设置画笔的宽度 具体绘制的时候，可以任意组合Canvas和Paint的API实现不同的绘制效果，比如绘制一个红色实心矩形。 Canvas高级使用虽然通过Canvas的drawXXX()方法可以绘制各种图形，但是对于一些复杂的图形，会涉及到复杂的坐标运算，为了简化坐标运算，可以使用以下方法。 Canvas.save()和Canvas.restore()save()的作用是将之前已绘制的图像保存起来，这样，后续绘制操作相当于在一个新的图层上进行；restore()方法作用是将save()之后绘制的图像与save()之前绘制的图像进行合并，即将新的图层绘制到Canvas上；这两个方法一般是配合使用； Canvas.translate()和Canvas.rotate()translate(x, y)方法可以理解为将绘图的坐标原点(0, 0)移到(x, y)，后续的绘图操作都以(x, y)为原点进行；rotate()方法可以理解为将绘图的坐标系旋转一定的角度，后续的绘图操作都以旋转后的坐标系为参照进行，这样可以减少坐标计算，例如，在原坐标系中的斜线，在旋转后的坐标系中只需要绘制成直线； Canvas还提供了clipXXX()方法对图像进行裁剪，比如clipRect()方法可以将绘制好的图像裁剪成为矩形。 Layer图层一张复杂的图像可以由多个图层叠加形成，多个图层就形成了一个栈的结构，Android系统对图层的管理就是通过栈的结构进行的。 saveLayer()和saveLayerAlpha()方法将一个图层入栈；restore()和restoreToCount()方法将一个图层出栈。 入栈的时候，后面所有的绘制操作都发生在这个图层上；出栈的时候，会把图层上的图像绘制到Canvas上。 通过控制图层的位置、透明度等，可以绘制出各种复杂的图像。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏幕信息]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%B1%8F%E5%B9%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Android手机屏幕的尺寸、分辨率多种多样，这为绘图造成了一定的难度，想要在不同的屏幕上保持绘图的准确性，需要对屏幕的信息有充分了解。 屏幕参数通常Android手机屏幕有下面几个参数： 屏幕尺寸指屏幕对角线的长度，通常使用“寸”表示，比如4.7寸手机。 分辨率指屏幕像素点的个数，例如720 x 1280分辨率手机表示：宽有个720个像素点，高有1280个像素点。 ppi或dpi指每英寸像素（Pixels Per Inch），又称dpi（Dots Per Inch），由对角线的像素点个数除以屏幕的尺寸得到。 Android系统屏幕密度虽然Android手机有各种尺寸和分辨率，但是Android系统定义了几个标准的dpi值，在具体适配时，只需要对下面表格里的标准dpi进行适配即可。 屏幕类型 ldpi mdpi hdpi xhdpi xxhdpi 密度值 120 160 240 320 480 分辨率 240x320 320x480 480x800 720x1280 1080x1920 独立像素密度dp由于Android手机屏幕密度不同，因此，同样的像素点个数在不同屏幕上显示的长度也不同，因为高密度屏幕在同样的长度范围包含更多像素点。为了解决这个问题，Android系统使用dp（Device Independent Pixels，又称dip）表示屏幕长度，并规定在mdpi中，1dp = 1px，这样可以根据屏幕的密度值进行换算，得到每种屏幕密度对应的像素数目，例如，在xhdpi中，1dp = 320/160 * 1px = 2px。 单位转换根据上面的分析，可以手动对像素单位进行转换，不过更好的方式是使用系统的TypedValue类，代码如下所示： 123456789101112131415/** * dip to pixels */public static float dipToPixels(Context context, float dipValue) &#123; DisplayMetrics metrics = context.getResources().getDisplayMetrics(); return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dipValue, metrics);&#125;/** * sp to pixels */public static float spToPixels(Context context, float spValue) &#123; DisplayMetrics metrics = context.getResources().getDisplayMetrics(); return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, metrics);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现滑动的方法]]></title>
    <url>%2F2017%2F12%2F27%2F%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[了解滑动实现原理后，可以总结出实现滑动效果的基本思想：当View被触摸时，记录当前触摸点的坐标；当触摸点移动时，记录移动后触摸点的坐标；根据两次获取的坐标计算出触摸点的偏移量，通过偏移量修改View的坐标；不断重复，实现滑动效果。 接下来介绍实现滑动效果的一些方法。 layout方法在View进行绘制时，会调用onLayout()方法设置显示的位置，因此，可以通过修改View的left，top，right，bottom属性来控制View的坐标。具体在onTouchEvent()方法中实现，示例代码如下： 12345678910111213141516171819202122232425@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); return true; &#125; return super.onTouchEvent(event);&#125; 面的示例代码是通过getX()和getY()方法获取触摸事件的坐标值，下面以getRawX()和getRawY()方法来获取坐标值实现滑动效果： 1234567891011121314151617181920212223242526272829@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int rawX = (int) event.getRawX(); int rawY = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = rawX; lastY = rawY; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = rawX - lastX; int offsetY = rawY - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); // 重新设置初始坐标 lastX = rawX; lastY = rawY; return true; &#125; return super.onTouchEvent(event);&#125; 注意 使用绝对坐标系时，每次执行完ACTION_MOVE逻辑后，一定要重新设置初始坐标，这样才能准确获取连续移动时的偏移量。因为在相对坐标系中，ACTION_DOWN事件的坐标值对于View是不变的，而在绝对坐标系中，这个坐标值对于View是变化的。 offsetLeftAndRight和offsetTopAndBottom方法这两个方法只需要偏移量就可以完成View的重新绘制，达到layout方法同样的效果，示例代码如下： 12345678910111213141516171819202122232425@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 offsetLeftAndRight(offsetX); offsetTopAndBottom(offsetY); return true; &#125; return super.onTouchEvent(event);&#125; LayoutParamsLayoutParams保存了View的布局参数，可以通过改变LayoutParams来动态修改View的位置参数，实现View的滑动效果。具体示例代码如下： 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams(); layoutParams.leftMargin += offsetX; layoutParams.topMargin += offsetY; setLayoutParams(layoutParams); return true; &#125; return super.onTouchEvent(event);&#125; scrollTo与scrollBy方法View提供了scrollTo与scrollBy方法来改变View的位置，scrollTo(x, y)表示移动到坐标点(x, y)，scrollBy(dx, dy)表示移动的增量为dx、dy。 scrollTo与scrollBy方法的本质是移动View，从而使View中content产生相对移动。以下示意图以scrollBy方法为例进行说明： 从示意图可以看出，content移动的方向和ViewGroup移动的方向是相反的，所以，如果以子View的偏移量来移动ViewGroup来达到子View的滑动效果，那么，scrollBy中的偏移量要使用负值。 根据以上分析，使用scrollBy方法实现滑动效果的示例代码如下： 123456789101112131415161718192021222324@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 ((View) getParent()).scrollBy(-offsetX, -offsetY); return true; &#125; return super.onTouchEvent(event);&#125; 类似的，在绝对坐标系中，可以使用scrollTo方法实现同样的滑动效果。 Scroller在使用scrollTo与scrollBy方法移动时，View的移动都是瞬时完成的，为了产生平滑移动的效果，需要使用Scroller类。 Scroller的原理也是使用scrollTo与scrollBy方法来移动View，但是它会把移动的偏移量分为多个很小的偏移量，虽然在每个小的偏移量里面，移动是瞬时的，但是整体上会是一个平滑的移动效果。 使用Scroller类实现滑动效果需要以下几个步骤： 初始化Scroller 1mScroller = new Scroller(context); 重写computeScroll()方法，实现平滑移动 系统绘制View的时候会在draw()方法中调用computeScroll()方法，可以在computeScroll()中使用scrollTo()方法进行小的偏移量的移动，接着调用invalidate()方法触发draw()方法，形成一个循环过程，最终实现平滑移动。示例代码如下： 12345678910@Overridepublic void computeScroll() &#123; super.computeScroll(); // 判断Scroller是否执行完毕 if (mScroller.computeScrollOffset()) &#123; ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 通过重绘不断调用computeScroll()，达到平滑移动的效果 invalidate(); &#125;&#125; Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动过程，用时提供了getCurX()、getCurY()方法获取当前的滑动坐标。 执行startScroll()方法，执行滑动过程 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 执行滑动过程 View viewGroup = (View) getParent(); mScroller.startScroll(viewGroup.getScrollX(), viewGroup.getScrollY(), -offsetX, -offsetY, 0); // 通过重绘首次触发computeScroll() invalidate(); return true; &#125; return super.onTouchEvent(event);&#125; 通常使用getScrollX()和getScrollY()方法获取滑动的起始坐标，由于是父视图在滑动，因此，偏移值的正负情况与scrollTo、scrollBy方法相同。同时，需要注意调用invalidate()触发computeScroll()方法进行滑动过程。 ViewDragHelperAndroid的Support库中提供了DrawerLayout和SlidingPaneLayout方便实现侧滑菜单的效果，这两个布局就是通过ViewDragHelper类实现的。通过ViewDragHelper类，基本可以实现各种不同的Scroll、Drag需求。 ViewDragHelper功能比较强大，使用也相对比较复杂，具体使用可以搜索相关资料，这里就不详细介绍了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>滑动效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动实现原理]]></title>
    <url>%2F2017%2F12%2F26%2F%E6%BB%91%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[滑动的产生View的滑动，本质上是移动View，即改变View所处的位置，这点和动画效果类似，都是通过不断改变View的坐标来实现的。 因此，要产生滑动效果，需要监听用户的触摸事件，根据事件的坐标信息不断改变View的坐标，使View跟随用户的触摸进行移动。 滑动是相对的移动，要实现滑动，就必须了解Android系统中的坐标体系和触摸事件(MotionEvent)，接下来对坐标体系和触摸事件进行说明。 系统坐标系Android系统的坐标系如下图所示： 系统提供了getLocationOnScreen()方法获取View在系统坐标系的位置，即该View左上角在系统坐标系的位置。 触摸事件中触摸点的系统坐标使用getRawX()和getRawY()方法获取。 视图坐标系除了系统坐标系，Android中还有视图坐标系，它用来描述子View在父View中的位置，系统坐标系如下图所示： 触摸事件中触摸点的视图坐标使用getX()和getY()方法获取。 触摸事件与坐标系触摸事件MotionEvent中封装了常用的事件常量，这些常量定义了不同的类型的触摸事件，可以使用getAction()方法获取。 下面用一幅图来描述一些获取坐标值和相对距离的常用API：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>滑动效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件拦截机制]]></title>
    <url>%2F2017%2F12%2F21%2F%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在对控件进行测量、布局、绘制一系列工作后，想要让控件与用户进行交互，就需要涉及到Android的事件拦截机制。Android系统提供了一套完善的事件分发、拦截、处理机制，让控件能够对用户输入的事件进行准确的响应和处理。 触摸事件Android中使用MotionEvent类代表一个触摸事件，比如用户的点击、滑动事件，从MotionEvent类中，可以获取事件的类型、点击坐标等一系列信息。 事件拦截机制分析在描述事件拦截机制前，要明确Android的视图是树结构。树结构具有层次，一个事件会从顶层逐步向低层进行分发。如果处于上层的ViewGroup要对事件进行处理，首先要对事件进行拦截，然后再进行处理；如果不进行处理，那么需要把事件分发到底层的View或者ViewGroup。如果底层的View处理了事件，那么这个事件的生命周期就结束了，否则，这个事件还要沿着原路向上层传递。这时，上层ViewGroup可以选择对事件进行处理，或者继续向上层传递，直到事件被处理为止。 以上分析可以用下面的流程图来表示： 事件处理的关键方法当控件想要分发一个事件时，会调用dispatchTouchEvent()方法。如果返回true，表示控件完成了这个事件的分发工作；如果返回false，表示事件分发工作未完成，事件将交由上层控件处理。 当控件想要拦截一个事件时，会调用onInterceptTouchEvent()方法。只有ViewGroup才拥有该方法，因为父控件只能是ViewGroup。当父控件要对分发到子控件的事件进行处理时，就需要调用此方法，如果返回true，表示父控件拦截了这个事件；如果返回false，父控件不对事件进行拦截，将把事件分发到子控件。 当控件想要处理一个事件时，会调用onTouchEvent()方法。在这个方法中，可以根据MotionEvent类提供的信息做相应的操作。操作完毕后，如果返回true，表示事件被处理了，该事件就结束了；如果返回false，表示事件没有被处理，事件将交由上层控件，直到被处理为止。 下面使用时序图描述一个事件处理的实例：父控件将事件分发给控件，控件接着将事件分发给子控件，然而子控件没有处理事件，把事件返还给了控件，最后控件自己处理了这个事件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View和ViewGroup]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%92%8CViewGroup%2F</url>
    <content type="text"><![CDATA[自定义View在自定义View时，通常需要重写onDraw()方法绘制View的显示内容；如果需要使用wrap_content属性，还需要重写onMeasure()方法进行测量；另外，还可以在attrs.xml文件中为View自定义属性。 在View中通常用到的回调方法有： onFinishInflate()从XML文件中加载控件后调用； onSizeChanged()控件大小改变时调用； onMeasure()测量控件大小时调用 onLayout()确定控件显示位置时调用 onDraw()绘制控件时调用； onTouchEvent()监听触摸事件时调用； 在自定义View的时候，只需要重写特点条件的回调方法。 通常情况下，自定义View有三种方式：对现有View进行扩展、创建复合View、自定义新的View。 对现有View进行扩展这种方式是在原生View的基础上进行扩展，比如修改显示的效果、增加新的功能等。 通常可以在onDraw()方法中，对原生View进行扩展。 创建复合View这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，从而组合成新的复合View。 对于复合View，一般会给它指定一些自定义属性，让其具有更强的扩展性。 自定义新的View当原生View无法满足需求时，可以通过继承View，自定义一个新的View。 自定义新的View，最重要的是绘制View和实现交互。绘制逻辑需要重写onDraw()和onMeasure()方法，交互逻辑需要重写onTouchEvent()等控制触控事件的方法。还可以像实现复合View那样，为新的View配置自定义属性，丰富自定义View的可定制性。 自定义ViewGroupViewGroup用于管理一组子View，将子View放到合适的位置，并为其添加响应事件。 自定义ViewGroup通常需要重写onMeasure()方法对子View进行测量，重写onLayout()方法确定子View的位置，重写onTouchEvent()方法为子View设置响应事件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件的测量和绘制]]></title>
    <url>%2F2017%2F12%2F20%2F%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%B5%8B%E9%87%8F%E5%92%8C%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[View的测量Android系统在绘制View前，要对View进行测量，告诉系统View的大小，这个过程是在View的onMeasure()方法中进行的。 具体测量View是通过MeasureSpec类，测量模式有一下三种： EXACTLY当控件的layout_width和layout_height属性为具体数值，或者被指定为match_parent时，使用的就是该模式； AT_MOST当控件的layout_width和layout_height属性被指定为wrap_content时使用，这时控件的大小会随着子控件的大小变化，同时控件的尺寸不允许超过父控件的最大尺寸； UNSPECIFIED在这个模式下，View大小可以随意指定，通常在绘制自定义View的时候使用； MeasureSpec类除了指定View的测量模式外，还指定了对应测量模式下View的尺寸。 MeasureSpec是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小，为了提高运算效率，具体获取模式和大小的时候使用位运算。 View的默认onMeasure()方法只支持EXACTLY模式，如果想让View支持wrap_content属性，需要重写onMeasure()方法，指定AT_MOST模式下View的大小。 View的绘制View测量完毕后，需要重写onDraw()方法，在其Canvas对象上使用Paint对象绘制所需的图形。可以把Canvas对象看作成一块画板，Paint对象看作画笔，然后在onDraw()方法中进行绘制操作。 调用Canvas的drawXXX()方法绘制图形、文字、图片等，对于复杂的控件，可以把其拆分为一个个小的图形单元分别绘制。 ViewGroup的测量和布局ViewGroup在测量时，会遍历所有的子View，调用子View的measure()方法获取每个子View的测量结果，这时子View会调用onMeasure()方法进行测量。 当子View测量完毕后，还需要把子View放到合适的位置，这个过程就是View的布局过程。ViewGroup在执行布局过程时，同样会遍历调用子View的layout()方法，然后子View调用onLayout()方法进行具体的布局过程。 在自定义ViewGroup时，通常需要重写onLayout()方法来控制其子View的显示位置。类似于View，如果需要支持wrap_content属性，也需要重写onMeasure()方法。 ViewGroup的绘制ViewGroup通常不需要绘制，因为其本身没有需要绘制的内容，如果不指定背景颜色，ViewGroup的onDraw()方法都不会被调用。但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，这个过程也会遍历所有的子View，并调用子View的draw()方法完成绘制工作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件架构]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[控件树Android中的控件可以分为View控件和ViewGroup控件两类，一个ViewGroup控件可以包含多个View控件，这样就形式了一棵控件树： 控件树中的上层父控件负责下层子控件的测量和绘制，并且传递交互事件给子控件。 每个子控件都包含一个指向父控件的ViewParent对象，ViewParent对象专门负责管理与父控件的交互事件，从而对整个视图进行控制。 Activity中的findViewById()方法就是在控件树中，以DFS来查找对应的控件的。 界面架构每个Activity都包含一个Window对象，具体由PhoneWindow实现，PhoneWindow将DecorView设置为Window的顶层View。 DecorView将屏幕分为：StatusBar、DecorContent、NavigationBar三部分，DecorContent又包含ActionBar和ContentView两部分。 Activity就是通过setContentView()方法将布局内容加载到ContentView中的。 从界面架构图可以看出，ActionBar和ContentView都是在DecorView中进行绘制的，如果使用requestWindowFeature()方法设置全屏显示，那么需要在setContentView()方法调用之前进行。 视图树通过AS的Layout Inspector工具，可以直观的看到一棵标准的视图树： 视图树中的结构和上面描述的界面架构基本上能够对应上，只是多了一个action_mode_bar_stub，这个ViewStub对象主要用于绘制ActionMode状态下的ActionBar区域。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在网上浏览技术文章的时候，经常看到有人把文章发布到自己的个人博客上，感觉挺高端的，在查阅了相关资料后，也搭建了自己的个人博客，这篇文章就是我搭建个人博客的总结。 注意 本文主要是针对Windows环境，在Mac环境除了软件安装方式和命令有所区别外，其它基本一样。 创建域名和空间创建GitHub域名博客是托管在GitHub上的，首先要注册GitHub账号，注册的时候注意username，因为GitHub域名将是username.github.io，注册完毕后，GitHub域名也就创建了。 创建Blog存储空间Blog本质是一个网站，那么需要一个空间去存储网站的内容，这里使用GitHub的仓库(Repository)存储网站的内容，所以，需要在GitHub上创建一个仓库，Repository name就用上一步创建的域名：username.github.io，仓库创建完毕后，Blog存储空间也就创建了。 安装必要的工具Hexo是目前比较流行的博客框架，基于Node.js，可以使用 Markdown解析文章。要使用Hexo，需要安装Git，Node.js，Hexo工具。 安装GitGit用于把Hexo生成的本地网站内容提交到GitHub上，可以去Git官网下载安装程序进行安装，安装完毕后，需要在GitHub上配置SSH keys，具体配置方式可以参考Connecting to GitHub with SSH。 安装Node.jsNode.js是Hexo的运行环境，可以去Node.js官网下载安装程序进行安装，安装过程中，注意勾选Add to PATH选项。 安装Hexo在Git和Node.js安装完毕后，可在Git Bash中使用npm安装Hexo，由于Hexo的很多操作都涉及到命令行，可以考虑始终使用Git Bash来进行操作。 1$ npm install -g hexo-cli 创建网站和配置Hexo安装完毕后，接下来利用Hexo创建一个网站，并进行一些基本的配置。 创建网站执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 基本配置配置信息在网站的_config.yml文件中，可以根据需要进行配置，记得保存，注意配置的键值之间一定要有空格。 网站配置 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言 timezone 网站时区 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。下面附上我自己的配置，以供参考： 1234567# Sitetitle: Zhou Zejin&apos;s Homesubtitle: 想象力比知识更重要！description: Sunny的个人Blog，主要记录Android学习总结，欢迎交流~author: Zhou Zejinlanguage: zh-Hanstimezone: 其它配置可以参考更多配置。 部署配置这里只讲述Git的部署配置，其它方式的部署配置参考部署配置。 参数 描述 repo 库(Repository)地址 branch 分支名称 message 自定义提交信息 下面是我的部署配置： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:zhouzejin/zhouzejin.github.io.git 工作流程网站创建和配置完毕后，接着就可以撰写博客，并进行发布了。 新建1$ hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用_config.yml中的 default_layout 参数代替。如果标题包含空格，要使用引号括起来。 创建的文章在username.github.io/source/_posts目录下，默认是Markdown文件，在具体撰写博客前，可以学习一下Markdown语法。 测试1$ hexo server 启动本地服务器。默认情况下，访问网址为： http://localhost:4000/ 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 注意 上述方式如果无法启动Server，很大可能是默认端口4000被占用，可以更换其它端口重新启动 1$ hexo server -p 5000 服务器启动后，就可以浏览文章的排版和效果，如果不满意，可以直接修改文章对应的Markdown文件，修改完毕后，直接刷新就可以看到修改后的效果，不必重启Server。 发布使用Git发布需要先安装hexo-deployer-git插件（更多插件使用可以参考Hexo插件）： 1$ npm install hexo-deployer-git --save 发布前先要生成网站的静态文件： 1$ hexo generate 生成完毕后就可以进行发布： 1$ hexo deploy 生成和发布操作可以使用一个命令完成： 1$ hexo d -g 发布成功后，在浏览器输入username.github.io就可以进行访问了。 注意 在某些情况（尤其是更换主题后），如果发现对网站的更改无论如何也不生效，可以使用clean命令清除缓存文件(db.json)和已生成的静态文件(public)，然后再进行发布。 1$ hexo clean Hexo的更多使用可以参考Hexo官网文档 自定义主题经过以上步骤，个人博客就搭建完毕了，但是为让自己的博客更美观，可以更换默认主题，这里使用现在比较流行的NexT主题，如果需要使用其它主题，可以参考Hexo主题。 下面只对我自己用到的主题配置和第三方服务进行总结，更多配置和服务可以参考NexT使用文档。 主题安装下载主题在终端窗口下，定位到Hexo站点目录下。使用Git checkout代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在网站的_config.yml文件中，找到theme字段，并将其值更改为next： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题配置如果没有特殊说明，主题的配置都是在主题的_config.yml文件中进行的。 菜单配置每个菜单项目的配置都是类似的，接下来以配置about菜单进行说明： 在终端窗口下，定位到Hexo站点目录，创建一个名为about的页面 1hexo new page "about" 编辑分类页, 设置页面类型为about 123title: 关于date: 2017-11-24 16:00:52type: "about" 添加about到主题配置文件中menu字段下 123456789menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 配置完categories和tags菜单后，可以参考Hexo的Front-matter文档为文章添加分类和标签。 侧边栏配置 在移动设备上显示侧边栏 12# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true 设置头像 将头像放在网站目录下的source/uploads/路径，若uploads目录不存在则新建，然后在主题配置文件中进行如下配置： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/Sanji.jpg 添加社交链接 在主题配置文件下的social字段下，添加相应的社交链接即可： 12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 RSS配置安装hexo-generator-feed插件 1$ npm install hexo-generator-feed --save 安装成功后，就可以在侧边栏看到RSS订阅的标识了。 开启打赏功能只需要主题配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 网站footer个性化显示如果想自定义网站底部的信息，可以在主题配置文件进行如下配置： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false 设置「阅读全文」在主题配置文件中添加： 123auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定。 第三方服务可以为主题添加一些第三方服务来丰富网站的功能。 内容分享服务编辑主题配置文件，添加字段jiathis，值为true： 12# JiaThis 分享服务jiathis: true 搜索服务 安装hexo-generator-searchdb插件 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能 123# Local searchlocal_search: enable: true 参考资料 5分钟 搭建免费个人博客Hexo官方文档NexT使用文档]]></content>
      <categories>
        <category>方法和经验</category>
      </categories>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
</search>
