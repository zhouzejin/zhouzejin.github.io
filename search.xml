<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android中的线程使用]]></title>
    <url>%2F2018%2F02%2F07%2FAndroid%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Android开发中，通常会将耗时的任务放到子线程中执行，以保证UI线程的流畅性。不过，系统要开启一个线程会消耗一定的资源，并且，对于多线程还有额外的工作要处理，比如：线程安全、死锁、内存消耗、对象生命周期管理等。因此，在开发过程中，如果随意开启线程，不但会加重开发任务，还会过多消耗系统资源，达不到令UI线程流畅的效果。 进程优先级线程是进程的一部分，因此，线程的生命周期直接被进程所影响，而进程的的存活又与其优先级直接相关，所以，在使用线程的时候，通常需要关注进程的优先级。 通常来说，Android系统会系统资源不足的情况下，根据进程优先级杀死进程，优先级越低的进程越容易被杀死。Android系统进程优先级由高到底排列如下： 前台进程（Foreground Process）：表明用户正在与该进程进行交互操作。 1.进程持有一个正在与用户交互的Activity（Activity处于Resumed状态）。2.进程持有一个Service，并且这个Service与一个用户正在交互的Activity进行绑定。3.进程持有一个前台运行模式的Service（Service调用了startForegroud()方法）。4.进程持有一个正在执行生命周期方法的Service（Service正在执行onCreate()、onDestroy()等方法）。5.进程持有一个正在执行onReceive()方法的BroadcastReceiver。 可见进程（Visible Process）：表明虽然该进程没有持有任何前台组件，但是它能够影响用户可见的界面。 1.进程持有一个非前台Activity，但这个Activity对用户可见（Activity处于Paused状态）。2.进程持有一个与可见Activity绑定的Service。 服务进程（Service Process）：除了符合前台进程和可见进程条件的Service，其它的Service都会被归类为服务进程。 后台进程（Background Process）：持有不可见Activity（Activity处于Stopped状态）的进程。 通常情况下会有很多后台进程，当内存不足的时候，在所有的后台进程里面，会按照LRU（最近使用）规则，优先回收最长时间没有使用过的进程。 空进程（Empty Process）：不持有任何活动组件的进程（Activity处于Destroyed状态）。 保持这种进程只有一个目的，就是为了缓存，以便下一次启动该进程中的组件时能够更快响应。当资源紧张的时候，系统会平衡进程缓存和底层的内核缓存情况进行回收。 线程调度线程优先级进程的优先级与系统回收资源有关，而线程的优先级与线程调度有关，一般来说，优先级越高的线程能获取到更多的CPU时间片去执行。 但是，在Linux系统中，调度器在分配时间片时，采用的CFS(completely fair scheduler)策略，这种策略不但会参考单个线程的优先级，还会追踪每个线程已经获取到的时间片数量，如果高优先级的线程已经执行了很长时间，但低优先级的线程一直在等待，后续系统会保证低优先级的线程也能获取更多的CPU时间。显然使用这种调度策略的话，优先级高的线程并不一定能在争取时间片上有绝对的优势，所以，Android系统在线程调度上使用了cgroups的概念，cgroups能更好的凸显某些线程的重要性，使得优先级更高的线程明确的获取到更多的时间片。 Android中的线程调度Android系统将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的时间片，剩下的全部分配给default group，这样设计能保证UI线程的流畅性。 在开启线程时，可以手动将线程归于background group，这样可以保证UI线程的流程性： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); &#125;&#125;).start(); 因此，在开启新线程时，需要考虑这个线程是否需要和UI线程争夺CPU资源：如果不是，降低线程优先级将其归于background group；如果是，则需要进一步的profile看这个线程是否造成UI线程的卡顿。 虽然，Android系统在任务调度上是以线程为基础单位，设置单个Thread的优先级可以改变其所属的control groups，从而影响CPU时间片的分配，但是，进程的状态的变化也会影响到线程的调度。当一个App进入后台的时候，该App所属的整个进程都将归于background group，以确保处于前台的可见进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。 1$ adb shell ps -P 当App重新被用户切换到前台的时候，进程当中所属的线程又会回归到原来的group。在用户频繁切换的过程当中，Thread的优先级并不会发生变化，但系统在时间片的分配上却在不停的调整。 Android中的线程形态在Android中，不同应用场景需要使用不同形态的线程，接下来介绍各种形态的线程的使用方式。 Thread 优点 使用最简单，适用于一些单一的只需要执行耗时任务的场景。 缺点 1.仅仅启动了一个新线程，没有任务的概念，不能做状态管理，任何开始后，会一直执行完毕后才结束，无法中途取消。2.如果Runnable匿名内部类持有了外部类的引用，在线程结束前，该引用会一直存在，这样可能会阻碍外部类对象被GC回收，造成内存泄露。3.没有通信接口，如果要与UI进行交互，需要手动实现消息机制。 使用方式 直接创建线程对象开启线程，代码如下所示： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;).start(); 如果从UI线程启动，则该线程优先级默认为Default，归于default group，会平等的和UI线程争夺CPU资源。因此，在对UI性能要求高的场景下需要手动将其优先级设为Background： 1Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); AsyncTask 优点 1.将线程以任务的方式执行，可以管理任务的状态，比如，可以获取任务执行进度，以及终止任务执行。2.内部封装了Handler，可以与UI线程直接交互。3.开启的进程默认被设置为Background优先级，对UI线程的执行影响极小。4.默认会在一个串行的线程池中执行任务，可以重复使用线程资源，避免了频繁开启和关闭线程带来的资源消耗。 缺点 1.只能对任务做粗略地控制。2.只能与UI线程进行交互。3.类似于直接开启Thread，也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。 使用方式 通过继承AsyncTask重写相应的方法： 123456789101112131415161718192021public static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Void doInBackground(Void... voids) &#123; return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; super.onPostExecute(aVoid); &#125; @Override protected void onProgressUpdate(Void... values) &#123; super.onProgressUpdate(values); &#125;&#125; 上面重写了使用AsyncTask常用的4个方法： onPreExecute()：在主线程中执行，异步任务执行之前调用，可以做一些准备工作； doInBackground()：在线程池中执行，并且线程的优先级会被设置设为Background； onPostExecute()：在主线程中执行，异步任务执行完毕后调用，可以获取任务执行完毕的返回值； onProgressUpdate()：在主线程中执行，用于获取任务执行的进度； 因为AsyncTask在内部使用了Handler（消息机制）与主进程交互， 所以异步任务定义完毕后，必须要在主线程中开启任务。开启任务的方式如下所示： 1new MyAsyncTask().execute(); 注意事项 1.可以调用cancel()终止任务，不过，调用方法后，任务并不一定会被终止，要看方法的返回值来确定任务是否被终止。2.Android3.0以后，为了避免并发错误，如果有多个AsyncTask任务，默认会在一个串行的线程池中执行这些任务，只有当一个任务执行完毕后才会去执行下一个任务；不过，也可以调用其executeOnExecutor()方法在并行的线程池中执行任务，但是，并行执行任务时需要处理线程安全的问题。3.AsyncTask默认串行执行所有任务，最好不要创建了大量的AsyncTask任务，或者在AsyncTask任务中执行特别耗时的任务，这样会影响其它任务的执行。4.不要直接调用onPreExecute()、doInBackground()、onPostExecute()和onProgressUpdate()方法。5.一个MyAsyncTask对象只能执行一次，即只能调用一次execute()方法，否则会运行时异常。 HandlerThread 优点 1.可以对任务做比较精细的控制，适用于线程切换比较频繁的场景。2.在Thread中封装了消息机制，其它线程都可以通过Handler与其进行交互。3.类似于AsyncTask，串行执行多个任务，不存在线程安全的问题。4.每个HandlerThread都有自己的消息队列，在一个HandlerThread中执行多个任务或比较耗时的任务，不会影响其它HandlerThread，这点与AsyncTask不同。 缺点 使用起来比AsyncTask复杂，需要编写更多代码。 使用方式 以下是使用HandlerThread的示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyHandlerThread&lt;Token&gt; extends HandlerThread &#123; private static final String TAG = "MyHandlerThread"; private static final int MESSAGE_DOWNLOAD = 0; private Handler mHandler; private Handler mResponseHandler; private Listener&lt;Token&gt; mListener; public interface Listener&lt;Token&gt; &#123; void onRequestHandled(Token token); &#125; public void setListener(Listener&lt;Token&gt; listener) &#123; mListener = listener; &#125; public MyHandlerThread(Handler responseHandler) &#123; super(TAG); mResponseHandler = responseHandler; &#125; /** * HandlerThread.onLooperPrepared()方法的调用发生在Looper.loop()方法之前， * 因此，在该方法中创建Handler，并执行相关任务。 */ @SuppressLint("HandlerLeak") @Override protected void onLooperPrepared() &#123; mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == MESSAGE_DOWNLOAD) &#123; Log.i(TAG, "Got a Message"); @SuppressWarnings("unchecked") Token token = (Token) msg.obj; handleRequest(token); &#125; &#125; &#125;; &#125; /** * 其它线程给该线程发送消息的接口。 */ public void sendRequest(Token token) &#123; Log.i(TAG, "Got a Request"); mHandler.obtainMessage(MESSAGE_DOWNLOAD, token).sendToTarget(); &#125; /** * 处理其它线程发送的消息。 */ private void handleRequest(final Token token) &#123; Log.i(TAG, "Handle Request"); // 因为mResponseHandler与主线程的Looper关联，所以UI更新代码是在主线程中完成的。 mResponseHandler.post(new Runnable() &#123; @Override public void run() &#123; // 回调更新UI mListener.onRequestHandled(token); &#125; &#125;); &#125; /** * 如果需要更新的View已经销毁，清空消息队列。 */ public void clearQueue() &#123; mHandler.removeMessages(MESSAGE_DOWNLOAD); &#125;&#125; 注意事项 1.HandlerThread默认被设置为Default优先级。2.HandlerThread使用了消息机制，会一直循环处理消息，不会自动停止，如果不再使用HandlerThread时，可以通过quit()或则quitSafely()方法来终止线程的执行，避免资源消耗。 IntentService 优点 1.在Service组件中封装了HandlerThread，优先级（所属进程的优先级）比一般后台线程要高，不容易被系统杀死，可以用来执行优先级比较高的后台任务。2.类似于HandlerThread，如果IntentService被开启了多次，会串行执行这些任务，不过，所有任务都执行完毕后，IntentService会自动停止。 使用方式 以下是使用IntentService的示例代码： 123456789101112131415161718192021public class MyIntentService extends IntentService &#123; private static final String TAG = "MyIntentService"; public MyIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; // 处理任务 Log.i(TAG, "Handle Task."); &#125; @Override public void onDestroy() &#123; Log.i(TAG, "Service Destroyed."); super.onDestroy(); &#125;&#125; 注意事项 停止IntentService一般使用stopSelfResult(int startId)和stopSelf()方法。其中stopSelfResult(int startId)相对比较安全，如果还有其它任务还未执行，那么会等待其它任务执行完毕后才停止服务；而stopSelf()直接停止当前服务，不管是否还有任务需要执行。 Android中的线程池前面介绍线程的形态时，如果有多个线程，一般都是串行执行的。串行执行虽然没有线程同步的问题，但是，如果有大量的耗时任务需要执行，串行执行不是一个好的选择，这时，就需要并发的执行多个线程。在Android中，如果要并发执行线程，需要用的线程池，一般来说，线程池有以下优点： 重用线程池中的线程，避免了频繁创建和销毁线程带来的性能开销。 能够控制线程的最大并发数，避免了大量线程因相互抢占系统资源而导致的阻塞现象。 能对线程进行简单的管理，还能提供定制执行、或者间隔循环执行线程等功能。 不过，要特别注意处理线程安全的问题，因为多线程并发运行导致的Bug往往是偶现的，不方便调试。 ThreadPoolExecutorAndroid中的线程池来源于JDK，使用Executor表示一个线程池，它是一个接口，线程池的实现类是ThreadPoolExecutor。这个实现类提供了一系列参数来配置线程池，下面是ThreadPoolExecutor的构造方法： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize线程池的核心线程数。默认情况下，核心线程会在线程池中一直存活，即使处于闲置状态。如果将线程池的allowsCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间由keepAliveTime决定，如果超时，核心线程也会被终止。 maximumPoolSize线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。 keepAliveTime非核心线程闲置的超时时间，如果超过这个时间，非核心线程就会被回收。如果将线程池的allowsCoreThreadTimeOut属性设置为true，这个超时也会作用于核心线程。 unit用于指定keepAliveTime的时间单位，是一个枚举量。 workQueue线程池中的任务队列，通过线程池的execute()方法提交的Runnable对象会被存储在这个队列中。 threadFactory线程工厂，为线程池提供创建新线程的能够。它是一个接口，只有Thread newThread(Runnable r)一个方法。 RejectedExecutionHandler这个参数不常用。当线程池无法执行新任务时（可能是任务队列已满，或者无法成功执行任务），线程池会调用参数的rejectedExecution()方法通知调用者，默认抛出RejectedExecutionException。 ThreadPoolExecutor执行任务一般遵循以下规则： 如果线程池中的线程数量未达到核心线程的数量，直接启动一个核心线程来执行任务。 如果线程池中的线程数量已经到达或超过核心线程的数量，那么任务会被插到任务队列中等待执行。 如果步骤2中的任务队列已满，但是线程数量没有达到线程池能容纳的最大线程数，那么会立刻启动一个非核心线程来执行任务。 如果步骤3中线程数量已达到线程池能容纳的最大线程数，那么拒绝执行此任务，调用rejectedExecution()方法通知调用者。 常用的线程池如果直接使用ThreadPoolExecutor创建一个线程池会比较繁琐，可以使用Executors工厂类直接创建要使用的线程池实例，去实现特定功能的线程池。接下来介绍Android中常用的几种线程池。 FixedThreadPool 通过Executors创建FixedThreadPool的源代码如下所示： 123456789public class Executors &#123;... public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125;...&#125; 它是一种线程数量固定的线程池，当其中的线程处于空闲状态时，也不会被回收，除非线程池被关闭。 由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，所以，它能够快速响应外界的请求。 CachedThreadPool 通过Executors创建CachedThreadPool的源代码如下所示： 123456789public class Executors &#123;... public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;...&#125; 它是一种线程数量不确定的线程池，并且只有非核心线程。当线程池中所有的线程都处于活动状态时，就立刻创建新线程处理新任务，否则，就会使用闲置的线程来处理新任务。如果某个线程空闲时间超过60s，这个闲置线程会被回收。因此，该线程池的任务队列相当于是一个空集合。 从CachedThreadPool的特性来看，它比较适合执行大量的、耗时较少的任务。 ScheduledThreadPool 通过Executors创建ScheduledThreadPool的源代码如下所示： 1234567public class Executors &#123;... public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;...&#125; 1234567891011public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;... public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125;...&#125; 它的核心线程数量是固定的，而非核心线程数量没有限制。当非核心线程闲置时，会被回收。 ScheduledThreadPool主要用于执行定时任务，或者具有固定周期的重复任务。 SingleThreadExecutor 通过Executors创建SingleThreadExecutor的源代码如下所示： 12345678910public class Executors &#123;... public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;...&#125; 它的线程池内只有一个核心线程，能确保所有的任务都在同一个线程中按顺序执行。 SingleThreadExecutor用于串行执行所有的任务，让这些任务之间不用考虑线程同步的问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制]]></title>
    <url>%2F2018%2F02%2F05%2FAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在Android系统中，主要有两种通信机制：Binder机制和消息机制。Binder机制用于跨进程通信，消息机制用于进程内部通信，也就是同一个进程中内部线程之间的通信。 消息机制概述通常在工作线程中做完一些操作后需要更新UI，但是，UI控件不是线程安全的，不能直接在工作线程中更新UI。这时，工作线程需要通过UI线程的Handler对象向UI线程发送消息，通知UI线程去更新UI。这个过程的实质就是线程之间通过消息机制进行通信。 Android消息机制主要通过Handler实现，而Handler的运行需要MessageQueue和Looper配合。 MessageQueue是一个消息队列，采用链式队列的数据结构实现，用来存储Handler发送的消息。 Looper可以理解为消息循环，每个要处理消息的线程都拥有一个属于自己的Looper，这个Looper会以无限循环的方式查询MessageQueue，如果有消息，就通过消息对应的Handler对象处理消息，否则，就一直等待。 Handler有两个作用：一方面可以让其它线程通过Handler给拥有这个Handler对象的线程发送消息；另一方面可以在线程的Looper获取消息后，通过Handler处理这个消息。 需要注意的是，线程默认是没有Looper的，如果要使用Handler，必须先为线程创建一个Looper，并且，一个线程只能有一个Looper。不过，一个线程可以拥有多个Handler对象，这个并不影响Looper处理消息，因为不管是哪个Handler发送过来的消息，都一并存在MessageQueue，Looper只会串行获取这些消息进行处理。 MessageQueue分析MessageQueue是一个链式队列，当消息过来时，会将消息对象Message插入到队列中；当要处理消息时，会读取队列中的消息，并删除已读取的消息。 MessageQueue通过enqueueMessage()方法插入消息，其源码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * frameworks/base/core/java/android/os/MessageQueue.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public final class MessageQueue &#123; ... boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; ... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 消息队列为空，插入的消息处于队首，如果消息队列被阻塞，需要将其唤醒。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 在消息队列的中间位置插入消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; ... &#125; return true; &#125; ...&#125; MessageQueue通过next()方法读取并删除消息，其源码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * frameworks/base/core/java/android/os/MessageQueue.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public final class MessageQueue &#123; ... Message next() &#123; ... int nextPollTimeoutMillis = 0; for (;;) &#123; // 无线循环。 ... synchronized (this) &#123; // 检索下一个Message，如果存在就返回这个Message。 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 如果队列中没有消息，进行阻塞，直到获取到下一个消息。 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个消息没有准备好，为其设置一个唤醒时间。 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取到下一个消息。 mBlocked = false; // 删除当前获取的消息。 if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // 没有更多消息了。 nextPollTimeoutMillis = -1; &#125; ... &#125; &#125; ...&#125; Looper分析Looper在消息机制中实现消息循环，具体来说，它会不停地从MessageQueue中查看是否有新消息，如果有就进行处理，没有就一直循环等待。 一个线程默认是没有Looper的，要让一个普通线程升级为Looper线程需要做一下操作： 12345678910111213public class LooperThread extends Thread &#123; @Override public void run() &#123; // 将当前线程初始化为Looper线程。 Looper.prepare(); // 其他处理，如实例化handler。 ... // 开始循环处理消息队列。 Looper.loop(); &#125;&#125; 这个过程并没有涉及到MessageQueue，这是因为Looper将MessageQueue进行了封装，开发者不需要直接与MessageQueue交互，这点可以从Looper的构造函数中看出来： 123456789101112131415/** * frameworks/base/core/java/android/os/Looper.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public final class Looper &#123; ... private Looper(boolean quitAllowed) &#123; // Looper内的消息队列。 mQueue = new MessageQueue(quitAllowed); // 当前线程。 mThread = Thread.currentThread(); &#125; ...&#125; Looper.prepare()prepare()方法用来为线程添加Looper对象，并且一个Thread只能有一个Looper对象，具体可以看其源码： 1234567891011121314151617181920212223/** * frameworks/base/core/java/android/os/Looper.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public final class Looper &#123; ... // sThreadLocal.get()会返回null除非调用了prepare()方法。 static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); ... public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; // 试图在有Looper的线程中再次创建Looper将抛出异常。 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; ...&#125; 可以看出，prepare()方法是通过ThreadLocal保证了每个线程只能有一个Looper对象。这里简单介绍下ThreadLocal的使用原理。 ThreadLocal的使用原理 ThreadLocal是一个创建线程局部变量的类。通常情况下，创建的变量是可以被任何一个线程访问并修改的，而使用ThreadLocal创建的变量，每个线程访问时都会获取其一个副本，这个副本只能在当前线程访问，其他线程无法访问和修改。ThreadLocal从本质上讲，是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。 注意 除了prepare()方法，Looper还提供了prepareMainLooper()方法专门为主线程（ActivityThread，也即UI线程）提供Looper对象，其本质也是通过prepare()方法创建Looper对象。不过，由于主线程的Looper对象比较特殊，Looper提供了一个getMainLooper()方法，通过这个方法可以在其它线程也能获取到主线程的Looper对象，所以，主线程的Looper对象不是ThreadLocal类型的。另外，Android系统在创建主线程的时候就已经为其初始化了Looper对象，所以，一般不需要另外调用prepareMainLooper()方法。 Looper.loop()loop()方法用来开启消息循环，只有调用了这个方法，Looper线程才能开始工作，其源码如下所示： 123456789101112131415161718192021222324252627282930313233/** * frameworks/base/core/java/android/os/Looper.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public final class Looper &#123; ... public static void loop() &#123; final Looper me = myLooper(); // 得到当前线程Looper。 if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // 得到当前Looper的MessageQueue。 ... for (;;) &#123; // 开启无线循环。 Message msg = queue.next(); // 获取Message，可能会被阻塞。 if (msg == null) &#123; // 没有消息需要处理，退出无线循环。 return; &#125; ... try &#123; // msg.target即发送这个消息的Handler对象，用这个Handler对象来处理消息。 msg.target.dispatchMessage(msg); &#125; finally &#123; ... &#125; ... msg.recycleUnchecked(); // 回收消息资源。 &#125; &#125; ...&#125; 可以看出，loop()方法是一个无线循环，不断从MessageQueue中获取消息并进行处理，唯一跳出循环的方式MessageQueue的next()方法返回了null。 loop()方法使用了myLooper()方法，其源码如下： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 由于ThreadLocal的原因，在任意线程调用Looper.myLooper()方法返回的都是当前线程的Looper对象。 退出消息循环消息循环是可以退出的，Looper提供了quit()和quitSafely()方法来退出消息循环，这两个方法的区别是：quit()方法会直接退出消息循环；而quitSafely()方法只是设定了一个退出标记，只有当把消息队列中已有的消息处理完毕后才退出消息循环，这种方式比较安全。 如果在一个线程中创建Looper开启了消息循环，那么在任务完成后，需要主动退出消息循环，否则，该线程会一直处于等待状态，不会被终止。 Handler分析Handler用来向Looper的消息队列发送消息，在Looper获取这个消息后，会调用该Handler处理这个消息，这个过程是异步的。 创建Handler由于Handler需要向Looper的消息队列发送消息，所以，在初始化Handler时，需要关联一个Looper对象。但是，在一个线程中，通常直接使用Handler的无参构造函数去创建Handler对象，并没有直接让Handler对象与Looper对象关联。其实，关联是在这个构造函数中实现的，具体可以看其源码： 123456789101112131415161718192021222324252627282930/** * frameworks/base/core/java/android/os/Handler.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public class Handler &#123; ... final Looper mLooper; // 关联的Looper。 final MessageQueue mQueue; // 关联的MessageQueue。 final Callback mCallback; final boolean mAsynchronous; ... public Handler() &#123; this(null, false); &#125; ... public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); // 默认将关联当前线程的Looper。 if (mLooper == null) &#123; // Looper不能为空，即该默认的构造方法只能在拥有Looper的线程中使用。 throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; ...&#125; 所以，可以通过以下代码为在Looper线程中创建Handler对象： 1234567891011121314151617public class LooperThread extends Thread &#123; private Handler handler1; private Handler handler2; @Override public void run() &#123; // 将当前线程初始化为Looper线程。 Looper.prepare(); // 实例化两个Handler。 handler1 = new Handler(); handler2 = new Handler(); // 开始循环处理消息队列。 Looper.loop(); &#125;&#125; 需要说明的是，一个Looper线程能拥有多个Handler对象。加入多个Handler对象后，LooperThread的结构图如下所示： 发送消息Handler创建完毕后，就可以使用post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和sendMessageDelayed(Message, long)等方法发送消息了。 通过这些API的参数看以看到，Handler不但可以发送Message对象，还能发送Runable对象，其实，Runable对象在底层也会被封装成Message对象发送给对应的消息队列。下面源码展示以post(Runnable)方法发送消息的过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * frameworks/base/core/java/android/os/Handler.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public class Handler &#123; ... public final boolean post(Runnable r) &#123; // getPostMessage(r)将Runnable封装成Message。 return sendMessageDelayed(getPostMessage(r), 0); &#125; ... private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; // 将Runnable设为Message的callback。 return m; &#125; ... public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; ... public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; ... private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; // Message的target必须设为当前Handler，因为Looper对象会用这个Handler对象处理此消息。 msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); // 将消息插入到消息队列。 &#125; ...&#125; 处理消息发送消息后，在Looper.loop()方法中会调用msg.target.dispatchMessage(msg)方法来处理消息，这个target就发送消息的Handler对象。以下源码展示了Handler处理消息的过程： 12345678910111213141516171819202122232425262728293031323334353637383940/** * frameworks/base/core/java/android/os/Handler.java * 开源项目: Android 版本名称: Nougat MR1 API Level: 25 */public class Handler &#123; ... public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 如果Message设置了callback，即Runnable消息，处理callback。 handleCallback(msg); &#125; else &#123; // 如果Handler本身设置了callback，则执行callback。 if (mCallback != null) &#123; // 这种方式运行使用Handler handler = new Handler(callback)方式创建Handler； // 避免通过继承Handler重写handleMessage()方法。 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 如果Message没有callback，则调用Handler的handleMessage()方法。 handleMessage(msg); &#125; &#125; ... private static void handleCallback(Message message) &#123; // 处理Runnable消息。 message.callback.run(); &#125; ... // 使用Handler handler = new Handler(callback)方式创建Handler所使用的Callback接口。 public interface Callback &#123; public boolean handleMessage(Message msg); &#125; ... // 由子类实现的处理消息的方法，默认实现为空。 public void handleMessage(Message msg) &#123; &#125; ...&#125; 消息机制通信的流程经过以上分析，消息机制的原理已经很清楚了，下面以一幅图来展示消息机制通信的整个流程：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的IPC方式]]></title>
    <url>%2F2018%2F02%2F02%2FAndroid%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上一篇文章介绍了Android中IPC的基本原理，这一篇文章详细介绍Android中各种跨进程通信的方式。 IPC的方式具体方式有很多，但是，它们的使用场景有很大区别，下面对这些方式进行详细分析。 使用IntentAndroid中的四大组件有三大组件（Activity, Service, Receiver）都支持在Intent中传递Bundle数据。由于Bundle实现了Parcelable接口，所以，它能够在不同进程中进行传输。因此，当在一个进程中启动了另一个进程的Activity、Service和Receiver组件时，可以在Bundle中附加数据，并通过Intent发送给目标进程的组件，这样就实现了跨进程通信。 不过，在传输的过程中，所传输的数据必须支持序列化。比如基本数据类型，字符串，Parcelable的实现类和Serializable的实现类。 使用文件共享文件共享式一种比较方便的跨进程通信方式，其原理是两个进程通过read/write同一个文件来交换数据。write文件的时候将对象序列化后保存到文件中，read文件的时候通过反序列化从文件中读取数据。 这种IPC方式对文件的格式没有具体要求，可以是txt、xml或者Json，只要是读写双方约定的格式即可。 不过这种方式存在并发read/write的问题，因此，使用这种方式时要尽量避免并发read/write文件的情况，或者使用线程同步的方式控制多个线程并发read/write文件。 使用Messenger可以使用Messenger创建跨进程通信的接口，这种方式需要使用Handler响应不同的Message对象（这里涉及到Android消息机制），因此，Handler是使用Messenger的基础。Messenger能够让服务端和客户端共享Binder对象，这样，客户端可以使用Messenger向服务端发送Message消息。另外，客户端也能定义一个Messenger，让服务端能够回传Message消息。 Messenger对AIDL做了封装，使用相对比较简单，不过，它是在一个线程中串行处理客户端请求，不需要考虑线程同步的问题。 以下是使用Messenger的主要步骤： 在服务端实现一个Handler，用来处理客户端发送的消息； 在服务端使用步骤1中的Handler初始化Messenger对象； 在服务端的onBind()方法中，使用步骤2中的Messenger对象创建一个Binder对象，并返回给客户端； 在客户端中使用步骤3中的Binder对象初始化一个Messenger对象，它用来给服务端发送Message对象； 服务端接在Handler中接收到Message对象后，进行相应的处理； 在服务端创建Messenger接口的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 在客户端使用Binder对象创建Messenger对象，并发送消息的示例代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 上面的示例没有展示服务端如何回复客户端。不过，如果服务端需要回复客户端，有一点非常关键，那就是当客户端发送消息的时候，需要把接收服务器端回复的Messenger通过Message的replyTo参数传递给服务端，作为通信的桥梁。 通过Messenger进行IPC的原理图如下所示： 使用AIDLMessenger串行处理客户端发送的消息，如果大量的消息同时发送到服务端，Messenger方式就不太合适了；同时，Messenger的主要作用是传递消息，如果要跨进程调用服务端方法，Messenger也无法做到。不过，AIDL可以实现这样的需求。 AIDL是一种接口定义语言，用于约束两个进程间的通讯规则，在进行IPC时，通信信息会被转换为AIDL协议消息，然后发送给对方，对方接收到AIDL协议消息后，再转换成相应的对象。 AIDL是由Binder机制实现的，Binder机制以在上一篇文章中介绍了，下面阐述如何使用AIDL进行IPC。 创建aidl文件可以使用Java语法定义aidl文件，每个文件必须定义一个interface，并将interface只能有一个，然后在interface声明调用的方法。 AIDL支持以下数据类型： 所有Java支持的原子数据类型（比如int, long, char, boolean等） String CharSequence List：只支持ArrayList，里面的每个元素都必须能被AIDL支持 Map：只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value Parcelable：所有实现了Parcelable接口的对象 AIDL：所有AIDL接口本身也可以在AIDL文件中使用 在定义AIDL接口时，需要注意以下几点： 如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的aidl文件，并在其中声明为parcelable类型。 自定义的Parcelable对象和AIDL对象必须在aidl文件中要显示import，即使他们和当前的aidl文件定义在同一个包内。 AIDL除了原子数据类型外，其它类型的参数必须标明数据流动的方向：in、out或者inout，原子类型默认方向是in，并且不能被改变。 要根据具体情况标明参数的数据流动方向，不能一概使用inout，因为这在底层是有开销的。 AIDL接口只支持声明方法，不支持声明static常量，这一点与Java中的接口不一样。 下面是一个定义AIDL接口的示例： 1234567891011121314151617// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 实现接口创建完AIDL接口后，Build项目，这时会根据aidl文件生成一个对应Java接口文件。这个接口包含了一个名为Stub的子类，它是一个Binder接口，服务端需要实现这个接口提供对应的服务。 123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125;&#125;; 在实现AIDL接口定义的方法时，需要注意： 要考虑多线程问题； 默认情况下，客户端调用服务端方法（RPC）是同步的，如果客户端的UI线程进行RPC，并且这个RPC比较耗时，会造成客户端ANR。所以，在需要的时候，在工作线程中进行RPC； 进行RPC时抛出的Exception不会被发送到客户端； 将接口暴露给客户端服务端实现AIDL接口后，需要将接口暴露给客户端。一般是通过Service组件，在其onBind()方法中将实现的Binder接口返回给客户端，示例代码如下： 12345678910111213141516171819202122public class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125; &#125;;&#125; 如果客户端和服务端属于不同的项目，需要将服务端的aidl文件复制到客户端，这时客户端才能声明AIDL定义的接口，并进行使用。 当客户端调用bindService()方法连接服务端时，onServiceConnected()回调方法会接收到服务端返回的Binder接口，将其转换为AIDL定义接口后，就可以调用服务端对应的方法了，示例代码如下所示： 12345678910111213141516IRemoteService mIRemoteService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Following the example above for an AIDL interface, // this gets an instance of the IRemoteInterface, which we can use to call on the service mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, "Service has unexpectedly disconnected"); mIRemoteService = null; &#125;&#125;; AIDL的进阶使用跨进程监听器通常会有这样的需求：客户端需要使用监听器去监听服务端数据的变化，然后做相应的处理。一般来说，会这样实现这个需求：客户端向服务端注册一个监听器，注册成功后，服务器在数据变化时，回调监听器里面的方法通知客户端数据发生变化；当客户端不需要数据监听数据变化时，就会向服务器注销这个监听器。 在AIDL中，需要使用AIDL接口定义监听器，然后，在服务器的AIDL接口中定义registerListener()和unRegisterListener()方法。由于要支持多线程，需要在服务端定义一个List去管理各个客户端的Listener，一般会想到使用CopyOnWriteArrayList去存储Listener，因为它支持多线程。不过，如果这样实现，我们可以发现：客户端可以正常register监听器，但是，客户端unRegister同一个监听器的时候，却总是失败！ 之所以会出现这个情况，是因为在客户端中，虽然register和unRegister的是同一个Listener对象，但是，Listener对象的数据通过Binder机制跨进程传输到服务端，进行反序列化后，在服务端却是不同的对象。总的来说，对象是不能跨进程直接传输的。 为了解决这个问题，就需要使用RemoteCallbackList，它是系统专门提供的用于删除跨进程Listener对象的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，所以，可以使用它来代替CopyOnWriteArrayList管理客户端的Listener对象，实现跨进程监听器。 RemoteCallbackList的内部有一个Map结构专门用来保存所有的AIDL回调，其key是IBinder类型，value是Callback类型。其Map结构的具体声明如下所示： 1ArrayMap&lt;IBinder, Callback&gt; mCallbacks = new ArrayMap&lt;IBinder, Callback&gt;(); 其中Callback中封装了正真的远程Listener。当客户端register时，它会把Listener的信息存入到Map结构中，key和value的获取过程如下所示： 12IBinder key = listener.asBinder();Callback value = new Callback(listener, cookie); 可以看到，Map结构的key值是Listener对应的Binder对象。之所以会这样，是因为Listener对象虽然是跨进程的，在客户端和服务端会是不同的对象，不过，这个跨进程的Listener在底层对应的Binder对象是同一个。正是利用这个特性，RemoteCallbackList可以正确删除掉对应的Listener对象。 同时，RemoteCallbackList内部自动实现了线程同步的功能，并且，在客户端进程意外终止后，也能够自动删除客户端注册的Listener对象。 RemoteCallbackList常用的API有： register和unregister：用来注册和注销客户端对应的Listener对象； beginBroadcast和finishBroadcast：开始使用和结束使用RemoteCallbackList对象，必须成对使用； getBroadcastItem(int pos)：根据pos获取对应的Listener对象； 多线程问题 客户端调用服务端的远程方法时，远程方法运行在服务端的Binder线程池中，同时，客户端线程会被阻塞，如果这个线程是UI线程，并且远程方法执行比较耗时，会造成客户端出现ANR，所以，不要在UI线程中调用耗时的远程方法。 服务端的远程方法（通过实现Binder接口的方法）本身就运行在服务端的Binder线程池中，所以，服务端的远程方法本身就可以执行大量耗时操作，切记不要在远程方法中开启线程执行异步任务，除非明确知道开启异步线程的目的。 当服务端调用客户端Listener中的方法时，该方法也运行在Binder线程池中，不过是客户端的线程池，所以，相对于服务端，Listener中的方法也是远程方法，因此，也不能在服务端（要注意Service组件运行在UI线程）调用客户端的耗时远程方法。所以，要确保客户端的耗时远程方法运行在服务端的非UI线程，否则，会导致服务端无法及时响应。 客户端的远程方法运行在客户端的Binder线程池中，因此，不能在其远程方法中修改UI。如果要修改UI，需要使用Handler切换到UI线程。 服务端的Binder连接有可能意外断开，为了程序的健壮性，客户端可以在断开时，重新连接服务端。有两种方法实现这个功能：第一种是客户端连接服务端成功后，使用Binder.linkToDeath()方法设置DeathRecipient监听器，这样，在Binder断开时，客户端会收到binderDied()回调方法；第二种是在客户端连接服务端时，重载onServiceDisconnected()方法。这两种方法的区别是，binderDied()回调方法运行在客户端的Binder线程池中，而onServiceDisconnected()方法运行在UI线程中。 权限控制默认情况下，远程服务任何客户端都能连接，这是不安全的，可以给服务加入权限验证功能。通常有两种方法： 在onBind()方法中验证 可以在服务端的onBind()方法中进行权限验证。下面介绍在onBind()方法中使用Permission验证： 1.在Manifest文件中声明所需的权限 123&lt;permission android:name="com.example.ipc.permission.ACCESS_DADA" android:protectionLevel="normal" /&gt; 2.在onBind()方法中做权限验证 12345public onBind(Intent intent) &#123; int check = checkCallingSelfPermission("com.example.ipc.permission.ACCESS_DADA"); if (check == PackageManager.PERMISSION_DENIED) return null; return mBinder; &#125; 如果权限不通过，就直接返回null，那么客户端就无法访问这个服务端。 3.如果客户端需要绑定声明权限的服务端，需要在Manifest中声明权限 1&lt;uses-permission android:name="com.example.ipc.permission.ACCESS_DADA" /&gt; 这种方式也可以用于Messenger中。 在onTransact()方法中验证 可以在服务端实现Binder接口时，重载onTransact()方法进行权限验证。下面介绍在onTransact()方法中获取客户端的Uid验证包名： 12345678910111213public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; String packageName = null; String[] packages = getPackageManager().getPackagesForUid(getCallingUid()); if (packages != null &amp;&amp; packages.length &gt; 0) &#123; packageName = packages[0]; &#125; if (packageName == null || !packageName.startsWith("com.example.ipc")) &#123; return fasle; &#125; return super.onTransact(code, data, reply, flags);&#125; 如果验证失败，就返回false，那么，客户端执行远程方法会失败。这种方式可以让客户端连接到服务端，但无法执行服务端的远程方法。 还可以使用getCallingPid()方法获取Pid，去验证客户端的包名，方法与上面介绍的基本一样。 不过，除了上述两种方法，还可以使用其它方式验证权限，比如为Service组件指定android:permission属性等，这里就不进行介绍了。 使用ContentProviderContentProvider是Android系统中专门用于不同应用间进行数据数据共享的方式，从这点来看，ContentProvider本身就适合进程间通信。和AIDL一样，它的底层也是通过Binder实现的，不过，系统对其进行了封装，使用过程比AIDL要简单。ContentProvider的具体使用这里就不介绍了，下面主要阐述使用ContentProvider进行IPC需要注意的细节。 创建一个ContentProvider一般需要实现六个抽象方法：onCreate、query、update、insert、delete和getType。根据Binder原理，这六个方法都运行在ContentProvider的进程中，不过，除了onCreate方法由系统回调并运行在主线程中，其它五个方法均由其它进程回调且运行在Binder线程池中。因此，不能在onCreate方法中做耗时操作，并且，其它应用调用另外五个远程方法时，如果这些方法比较耗时，不要在UI线程中调用。 由于query、update、insert、delete这四个方法会涉及到数据源的读写操作，并且它们运行在Binder线程池中，所以在具体实现这些方法时，要实现线程同步操作，保证线程安全。 使用SocketSocket主要用于网络通信，网络通信的服务端和客户端处于不同的主机，既然这样，处于同一个设备的服务端和客户端就更加能够使用Socket进行通信。因此，可以在Android系统中使用Socket方式进行进程间通信。Socket的具体使用这里就不介绍了，下面主要阐述在Android中使用Socket进行IPC需要注意的地方。 使用Socket进行通信，需要声明网络权限： 12&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; 另外，不要在主线程中访问进行网络通信，因为网络操作一般来说都比较耗时，如果放在主线程中会影响应用的响应效率。 Binder连接池在使用AIDL时，如果一个项目中，有多个业务模块都要使用AIDL提供服务，按照正常的实现方式，会创建多个Service组件去实现这些服务。但是，Service组件是一种系统资源，过多使用会影响系统性能；并且，在一个应用中使用多个Service，用户在查看APP详情的时候，会发现这个应用会有多个服务同时在运行，给用户造成该应用浪费系统资源的印象。为了解决这个问题，需要减少Service的数量，将所有AIDL接口都放在同一个Service中去管理。 要实现用一个Service组件管理多个AIDL接口的需求，就要使用到Binder连接池： 每个业务模块创建自己的AIDL接口，并实现这个接口，不过，不同的业务模块之间不能耦合；实现接口后，每个AIDL模块向服务端提供唯一的标识符和对应的Binder对象。 对于服务端，只需要一个Service组件，提供一个queryBinder接口，这个接口能根据AIDL模块的标识符返回对应的Binder对象给客户端。 对于客户端，通过AIDL模块的标识符调用远程queryBinder方法，获取对应的Binder对象后，就可以使用这个Binder对象调用该模块的远程方法。 Binder连接池的主要作用是将客户端对每个业务模块的Binder请求统一转发到远程的Service中去执行，从而避免了重复创建Service组件，其工作原理如下图所示： 以上阐述了Binder连接池的实现原理，具体实现可以参考《Android开发艺术探索》相关章节。 使用合适的IPC方式上面介绍了各种IPC方式，但每种IPC方式都有其使用场景，可以根据具体需求选择不同IPC方式。 下表总结了Android中各种IPC方式的优缺点以及使用场景： 方式 优点 缺点 使用场景 Intent 简单易用 只支持传输Bundle数据 四大组件之间的进程间通信 文件共享 简单易用 不适合并发场景，无法做到即时通信 无并发访问、交换简单数据并且实时性不高的场景 Messenger 支持一对多串行通信，支持实时通信 不太适合高并发场景，不支持RPC，只支持传输Bundle数据 低并发的一对多的即时通信，并且无RPC要求 AIDL 支持一对多并发通信，支持实时通信 使用比较复杂，需要处理线程同步 一对多通信，或者有RPC需求 ContentProvider 支持一对多并发数据共享 可理解为受约束的AIDL，主要提供对数据源的CRUD操作 一对多的进程间的数据共享 Socket 功能强大，支持一对多并发实时通信 实现比较繁琐，不支持直接RPC 网络数据交换]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的IPC介绍]]></title>
    <url>%2F2018%2F02%2F01%2FAndroid%E4%B8%AD%E7%9A%84IPC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[IPC简介和使用场景IPC简介IPC(Inter-Process Communication)是指进程间通信，即两个不同进程之间交换数据的过程。 在明确IPC之前，要明白线程和进程的区别： 线程线程是进程中的一个实体，是能被操作系统独立调度的基本单位。它不拥有系统资源，但是它可以与同属于同一个进程的其它线程共享进程的全部资源。 进程一个执行单元，在PC和移动设备上一般指一个程序或者应用，一个进程可以包含多个线程。每个进程都拥有操作系统分配的相互独立的系统资源，比如CPU、内存等。 在Android系统中，一般一个APP就是一个进程（在无特别代码实现的情况下），UI线程就是这个进程的主线程。如果有耗时操作，会导致主线程堵死，而Android中的主线程负责UI操作，就会出现所谓的ANR（Application Not Responding），影响用户体验。所以，Android中一般需要将耗时操作放在子线程中进行。 IPC的使用场景在Android开发中，使用IPC的场景一般有以下两种情况： 应用自身原因，需要采用多进程模式现实比如，一个APP中的一些模块因为特殊原因需要在单独的进程中运行；或者，需要加大一个APP可使用的内存（Android系统对单个APP可使用的内存大小有限制）。 当前应用需要获取其他应用的数据每个APP对应一个进程，所以需要使用IPC。 Android中的多进程模式这里讨论的多进程模式是指在一个APP中开启多个进程的情况，因为两个APP之间默认就是多进程的。 开启多进程模式在Android中开启多进程一般只有一种方法，就是给四大组件（Activity，Service、Receiver、Provider）指定android:process属性，因此，不能为一个线程或者实体类指定其运行时所在的进程。 其实还有一种非常规开启多进程的方法，即通过JNI在native层fork一个新的进程，这种方法比较特殊，这里不进行考虑。 在Android中开启多进程的示例代码如下： 12345678910111213141516&lt;activity android:name=".MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="com.example.ipc.SecondActivity" android:process=":remote" /&gt;&lt;activity android:name="com.example.ipc.ThirdActivity" android:process=".remote" /&gt; 在APP中把这三个Activity都打开，通过DDMS可以看到开启了三个进程： 这三个进程分别是： com.example.ipcMainActivity所在的进程，当前APP的默认进程，和包名相同。 com.example.ipc:remoteSecondActivity所在的进程，当前APP的私有进程。 .remoteThirdActivity所在的进程，全局进程。 SecondActivity与ThirdActivity所在的进程区别如下： 如果进程名以 : 开始，那么这个进程名会被附加上当前应用的包名，表示该进程是当前应用的私有进程，其它应用不能和它在同一个进程中运行。 如果进程名不以 : 开始，那么进程名不会被附加包名信息，是一个完全的命名，表示该进程是全局进程，其它应用可以通过声明相同的android:sharedUserId属性，和它在同一个进程中运行。 Android系统会为每个应用分配一个唯一的UID(User Id)，如果两个应用具有相同的UID，并且签名也相同，那么，这两个应用可以相互访问对方的私有数据，比如组件信息、data目录等；更进一步，如果这两个应用运行在同一个进程时，它们还可以共享内存数据，或者说它们就像是同一个应用的两个部分。 因此，可以把同一个应用中的多进程理解为两个不同的应用使用了相同sharedUserId属性。 开启多进程存在的问题前面介绍过，操作系统会为每个进程分配相互独立的系统资源，同样，在Android系统中，会为每个进程分配一个独立的虚拟机。由于不同虚拟机在内存分配上的地址空间不同，这就导致不同进程访问同一个类时，会多次实例化这个类，这样，每个进程都会拥有一个这个类的对象，造成多进程间无法共享内存数据。 一般来说，在Android系统中，使用多进程会造成以下几个问题： 静态成员和单例模式失效； 线程同步机制失效； SharedPreferences的可靠性下降； Application会创建多次； 终上所述，在多进程模式中，不同进程的组件会拥有独立的虚拟机、Application和内存空间，这样，多进程之间就无法使用共享内存的方式进行通信，不过，Android系统提供一些跨进程的通信方式。接下来先介绍IPC涉及的一些基本概念，IPC的方式在会下一篇文章中详细分析。 IPC涉及的基本概念序列化和反序列化序列化是指将对象转换为可保存的字节序列；反序列化是将字节序列恢复为可使用对象。进程间通信时，一个进程需要将传递的对象序列化，另一个进程接收到序列化对象后需要反序列化，才能正常获取对象的数据。 在Android中，通常有Serializable和Parcelable两种序列化方式，它们之间的有如下区别： Serializable是Java中的序列化接口，其使用起来简单但是开销较大，序列化和反序列化需要大量的I/O操作。 Parcelable是Android中的序列化方式，更适用于Android的平台，缺点是使用起来稍微麻烦，但是效率很高。 Parcelable主要用于内存序列化上，适合进程间的通信；Serializable更适合文件存储和网络传输。 Android Binder机制Binder定义及原理Binder在不同场景下有不同含义： 从机制、模型的角度来说Binder是Android系统中特有的一种进程通信方式，即Binder机制模型，用于Android系统实现IPC。 从模型的结构、组成的角度来说Binder是一种虚拟的物理设备驱动，即Binder驱动，是ServiceManager连接Manager（比如ActivityManager）和相应ManagerService（比如ActivityManagerService）的桥梁。 从Android应用层来说Binder是Client和Server进行通信的媒介，当Client绑定一个Server时，Server就会返回一个包含了服务端业务的Binder对象，Client可以通过这个Binder对象获取Server提供的数据和服务。 从Android代码实现的角度来说Binder是一个类，实现了IBinder接口，用于在Android系统中具体实现Binder机制模型。 可以用一张图描述Binder原理： Binder通信采用的是C/S架构。AMS(ActivityManagerService)可以看成Server；AMP(ActivityManagerProxy)是AMS的代理类，ActivityManager通过AMP与AMS进行通信，可以看成Client。 ServiceManager用于管理系统中的各种服务，不过需要注意的是，这里的ServiceManager是属于Native层（C++）而不是Framework层（Java）。 ioctl是一个系统调用，用于内核空间和用户空间交换数据。通常情况下，进程处于用户空间，并且相互独立，如果要进行通信，需要通过操作系统的内核空间交换数据。 图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制的，那么，图中的每个步骤都有相应的Client端与Server端： 注册服务首先AMS注册到ServiceManager。该过程：AMS所在进程(system_server)是客户端，ServiceManager是服务端。 获取服务Client进程使用AMS前，须先向ServiceManager中获取AMS的代理类AMP。该过程：AMP所在进程(app process)是客户端，ServiceManager是服务端。 使用服务app进程得到的代理类AMP后，就可以直接与AMS所在进程交互。该过程：AMP所在进程(app process)是客户端，AMS所在进程(system_server)是服务端。 图中的Client, Server, ServiceManager之间交互都是虚线表示，是由于它们彼此之间不直接交互，而是通过Binder驱动进行交互，从而实现IPC。其中Binder驱动位于内核空间，Client, Server, ServiceManager位于用户空间。Binder驱动和ServiceManager可以看做是Android平台的基础架构，而Client和Server属于Android的应用层。 如果要进一步了解Binder的底层细节，可以参考彻底理解Android Binder通信架构。 Binder的优点对比Linux（Android基于Linux）上的其他进程通信方式（管道/消息队列/共享内存/信号量/Socket），Binder机制的优点有： 高效 Binder数据复制只需要一次，而管道、消息队列、Socket都需要2次； 通过驱动在内核空间复制数据，不需要额外的同步处理，而共享内存需要进行同步处理； 安全性高 Binder机制进行通信时，会根据进程的UID/PID进行有效性检测； 其它进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信的IP地址是客户端手动填入，容易出现伪造； 使用简单 采用C/S架构； 实现了“面向对象”的调用方式，在使用Binder时就和调用一个本地对象实例一样； Binder在Android中的应用在Android开发中，Binder主要用于Service组件中，Service组件根据是否被绑定分为普通Service（Unbounded Service）和绑定Service（Bounded Service）。其中，普通Service用于完成后台工作任务，不涉及交互，只有绑定Service才会使用Binder进行交互。 在Android中，使用绑定Service有以下三种方式： 扩展Binder类如果Service仅供当前应用使用，不需要跨进程工作，则可以实现自己的Binder类，让客户端通过该类直接访问Service中的公共方法。这种方式只在同一个进程中进行交互，不涉及IPC。 使用Messenger如果Service需要进行跨进程通信，则需要在Service中使用Messenger。这种方式实现了IPC，并且会在单一线程中创建包含所有请求的队列，以串行的方式处理客户端发来的消息，这样，在进行IPC的时候不需要考虑线程同步的问题。 使用AIDL如果Service需要跨进程通信，并且还需要并行处理客户端请求，则需要在Service中使用AIDL。这种方式实现了IPC，还可以让服务端具备多线程处理的能力， 不过，在进行IPC的时候需要考虑线程同步的问题。 其实，Messenger底层是通过AIDL实现的，不过它们最终还是要使用Binder机制实现IPC。 虽然，Messenger和AIDL用于跨进程通信，但是，在同一个进程中，Messenger和AIDL也是能够使用的，不过，这两种情况的底层实现是不一样的，具体表现为： 当Client和Server在同一个进程中时，绑定成功后，Client获取的Binder对象就是Server中定义的Binder对象本身，这样可以直接调用Server中的方法，不需要进行IPC； 当Client和Server在不同的进程中时，绑定成功后，Client获取的Binder对象是Server中Binder的代理对象BinderProxy，具体进行IPC的时候就是通过这个代理对象实现的。 里面的具体细节可以参考Android Binder跨进程与非跨进程的传输异同源码分析。 不过，还有一点需要注意的是，Client发起请求时，Client所在的线程会挂起，直到Server所在的进程返回数据，所以，当要调用的远程方法比较耗时，最好不要在UI线程中发起这个远程调用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent匹配规则]]></title>
    <url>%2F2018%2F01%2F31%2FIntent%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[通过Intent启动Activity有“显示启动”和“隐式启动”两种方式。显示启动需要明确指定被启动Activity的组件信息，包括包名和类名；而隐式启动不需要明确指定启动哪个Activity，只需要使用“匹配规则”描述要启动的Activity的一些特征，系统会根据这些特征搜索对应的Activity，如果对应的Activity有多个，会让用户选择要启动的Activity，否则，直接启动匹配到的Activity。 隐式启动通常用于APP之间的交互，比如，一个APP要播放音乐，但是该APP没有提供播放功能，这时该APP就可以通过隐式启动，调用当前系统中能够播放音乐的APP进行播放。下面介绍隐式启动的使用及其匹配规则。 隐式启动隐式启动需要Intent能够匹配目标组件在intent-filter标签中设置的过滤信息，intent-filter标签中能设置的过滤信息有action、category和data三类，下面是一个过滤规则的示例： 123456789101112131415161718&lt;activity android:name="com.chinaums.opensdkdemo.activity.tab.MyTabActivity" android:configChanges="keyboardHidden|orientation" android:launchMode="singleTask" android:screenOrientation="portrait"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!-- umsapp://main.app/openwith?key1=value1&amp;key2=value2... --&gt; &lt;data android:host="main.app" android:pathPrefix="/openwith" android:scheme="umsapp" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 系统对Intent进行匹配时，要同时匹配以上三类信息，才能启动目标组件。intent-filter标签中的action、category和data可以有多个，同时，一个Activity中也可以有多个intent-filter。不过，一个Intent只要匹配任何一组intent-filter即可启动对应的的Activity。 匹配规则接下来详细分析action、category和data这三类信息的匹配规则。 action匹配规则action是一个字符串，系统预定了一些action，可以直接使用，同时，也可以自定义action。 action的匹配规则要求Intent中的action存在，并且必须和intent-filter标签中的一个action相同。 需要注意的是action区分大小写。 category匹配规则category也是一个字符串，系统也预定义了一些category，同样，也可以自定义category。 但是，category匹配规则与action不一样。category匹配规则要求，如果Intent中出现了category，不管有几个category，对于每个category，它必须是intent-filter标签中已经定义了的category。 需要注意的是，如果Intent没有定义category，系统在调用startActivity()和startActivityForResult()方式时，会默认为Intent加上 “android.intent.category.DEFAULT” 这个category。因此，要想Activity能够接收隐式调用，必须在其intent-filter标签中指定这个默认的category。 data匹配规则data匹配规则和action类似，如果intent-filter标签中定义了data，那么Intent中必须要也要定义可匹配的data。 data语法格式如下所示： 1234567&lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; data由两部分组成：mimeType和URI。 mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic等，可以表示图片、文本、视频等不同的媒体格式。 URI包含了data标签中，除了mimeType以外的所有属性，下面是URI的结构及其实例： 1234&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com/search/info URI中每项数据的含义如下： scheme：URI的模式，例如http、file、content等，如果URI中没有指定scheme，那么URI无效的。 host：URI的主机名，例如www.baidu.com，如果host没有指定，URI也是无效的。 port：URI的端口号，只有指定scheme和host参数，port参数才有意义。 path：表示URI的路径信息。 pathPrefix：表示URI路径的前缀信息。 pathPattern：也可以表示路径信息，不过可以包含通配符 “*” ，用于表示0个或多个任意字符。 下面介绍两个data匹配的实例。 只配置mimeType1234&lt;intent-filter&gt; &lt;data android:mimeType="image/*" /&gt; ...&lt;/intent-filter&gt; 上面的规则指定了媒体类型为所有格式的图片类型，那么Intent中的mimeType必须指定为 “image/*” 才能匹配。这里intent-filter没有指定URI，但是系统会为其指定默认值为content和file，所以，要匹配这个过滤器，Intent中URI部分的schema还必须设置为content或者file。 因此，要匹配上面的规则，可以使用下面的示例代码： 1intent.setDataAndType(Uri.parse("file://abc"), "image/png"); 配置多个data12345&lt;intent-filter&gt; &lt;data android:mimeType="video/mpeg" android:scheme="http" ... /&gt; &lt;data android:mimeType="audio/mpeg" android:scheme="http" ... /&gt; ...&lt;/intent-filter&gt; 上面的规则指定了两组data规则，如果要匹配这个规则，可以使用以下示例代码： 1intent.setDataAndType(Uri.parse("file://abc"), "video/mpeg"); 或者 1intent.setDataAndType(Uri.parse("file://abc"), "audio/mpeg"); 匹配规则检测在用隐式Intent启动一个Activity的时候，可以使用resolveActivity()方法对匹配规则进行检测，如果返为null就表示该Intent无法匹配到任何Activity。 还可以使用queryIntentActivities()方法进行检测，不过，这个方法返回所有成功匹配的Activity信息，而resolveActivity()方法返回的是最佳匹配的Activity信息。 另外，Intent的匹配规则对于Service和BroadcastReceiver也是一样的，不过Android建议尽量使用显示的方式启动Service。同时，PackageManager对象也提供了类似方法去检测是否存在匹配的Service或BroadcastReceiver组件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APP组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存优化]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于Android系统的沙箱机制，分别给每个APP的内存大小是有限的。为了APP能在有限的内存下流畅地运行，通常需要对内存进行一定的优化。 Java中的存储空间在Java中，存储空间通常包括以下几个部分： 寄存器速度最快的存储场所，处于CPU内部，一般不在程序中进行控制。 栈存放基本的数据类型和对象引用。 堆存放使用new关键字创建的对象本身，由Java虚拟机的自动回收机制管理。 静态存储区用来存储静态变量。 常量池用来存储常量。 通常来说，当定义了一个变量，Java虚拟机会在栈中为其分配存内存空间，当变量的作用域结束后，这部分内存会被立刻回收；如果用new关键字创建一个对象，那么会在堆中为这个对象分配内存空间，即使对象的作用域结束了，这部分内存不会被立刻回收，而是等待虚拟机的垃圾回收器进行回收。所以，内存优化主要是指优化堆所指的内存。 内存泄露虽然，Java虚拟机可以通过垃圾回收器自动回收堆中的内存，但是，垃圾回收器不能在所有情况下都能正确地回收内存，这样，就会造成部分内存无法被再使用，即所谓的内存泄露。 所以，内存优化的目的不仅要有效地利用内存，还要尽量避免内存泄露。 内存优化的方法下面介绍一些常用的内存优化方法。 Bitmap优化Bitmap通常会占用大量内存，通常会造成OOM（Out Of Memory）。使用Bitmap时，可以使用以下优化方法： 使用适当分辨率的图片 由于Android系统在进行资源适配时，会根据屏幕分辨率加载对应分辨率的图片，如果在低分辨率的屏幕上加载高分辨率的图片，就会造成内存浪费。所以，在特定的屏幕上，只加载合适当分辨率的图片。另外，在对图像分辨率没有要求的地方，尽量使用低分辨率的图片。 使用图片缓存 使用内存缓存和磁盘缓存可以更好地使用Bitmap。 代码优化可以从代码的角度进行内存优化，下面是常用的一些方法： 对常量使用static修饰，可以加快访问速度； 尽量使用静态方法，静态方法比普通方法的访问速度更快； 减少不必要的成员变量； 减少不必要的对象，尽量使用基本类型； 尽量不使用枚举和迭代器； 对Cursor、Receiver、Sensor、File等对象，使用完毕后要注意回收和注销； 避免使用IoC（控制反转）框架，这些框架通常使用注解和反射实现，大量使用会降低性能； 使用RenderScript或OpenGL进行非常复杂的绘图操作； 使用SurfaceView代替View进行频繁的绘图操作； 尽量使用ViewHolder复用View； Memory ProfilerAndroid Profiler工具中的Memory Profiler组件能够可视化APP内存使用情况，帮助开发者定位内存泄露。这个工具还提供了捕获堆内存释放、强制进行垃圾回收，以及跟踪内存分配等功能，帮助我们更好地对内存进行优化。 更多性能优化Android的性能优化是一个比较大的话题，这里只介绍了常用的UI优化和内存优化，其它方面的性能优化可以参考性能优化的官方文档。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI优化]]></title>
    <url>%2F2018%2F01%2F29%2FUI%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[系统在渲染UI时会消耗大量的资源，一个好的UI不仅该具有良好的视觉效果，还应该具有良好的使用体验。布局优化的任务就让UI在使用过程中不产生卡顿，让APP有更好的用户体验。 UI渲染机制和检测工具渲染机制在Android中，系统通过VSYNC信号触发UI的渲染和重绘，信号发送的间隔时间是16ms。如果系统每次渲染的时间都控制在16ms之内，那么，UI界面会非常流畅，否则，就会造成丢帧，从而能使界面产生卡顿。例如，一次绘制任务耗时20ms，那么，在16ms系统发出VSYNC信号时就无法进行绘制，该帧只能等待下次VSYNC信号来临时才被绘制，这样，16*2ms内都是显示同一帧画面，用户在视觉上就会产生卡顿的感觉。 检测工具Android系统提供了检测UI渲染时间的调试工具。打开“开发者选项”，选择 “Profile GPU Rendering” ，然后选中 “On screen as bars” 选项，这时在屏幕上会显示如下图形： 图中每条柱状图由多种颜色组成，每种颜色的长度表示在渲染时，各个绘制过程消耗的时间。中间的绿色横线表示VSYNC间隔时间16ms，一个良好的UI需要尽量将所有条状图都控制在这条绿线之下。每种颜色表示的绘制过程如下图所示： 当知道了每个绘制过程的时间后，就可以针对特定的绘制过程进行优化。 Input Handing输入处理（Input）颜色的长度表示APP在输入事件回调方法中，处理事件花费的时间长短。 如果这方面时间花费太多，表示在处理输入事件时做了太多工作，由于回调方法是在主线程上进行的，可以将繁重的工作放到子线程中进行，从而达到优化效果。 另外，RecyclerView的滑动也属于输入处理，因为滑动会消耗触摸事件，所以，要尽可能快地布局和填充子View。 Animation动画（Anim）颜色的长度表示当前帧执行完所有动画花费的时间。这些常见的动画包括ObjectAnimator, ViewPropertyAnimator和Transitions. 如果这方面时间花费太多，一般都是执行动画引起属性变化造成的。比如，ListView或RecyclerView在执行fling动画时会快速滑动，引起大量子View的布局和重绘，从而造成执行动画时间过长。 Measurement和Layout测量和布局（Measure）颜色表示系统在测量和布局View时花费的时间。 如果这方面花费时间太多，一般都是自定义View时，onLayout()和onMeasure()方法执行时间过长造成的。可以用Traceview和Systrace工具检查代码中这样的问题。 Drawing绘制（Draw）颜色表示当前帧绘制View花费的时间，包括所有View执行onDraw()和dispatchDraw()方法的时间。 如果这方面花费时间太多，一般都是自定View时，onDraw()方法的逻辑太过复杂造成的。 Sync和Upload同步和上传（Upload）颜色表示当前帧中，将Bitmap对象从CPU内存转移到GPU内存花费的时间。 Android系统在绘制Bitmap时，需要将Bitmap从CPU传递到GPU，然后GPU再进行绘制。注意，在5.0系统上，这个时间用紫色表示。 如果这方面花费时间太多，一般来说是由两种情况造成的：一个是当前帧显示了一个接近屏幕大小的Bitmap；另一个是当前帧显示了大量缩略图。 如果要减少这方面的时间，可以使用以下两种方法： 在显示图片时，不要让高分辨率的图片在低分辨率的屏幕上显示。 在CPU和GPU内存同步内存之前，利用prepareToDraw()方法异步上传Bitmap对象。 Issuing Commands发布命令（Issue）颜色表示绘制屏幕时，发布所有绘制命令到显示列表（Display Lists）花费的时间。 由于系统绘制屏幕时，会向GPU发布必要的绘制命令，通常这些操作是通过OpenGL的API实现的。如果这方面花费的时间太多，表明在绘制时有太多的绘制命令需要发布。比如： 12for (int i = 0; i &lt; 1000; i++)canvas.drawPoint() 完成以上绘制的发布的绘制命令就完成以下绘制的要多，这样就会在发布命令上花费更多时间。 1canvas.drawPoints(mThousandPointArray); 所以，在自定义View时，尽量减少draw操作的数量，可以减少发布命令的时间。 Processing和Swapping BuffersCPU发布绘制命令和GPU执行绘制命令的操作是并行的，当CPU发布的速度快于GPU执行的速度时，命令队列会被填满，这时CPU就会被堵塞。处理和交换缓冲（Swap）的颜色表示的这时CPU等待GPU花费的时间。一般CPU被堵塞发生在交换缓冲区（Swap Buffers）阶段，因为在这个阶段，绘制一帧的所有绘制命令会被一起提交给GPU，造成GPU没时间处理CPU接下来发布的绘制命令。 减少这方面时间消耗用到方法与 “Issuing Commands” 中用到的方法一样。 Miscellaneous除了渲染UI，在主线程上还有很多其它操作，其它（Misc）颜色就是用来表示其它操作花费的时间。一般来说，其他时间就指在UI线程上连续绘制两帧之间的时间间隔。 如果这方面花费时间太多，表明在主线程中做了太多工作，可以将这些工作放到其它线程中。Method Tracing和Systrace工具可以可视化主线程中的任务，这些可视化的信息可以帮助进行相关优化工作。 避免过度绘制过度绘制（Overdraw）会浪费很多系统资源，比如，系统会默认绘制Activity的背景，如果再给根布局绘制背景，那么默认的Activity背景就属于无效的过度绘制。 Android系统提供了 “Enable GPU Overdraw” 调试工具来检查UI的过度绘制。在“开发者选项”中打开这个选项后，如下图所示： 可以通过界面上的颜色来判断Overdraw的次数： 没有颜色：没有过度绘制； 蓝色：过度绘制1次； 绿色：过度绘制2次； 粉色：过度绘制3次； 红色：过度绘制4次或更多次； 一般可以使用以下几种方式减少过度绘制次数： 移除布局中无用的背景 可以使用Layout Inspector工具找出那些对用户不可见的背景，然后移除这些无用的背景属性。还可以将APP的window背景颜色设置为主背景，那么所有的根布局的就不需要背景色了，从而减少过度绘制次数。 减少布局层级 在Android中，系统对View进行测量、布局和绘制时，都是通过对View树的遍历进行操作的。如果一个布局的层级太深，就会严重影响这些操作的速度，并且还会增加过度绘制次数。所以，在定义布局时，应该尽量减少布局层级，这样不但可以提高渲染速度，还能减少过度绘制次数。 减少使用透明度 绘制具有透明度属性的像素会增加过度绘制，和一般的过度绘制不一样，带有透明度的对象要求先绘制对象原本的颜色，然后再去绘制对象的透明度值，这样，一个带透明度属性的对象就需要绘制两次。像透明度视觉效果的动画，比如淡入淡出和阴影就是涉及到透明度属性，会造成过度绘制。可以通过减少使用带有透明度属性的对象来改善这种形式的过度绘制。 避免无用布局在“过度绘制”中已经提到过，布局层级太深会影响View进行测量、布局和绘制的速度，并且还会增加过度绘制次数。所以，要尽量避免无用布局，去减少布局的层级。下面介绍两种常用的避免无用布局的方法。 使用merge标签 通常会使用include标签重用layout，但是，使用include标签一般会在子View上增加一层根布局，有时在使用include中的子View时，可能并不需要这层根布局，这时就可以使用merge标签代替这个根布局。这样，子View会直接填充到include的位置，不会再添加任何额外的布局结构。 使用ViewStub标签 通常会在一个布局中隐藏一个子布局，在需要的时候再去显示。但是，即使将子布局进行隐藏，它们还是存在于布局中，在渲染UI时，还是会遍历这些隐藏的子布局，这时就可以使用ViewStub标签。 ViewStub虽然是View的一种，但是它没有大小，没有绘制功能，也不参与布局，资源消耗非常低，将它放置在布局当中，基本上不会影响UI性能。 不过，ViewStub加载的布局是不能使用merge标签的，因此，有可能导致加载出来的布局存在多余的布局结构。具体如何去取舍要根据实际情况来决定，对于那些隐藏的布局文件结构相当复杂的情况，使用ViewStub还是一种不错的选择。 Hierarchy Viewer可以使用Hierarchy Viewer工具查看布局的View树结构，并测量每个View的绘制速度。这些信息可以帮助我们对UI进行优化。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全机制]]></title>
    <url>%2F2018%2F01%2F29%2FAndroid%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android安全机制简介Android系统中，可以用以下几种安全机制保护系统的安全。 代码安全机制代码安全机制就是使用代码混淆proguard来保护系统安全。 APK存在被反编译的风险，proguard可以混淆关键代码，替换命名让破坏者阅读代码困难，同时可以压缩代码，优化编译后的Java字节码。 应用权限控制应用权限控制是在Manifest文件中声明权限，对权限进行检查。 任何应用程序在使用系统受限资源时，都需要向系统声明所需要的权限，通过了权限检查，才能调用系统对应的服务。 应用签名机制应用签名机制是利用数字证书来控制APK的来源是否安全。 Android中所有的APP都有一个数字证书，即APP的签名，用于保护APP的作者对已APP的信任关系。只有相同数字签名的APP，才会在升级时被认为是同一个APP，并且系统不会安装没有签名的APP。 Linux内核层安全机制Android是基于Linux内核开发，所以Android继承了Linux的安全特性，比如文件访问权限控制。通常只有System和Root用户才有权限访问系统文件。 虚拟机沙箱机制Android的APP运行在虚拟机中，因此有了沙箱机制，可以让APP之间相互隔离。通常情况下，不同APP之间不能相互访问，每个APP运行在单独的虚拟机中，与其它APP完全隔离，即使一个APP崩溃，也不会对导致其它APP异常。 APK反编译APK文件本质上是一个压缩文件，但是APK一般都做过加密处理，普通的解压方式不能得到正确的文件，下面介绍一些常用的工具，它们可以分别反编译APK的不同部分。 apktoolapktool可以用来反编译APK中的XML资源文件。 通过以下命令反编译一个APK文件： 1apktool.jar d test.apk 参数d是decode的意思，apk文件可以加上目录。执行反编译命令后，当前文件夹会出现对应APK名字的文件夹，打开文件夹就可以看到APK的资源文件。 这个工具在汉化时比较有用，在提前资源文件进行汉化后，可以用以下命令重新打包： 1apktool.jar b test smali使用apktool工具反编译APK文件后，可以得到一个smali文件夹。要查看APK的源码，首先需要将使用smali工具将smali代码转换为dex文件。 通过以下命令将smali文件转换为dex文件： 1smali.jar test/smali -o test.dex 使用以上命令后，后在当前文件夹会出现test.dex文件。 dex2jar使用smali工具获取dex文件后，还需要将dex文件转换为jar文件。 通过以下命令将dex文件转换为jar文件： 1dex2jar.bat test.dex 使用以上命令后，可以得到命名为test.dex.dex2jar.jar的文件。 jd-gui通过dex2jar工具获得了APK源码对应的jar文件后，就可以使用jd-gui工具查看APK的源码了。 直接打开jd-gui.exe程序，打开对应的jar文件查看即可。 APK加密Java字节码很容易被反编译，可以使用ProGuard对代码进行混淆，增加APK的安全性。 ProGuard的原理是使用无意义的字母来重命名类、字段和方法。不过，除了进行混淆代码，ProGuard还可以删除无用的类、字段和方法，以及无用的注释，最大限度地优化Class文件。 在Gradle中使用ProGuard的代码如下所示： 123456buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 其中minifyEnabled表示是否打开代码混淆，proguardFiles表示混淆规则的文件。前一个是系统默认的混淆文件，大部分情况使用这个默认文件就行了；后一个是自定义的混淆文件，在这个文件中可以定义一些第三方依赖包的混淆规则。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统与安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取系统和APK信息]]></title>
    <url>%2F2018%2F01%2F29%2F%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%92%8CAPK%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[获取系统信息通常可以通过android.os.Bulid和SystemProperty获取系统的配置信息。 android.os.Buildandroid.os.Bulid类包含了很多系统编译时的大量设备和配置信息，常用的有： Build.BOARD：主板 Build.BRAND：系统定制商 Build.SUPPORTED_ABIS：CPU指令集 Build.DEVICE：设备参数 Build.DISPLAY：显示屏参数 Build.FINGERPRINT：唯一编号 Build.SERIAL：硬件序列号 Build.ID：修订版本列表 Build.MANUFACTURER：硬件制造商 Build.MODEL：版本 Build.HARDWARE：硬件名 Build.TAGS：描述Build的标签 Build.TYPE：Build类型 Build.VERSION.CODENAME：当前开发代号 Build.VERSION.INCREMENTAL：源码控制版本号 Build.VERSION.RELEASE：版本字符串 Build.VERSION.SDK_INT：版本号 Build.HOST：Host值 Build.USER：User值 Build.TIME：编译时间 可以直接使用android.os.Bulid类获取Build提供的系统信息。 SystemPropertySystemProperty包含了许多系统配置属性值和参数，有一些也可以通过android.os.Bulid类获取，常用的有： os.verison：OS版本 os.name：OS名称 os.arch：OS架构 user.home：Home属性 user.name：Name属性 user.dir：Dir属性 user.timezone：时区 path.separator：路径分隔符 line.separator：行分隔符 file.separator：文件分隔符 java.vendor.url：Java vender URL属性 java.class.path：Java Class路径 java.class.version：Java Class版本 java.vendor：Java Vender属性 java.version：Java版本 java.home：Java Home属性 具体获取SystemProperty的值通过System.getProperty(“xxx属性”)方法。 获取APK信息除了获取系统相关信息，还可以获取APK的相关信息。 PackageManagerAndroid系统使用PackageManager来负责管理所有已安装的APP，它通过解析Manifest文件，将APP的各种组件和相关信息封装成对应的类。下面介绍一些常用的封装类。 ActivityInfo、ServiceInfo、ReceiverInfo、ProviderInfo封装了Manifest文件中各个组件的信息，包括name、icon、label、launchmode等。 ApplicationInfo封装了Manifest文件中application的信息，不过ApplicationInfo还包含了很多Flag，比如FLAG_SYSTEM表示系统应用、FLAG_EXTERAL_STORAGE表示安装在SDCard上的应用等，通过Flag，可以判断应用的类型。 PackageInfo封装了APK安装包的基本信息，比如包名、权限等。 ResolveInfo封装了Manifest文件中包含intent标签的组件的信息，可以用来寻找包含特定Intent的应用，比如寻找有分享功能的应用。 PackageManager可以通过调用相关方法，获取上面介绍的封装类，从而获取APK相关的信息，常用的方法有： getPackageManager()：获取PackageManager对象。 getApplicationInfo()：获取指定包名的ApplicationInfo。 getApplicationIcon()：获取指定包名的Icon。 getInstalledApplications()：以ApplicationInfo形式返还系统安装的所有应用。 getInstalledPackages()：以PackageInfo形式返回系统安装的所有引用。 queryIntentActivities()：返回指定Intent的所有Activity的ResolveInfo对象。 queryIntentServices()：返回指定Intent的所有Service的ResolveInfo对象。 resolveActivity()：返回指定Intent的Activity的ResolveInfo对象。 resolveService()：返回指定Intent的Service的ResolveInfo对象。 ActivityManagerPackageManager主要获取APK的静态信息，而ActivityManager可以获取APP运行时的信息。类似的，ActivityManager也将相关信息封装为对应的对象，比较常用的有： ActivityManager.MemoryInfo提供当前系统内存相的关状态信息，提供的字段有：availMem：系统可用内存；totalMem：总内存；threshold：低内存的阈值；lowMemory：是否处于低内存； Debug.MemoryInfo提供提供某个进程的内存使用信息。 RunningAppProcessInfo提供运行的进程的信息，提供的字段有：processName：进程名；pid：进程的pid；uid：进程的uid；pkgList：该进程下所有的包； RunningServiceInfo提供运行的服务的信息，提供的字段有：activeSince：第一次激活的时间和方式；foreground：服务是否在后台运行； 一般通过以下代码获取ActivityManager对象： 12ActivityManager activityManager = (ActivityManager) (getSystemService(Context.ACTIVITY_SERVICE)); Packages.xmlAndroid系统在初始化的时候，PackageManager的底层实现类PackageManagerService会去扫描系统中的一些特点目录，并解析其中的APK文件，然后，把获取的信息保存在Packages.xml文件中，当系统中的APK进行安装、删除、升级时，这个文件会被更新，它的路径位于/data/system/目录下。 通过Packages.xml文件可以获取APP的很多信息，一般在进行系统层开发时，会通过这个文件获取系统的信息。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统与安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity任务栈和启动模式]]></title>
    <url>%2F2018%2F01%2F24%2FActivity%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity任务栈一个APP通常有多个Activity，这些Activity通过栈结构保存，栈底是整个任务栈(Task)的发起者。 当一个APP启动时，如果系统中不存在该APP的任务栈，那么系统会为其创建一个任务栈，此后，这个APP启动的所有Activity都将在这个任务栈中被管理。需要注意的是，一个Task中的Activity可以来自不同的APP，同一个APP的Activity也可能存在于多个Task中。 在Task中，一个Activity启动另一个Activity时，新的Activity会被置于栈顶，并处于活动状态，而启动它的Activity依然保留在Task中，处于停止状态，当用户按返回键或者调用finish()方法时，系统会弹出栈顶的Activity，让后面的Activity从停止状态恢复到活动状态。以上是Task管理Activity的一般流程，当需要特殊处理时，就需要使用Activity的启动模式。 通过Manifest声明启动模式可以在AndroidManifest文件中，为Activity声明启动模式，一共能声明四种启动模式：standard、singleTop、singleTask、singleInstance，下面分别进行介绍。 standard默认的启动模式，每次启动Activity都会创建一个新的实例。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个Task，也可以位于不同的Task。 singleTop在singleTop模式下，启动一个Activity时，系统会判断当前Task中的栈顶Activity是否是要启动的Activity，如果是则不创建新的Activity，然后直接引用这个Activity，并调用其onNewIntent()方法；如果不是，则新建该Activity的实例，并将其置于栈顶。 因此，在同一个Task中，声明为singleTop模式的Activity也会存在多个实例，只不过这些实例不会相邻。 singleTask在singleTask模式下，只允许一个包含该Activity实例的Task存在。 singleTask模式下，Activity的启动方式与android:taskAffinity相关。当B是singleTask模式时，以A启动B来说： 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的Task，而是直接将B添加到A所在的Task；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其onNewIntent()方法。 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的Task，然后将B添加到新建的Task中；否则，将B所在Task中位于B之上的全部Activity都销毁，然后跳转到B中，并调用其onNewIntent()方法。 注意，当要启动的Activity在其它APP的Task中，会在返回栈(Back Stack)中将要启动Activity所在的Task置于当前Task之前，具体过程如下图所示： singleInstancesingleInstance模式下，任意时刻只允许存在唯一的Activity实例，而且该Activity所在的Task不能容纳除该Activity之外的其他Activity实例。其它Activity要启动该Activity，只需要打开这个分离的Task，并调用其onNewIntent()方法。 singleInstance模式经常用于需要与应用分离的界面，该模式的Activity实例即使启动其它Activity，这些Activity也会自动运行于另一个Task中。 singleInstance与singleTask一个明显区别是：singleTask所在的Task中能有其它的Activity，而singleInstance的Task中不能有其他Activity。 注意 如果ActivityA处于singleTask或singleInstance启动模式，当ActivityA通过startActivityForResult()方法启动另一个ActivityB时，将会直接返回RESULT_CANCELED，而不会等待ActivityB返回。因为Android系统不允许不同的Task之间直接传递数据，如果有这样的需要，只能通过onNewIntent()方法使用Intent传递。 通过Intent Flags声明启动模式除了在AndroidManifest文件中声明启动模式，还可以在启动Activity时，通过Intent中声明启动模式，这种Flag存在多个，下面介绍几个常用的启动Flag。 Intent.FLAG_ACTIVITY_NO_HISTORY 如果一个Activity是由该模式启动，当这个Activity再去启动其它Activity后，这个Activity就会被销毁，不会保留在Task中。 Intent.FLAG_ACTIVITY_SINGLE_TOP 这个Flag的效果与singleTop启动模式的效果相同。 Intent.FLAG_ACTIVITY_NEW_TASK 这个Flag的效果会受到taskAffinity属性影响，当B声明为该模式，以A启动B来说： 当A和B的taskAffinity相同时，与standard模式效果一样，每次都在当前Task新建B的实例。 当A和B的taskAffinity不同时，如果是首次启动，会新建一个Task，并将该Activity实例添加到Task中；如果再次启动，只会把该Activity所在Task置于前台，但是不会将该Activity置于栈顶，也不会调用其onNewIntent()方法。 该Flag通常用于其它组件启动一个Activity，因为其它组件不存在任何Task中，可能需要新建一个Task管理Activity实例，比如，使用Service启动Activity的场景。不过，当系统存在一个与其taskAffinity属性相同的Task时，这时就不会新建Task，而会直接在这个Task中新建Activity实例。 Intent.FLAG_ACTIVITY_CLEAR_TOP 如果要启动的Activity在当前的Task中，会销毁该Activity之上的所有其它Activity，从而将其置于栈顶；否则，在当前Task新建Activity实例。 不过，当要启动的Activity同时被声明为standard模式时，该Activity实例也会跟着其它Activity从栈顶弹出，然后重新创建该Activity。之所以这样，是因为standard模式下，总是创建新实例响应Intent。 总的来说，该模式只会清空栈顶，是通过新建实例还是通过onNewIntent()响应Intent启动消息，要看该Activity的其它启动模式。 通常将FLAG_ACTIVITY_CLEAR_TOP与FLAG_ACTIVITY_NEW_TASK混合使用，来定位存在于其他Task中的Activity实例，并将其置于栈顶。 Intent.FLAG_ACTIVITY_CLEAR_TASK 这个Flag用来清空Task，单独使用没有什么效果，通常与FLAG_ACTIVITY_NEW_TASK混合使用，这时会受到taskAffinity属性影响，当B声明为该模式，以A启动B来说： 当A和B的taskAffinity相同时，清空当前Task，并在当前Task中新建Activity实例。 当A和B的taskAffinity不同时，如果首次启动，新建Task，并在新Task新建Activity实例；如果再次启动，则清空实例所在的Task，再新建Activity。 注意 通过Intent Flags声明的启动模式能够覆盖通过Manifest文件声明的启动模式，因此，如果它们之间有冲突时，以Flags为准。 Task相关的属性除了用启动模式可以控制Task，还可以使用Task相关的属性控制Task，这些属性在Manifest文件的Activity节点声明，常用的有： 12345android:taskAffinity="string"android:allowTaskReparenting=["true" | "false"]android:alwaysRetainTaskState=["true" | "false"]android:clearTaskOnLaunch=["true" | "false"]android:finishOnTaskLaunch=["true" | "false"] 处理Affinity taskAffinity 介绍启动模式的时候已经提到过这个属性。每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。 allowTaskReparenting 是否允许activity重新指定Task，默认值是false。 如果一个Activity的allowTaskReparenting设置为true，它进入后台后，当一个和它有相同taskAffinity属性的Task进入前台时，它会重新宿主，进入到该前台的Task中。 清空任务栈一般来说，如果一个Task很长时间没有被用户使用，那么系统会清空这个Task中除了栈底Activity(Root Activity)之外的所有其它Activity，当用户重新进入这个Task时，只有Root Activity会被恢复。可以使用以下属性修改系统的这个默认行为。 alwaysRetainTaskState 默认值是false，如果将Root Activity的这个属性设置为true，那么该Activity所在的Task将不会被清空，即使很长时间不使用，这个Task中所有Activity的状态都会被保存。 clearTaskOnLaunch 默认值是false，如果将Root Activity的这个属性设置为true，不管用户什么时候离开该Activity所在的Task，系统会立刻清空这个Task中除了Root Activity之外的所有其它Activity，这个行为与alwaysRetainTaskState刚好相反。 finishOnTaskLaunch 默认值是false，如果某个Activity的finishOnTaskLaunch属性设置位true，只要你一离开该Activity所在的Task, 系统会立刻清除这个Activity, 不管这个Activity在Task的任何位置。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APP组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity状态和生命周期]]></title>
    <url>%2F2018%2F01%2F24%2FActivity%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Activity状态Activity有多种状态，并且在这些状态之间可以相互切换，从而控制自己的生命周期。 Resumed 这个状态的Activity处于Activity任务栈的最顶层，对用户可见，并且具有焦点，能与用户进行交互。 Paused 当Activity失去焦点，被一个非全屏的或者透明的Activity覆盖时，Activity就处于Paused状态。这时，Activity不能与用户进行交互，但是，其状态信息、成员变量等还被系统保持着，只有在系统内存将要耗尽时，才会被系统回收。 Stopped 当Activity被另一个Activity完全覆盖时会进入到Stopped状态，这时，Activity不可见，但也保持了所有的状态信息和成员变量，不过，相比Paused状态，系统会优先回收Stopped状态的Activity。 Destroyed 当Activity被系统回收或调用finish()方法后，Activity就处于Destroyed状态。 Activity生命周期下面以一张图来展示Activity生命周期（来自于Android官方文档）： Activity启动和销毁过程当系统启动Activity时，首先调用onCreate()之后，接着调用onStart()，然后调用onResume()进入Active/Running状态。 当系统销毁Activity时，如果是正常的销毁流程，会依次调用onPause()、onStop()和onDestory()，让Activity回到Destroyed状态；如果是系统回收内存资源进行的销毁，可能不会调用onDestory()甚至onStop()方法。 根据Activity启动和销毁过程，可以在相关方法中做一些特定操作： onCreate()：创建UI并加载数据，开启后台线程，初始化成员变量。 onDestory()：释放所有还保留着的系统资源，特别注意要关闭开启的后台线程（对象引用在Activity销毁时会自动清除，但是线程不会）。 Activity暂停和恢复过程Activity暂停时会调用onPause()方法，暂停结束后，会调用onResume()方法恢复Activity的状态。 根据Activity暂停和恢复过程，可以在相关方法中做一些特定操作： onPause()：暂停不需要在Paused状态运行的操作，比如Music、Video和Animation等，释放不需要在Paused状态使用的系统资源，比如Camera、Sensor、Receivers等；注意onPause()方法运行时间比较短，不要在里面做耗时操作，比如保存数据、请求网络、执行数据库事务等，不过，可以在onStop()方法中做这些耗时的操作。 onResume()：开启onPause()中暂停的操作，重新初始化onPause()中释放的资源。 Activity停止和重新启动过程当Activity处于Paused状态时，通常会有两种可能：调用onResume()方法恢复Activity；调用onStop()方法，停止Activity。 Activity停止后会处于后台，如果要重新启动，会调用onReStart()和onStart()方法。 根据Activity停止和重新启动过程，可以在相关方法中做一些特定操作： onStop()：释放几乎所有系统资源，因为大部分系统资源在Activity不可见时不会再使用，比如注销在onStart()中开启的，能够影响UI的Receivers；特别要注意释放那些可能造成内存泄露的系统资源，因为系统可能会在内存不足的时候跳过onDestory()方法销毁Activity；另外，还可以做一些耗时的关闭操作，比如保存用户的草稿数据到数据库中。 onReStart()：只有在从后台恢复到前台时才会调用onReStart()方法。 onStart()：初始化一些影响UI系统资源，比如注册能够影响UI的Receivers等。 Activity重新创建过程当Activity处于Paused或Stopped状态时，系统会因为内存不足回收Activity，这时，系统会将Activity的状态通过onSaveInstanceState()方法保存到Bundle对象中。当重新创建Activity时，Bundle对象会被传递到onRestoreInstanceState()和onCreate()方法中，这样就可以通过Bundle对象恢复Activity的状态。Android系统已经默认实现了系统控件的状态保存和恢复，不过只支持提供了android:id属性的View。 只有当前Activity离开前台，并且有被销毁的可能时，才会调用onSaveInstanceState()方法，如果调用finish()方法正常结束Activity的时候，该方法不会被调用。 另外，当系统配置改变时，Activity也会被重新创建，这时会调用onConfigurationChanged()方法。比如，在横竖屏切换时，系统会调用onSaveInstanceState()方法保存状态数据，然后，根据新的配置去恢复Activity的状态。 onSaveInstanceState()方法一般用来保存Activity的状态数据，如果要保存需要持久化的数据，应该在Activity在前台的时候，寻找合适的时机去保存，如果找不到合适的时机，可以在onStop()方法中进行。 onSaveInstanceState()方法会在onPause()方法之后、onStop()方法之前调用；onRestoreInstanceState()方法会在onStart()方法之后调用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APP组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴影和裁剪View及Drawable着色]]></title>
    <url>%2F2018%2F01%2F23%2F%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A3%81%E5%89%AAView%E5%8F%8ADrawable%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[阴影效果Android5.0以前，通常用X和Y两个属性表示View的平面位置，而在Android5.0中，增加了一个新属性Z，对应于垂直方向的位置，让View具有立体的效果，Z属性通过阴影的大小表示View的高低。 View的Z值有两部分组成： elevation：静态的，通过android:elevation或 View.setElevation()方法进行设置。 translationZ：动态的，用来实现动画效果，通过View.setTranslationZ()方法设置。 Z = elevation + translationZ 可以使用 ViewPropertyAnimator.z()和ViewPropertyAnimator.translationZ()方法实现elevation属性的动画效果； 还可以使用StateListAnimator声明elevation动画，比如Button按下的动画效果就是这样实现的。 自定义阴影轮廓View的背景形状决定了阴影的轮廓，所以，可以使用shape标签自定义形状作为View的background属性，从而自定义阴影的轮廓。 另外，还可以通过代码自定义View的阴影轮廓，一般需要以下几个步骤： 新建一个继承于ViewOutlineProvider的类； 重载getOutline()方法自定义轮廓； 使用View.setOutlineProvider()方法为View设置自定义的轮廓； 示例代码如下： 1234567ViewOutlineProvider outlineProvider = new ViewOutlineProvider() &#123; @Override public void getOutline(View view, Outline outline) &#123; outline.setRoundRect(0, 0, view.getWidth() + 10, view.getHeight() + 10, 30f); &#125;&#125;;view.setOutlineProvider(outlineProvider); 默认的ViewOutlineProvider类从View的background属性获取阴影轮廓，如果View不需要阴影效果，可以通过setOutlineProvider()将其设置为null。 裁剪View裁剪(Clip)View可以很容易改变View的形状，可以通过View.setClipToOutline()方法或android:clipToOutline属性将View裁剪至轮廓区域。 仅支持矩阵、椭圆和圆角矩阵的裁剪，这是由Outline.canClip()方法决定的。 如果要将视图的裁剪作用到Drawable背景对象上，首先使用View.setOutlineProvider()方法裁剪视图，然后调用View.setClipToOutline()方法，将裁剪作用到View的背景上。 裁剪视图操作比较耗费系统资源，所以，不要为裁剪视图的形状添加动画，如果要实现这样的动画效果，可以使用Reveal动画，具体可以参考MaterialDesign中的动画。 Drawable着色从Android5.0开始，可以为Drawable图片资源着色(Tint)，这样可以让图片资源与APP的主题匹配。 可以通过setTint()方法为BitmapDrawable、NinePatchDrawable以及VectorDrawable对象着色，也可以在XML布局文件中使用android:tint和android:tintMode属性设置着色的颜色和模式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Palette提取颜色]]></title>
    <url>%2F2018%2F01%2F23%2F%E4%BD%BF%E7%94%A8Palette%E6%8F%90%E5%8F%96%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[使用Palette提取当前图片的颜色，然后根据提取的颜色去设置当前主题的颜色，可以让主题动态适应当前页面的色调，做到整个APP颜色基调统一。 使用支持库使用Palette要配置对应的Support Library。 123456789android &#123; compileSdkVersion 24 ...&#125;dependencies &#123; ... implementation 'com.android.support:palette-v7:24.2.1'&#125; 创建Palette下面介绍如何根据一个Bitmap创建一个Palette。 生成Palette实例生成Palette有同步和异步两种方式，同步方式是在当前UI线程中操作，如果想优化UI性能，可以使用异步方式。 123456789101112131415// Generate palette synchronously and return itpublic Palette createPaletteSync(Bitmap bitmap) &#123; Palette p = Palette.from(bitmap).generate(); return p;&#125;// Generate palette asynchronously and use it on a different// thread using onGenerated()public void createPaletteAsync(Bitmap bitmap) &#123; Palette.from(bitmap).generate(new PaletteAsyncListener() &#123; public void onGenerated(Palette p) &#123; // Use generated instance &#125; &#125;);&#125; 自定义Palette生成Palette的时可以使用Palette.Builder对象自定义Palette，比如，可以过滤掉图片中黑色，或者只是用图片的上半部分生成Palette。 可以使用以下方法跳转Palette的大小和颜色： addFilter()：添加颜色过滤器； maximumColorCount()：设置生成Palette所使用的最大颜色位数，默认值是16位； setRegion()：设置生成Palette的图片区域； addTarget()：通过Target.Builder为Palette添加自定义的目标颜色配置； 获取颜色一般Palette会抽取下面6中特征颜色： Light Vibrant：充满活力的亮 Vibrant：充满活力的 Dark Vibrant：充满活力的黑 Light Muted：柔和的亮 Muted：柔和的 Dark Muted：柔和的黑 下面以一张图说明这些颜色特征： 具体获取某个特征颜色使用Palette.getXXXColor()方法，比如getMutedColor()。并不是所有的图片都会返回这些颜色特效，所以，在获取颜色时，还需要提供一个默认的返回颜色。 使用Swatch创建配色方案对于每个颜色特征，Palette都提供了一个Palette.Swatch对象用于生产对应的配色方案，获取Palette.Swatch模板代码如下： 12345678// Return a palette's vibrant swatch after checking that it existsprivate Palette.Swatch checkVibrantSwatch(Palette p) &#123; Palette.Swatch vibrant = p.getVibrantSwatch(); if (vibrant != null) &#123; return vibrant; &#125; // Throw error&#125; 注意要检查返回的Swatch是否为空，因为getXXXSwatch()方法没有像getXXXColor()方法那样设置默认的颜色。 获取了Swatch后，就可以根据Swatch创建主题的配色方案： 1234567891011121314// Set the background and text colors of a toolbar given a// bitmap image to matchpublic void setToolbarColor(Bitmap bitmap) &#123; // Generate the palette and get the vibrant swatch // See the createPaletteSync() and checkVibrantSwatch() methods // from the code snippets above Palette p = createPaletteSync(bitmap); Palette.Swatch vibrantSwatch = checkVibrantSwatch(p); // Set the toolbar background and text colors Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setBackgroundColor(vibrantSwatch.getRgb()); toolbar.setTitleTextColor(vibrantSwatch.getTitleTextColor());&#125; 下图是使用Vibrant特征颜色生成的Toolbar配色方法：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material主题]]></title>
    <url>%2F2018%2F01%2F23%2FMaterial%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Material主题能够提供以下功能： 自定义系统区域的颜色。比如可以修改Status Bar的颜色，使APP的颜色风格和系统的颜色风格保持统一。 为系统Widget提供触摸反馈动画。具体看以参考MaterialDesign中的动画。 提供Activity&amp;Fragment过渡动画。具体可以参考Activity&amp;Fragment过渡动画。 系统提供了以下默认的Material主题： @android:style/Theme.Material (dark version) @android:style/Theme.Material.Light (light version) @android:style/Theme.Material.Light.DarkActionBar Material Dark版本的样式如下图所示： Material Light版本的样式如下图所示： 自定义调色板继承Material主题后，可以在styles文件中自定义调色板(Color Palette)。 123456789101112&lt;resources&gt; &lt;!-- inherit from the material theme --&gt; &lt;style name="AppTheme" parent="android:Theme.Material"&gt; &lt;!-- Main theme colors --&gt; &lt;!-- your app branding color for the app bar --&gt; &lt;item name="android:colorPrimary"&gt;@color/primary&lt;/item&gt; &lt;!-- darker variant for the status bar and contextual app bars --&gt; &lt;item name="android:colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt; &lt;!-- theme UI controls like checkboxes and text fields --&gt; &lt;item name="android:colorAccent"&gt;@color/accent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 上面属性对应的APP界面的颜色如下图所示： 自定义StatusBar颜色在Material主题中，使用android:statusBarColor属性定义状态栏的颜色，默认情况下，android:statusBarColor使用android:colorPrimaryDark对应的颜色。还可以通过Window.setStatusBarColor()动态设置状态栏的颜色。 单个View的主题在XML布局文件中，可以为View使用android:theme属性指定特定的主题，这个主题修改只对View及其子View起作用，通常用于改变部分UI的主题颜色。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG和矢量动画]]></title>
    <url>%2F2018%2F01%2F23%2FSVG%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[在Android5.0(API Level 21)中开始支持SVG的绘制，SVG有以下几个特点： 可伸缩的矢量图形(Scalable Vector Graphics) 使用XML格式定义图形 图形在放大或改变尺寸时，图像不会失真 基于W3C标准，与Web中的矢量图通用 Android中可以使用&#60;path&#62;标签绘制SVG，相比Bitmap，SVG最大的优点是缩放不会失真，这样不需要为不同的分辨率设计多套图标，从而缩小APK的体积。 path标签和SVG指令使用&#60;path&#62;标签创建SVG，类似于用指令的方式控制一只画笔绘制图像。&#60;path&#62;标签支持的SVG指令有： M = moveto(M X,Y)：将画笔移动到指定的坐标位置，但未发生绘制 L = lineto(L X,Y)：画直线到指定的坐标位置 H = horizontal lineto(H X)：画水平线到指定的X坐标位置 V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置 C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝塞尔曲线 S = smooth curveto(S X2,Y2,ENDX,ENDY)：三次贝塞尔曲线，一般跟在C或S命令后面 Q = quadratic curveto(Q X,Y,ENDX,ENDY)：二次贝塞尔曲线 T = smooth quadratic curveto(T ENDX,ENDY)：二次贝塞尔曲线，一般跟在Q或T命令后面 A = elliptical arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线 Z = closepath()：关闭路径 使用以上指令时，需要注意： 坐标轴为以(0,0)为中心，X轴水平向右，Y轴水平向下。 所有指令大小写均可。大写绝对定位，参照全局坐标系；小写相对定位，参照父容器坐标系。 指令和数据间的空格可以省略。 同一指令连续出现多次可以只声明一次。 指令的详细解释可以参考MDN文档。 SVG指令的写法固定，并且比较复杂，一般可以通过SVG编辑器来绘制SVG图像，然后将其转换为SVG代码。常用的SVG编辑器有在线的Method Draw和离线的Inkscape。 SVG绘制在Android中，可以使用VectorDrawable创建基于XML的SVG。在XML中创建SVG时，path标签是SVG的最小单位，而group标签将不同的path标签进行组合，最终形成一棵SVG树。 下面是一个“心形”矢量图的例子： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- res/drawable/heart.xml --&gt;&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" &lt;!-- SVG的实际大小 --&gt; android:width="256dp" android:height="256dp" &lt;!-- SVG的划分比例，绘制path时使用的参数就是相对这两个值进行换算的 --&gt; android:viewportHeight="32" android:viewportWidth="32"&gt; &lt;group android:name="heart" android:rotation="0"&gt; &lt;!-- draw a path --&gt; &lt;path android:fillColor="#8fff" android:pathData="M20.5,9.5 c-1.955,0,-3.83,1.268,-4.5,3 c-0.67,-1.732,-2.547,-3,-4.5,-3 C8.957,9.5,7,11.432,7,14 c0,3.53,3.793,6.257,9,11.5 c5.207,-5.242,9,-7.97,9,-11.5 C25,11.432,23.043,9.5,20.5,9.5z"/&gt; &lt;/group&gt;&lt;/vector&gt; 矢量动画在Android中，可以使用AnimatedVectorDrawable实现矢量动画。AnimatedVectorDrawable的主要功能是将静态的VectorDrawable和动态的ObjectAnimator连接起来，产生动画效果。因此，矢量动画最终还是通过属性动画实现的。 使用矢量动画一般有以下几个步骤： 在res/drawable/路径下利用vector标签定义要进行动画的矢量图 在res/drawable/路径下利用animated-vector标签定义矢量动画 在res/anim/路径下利用objectAnimator标签定义矢量动画使用的属性动画 矢量图中能够产生动画效果的元素是path和group元素，在定义矢量动画时，需要进行动画的元素必须要定义唯一的android:name属性。 矢量动画的具体示例如下： 定义矢量图： 1234567891011121314151617&lt;!-- res/drawable/vectordrawable.xml --&gt;&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="64dp" android:height="64dp" android:viewportHeight="600" android:viewportWidth="600"&gt; &lt;group android:name="rotationGroup" android:pivotX="300.0" android:pivotY="300.0" android:rotation="45.0"&gt; &lt;path android:name="v" android:fillColor="#000000" android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z"/&gt; &lt;/group&gt;&lt;/vector&gt; 根据name属性定义矢量动画： 12345678910&lt;!-- res/drawable/animvectordrawable.xml --&gt;&lt;animated-vector xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/vectordrawable" &gt; &lt;target android:name="rotationGroup" android:animation="@anim/rotation"/&gt; &lt;target android:name="v" android:animation="@anim/path_morph"/&gt;&lt;/animated-vector&gt; 定义矢量动画对应的属性动画： 123456&lt;!-- res/animator/rotation.xml --&gt;&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="6000" android:propertyName="rotation" android:valueFrom="0" android:valueTo="360"/&gt; 12345678910&lt;!-- res/animator/path_morph.xml --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;objectAnimator android:duration="3000" android:propertyName="pathData" android:valueFrom="M300,70 l 0,-70 70,70 0,0 -70,70z" android:valueTo="M300,70 l 0,-70 70,0 0,140 -70,0z" android:valueType="pathType"/&gt;&lt;/set&gt; 需要注意的是，对pathData属性进行动画时，valueTo和valueFrom值必须要兼容，即要有同样数量的命令，并且命令的参数数量要相同。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign中的动画]]></title>
    <url>%2F2018%2F01%2F22%2FMaterialDesign%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[在Android5.0(API Level 21)以后，可以使用Material Design(MD)中的动画可以给用户提供触摸反馈和一致性交互体验。Activity&amp;Fragment过渡动画就是MD中动画的一种，接下来介绍MD中其它类型的动画。 Ripple AnimationMD大量使用了Ripple效果，即点击后View后，产生波纹效果，这个效果主要用于触摸反馈。 可以通过如下代码设置View的波纹背景： 12345// 有边界波纹android:background="?android:attr/selectableItemBackground"// 无边界波纹android:foreground="?android:attr/selectableItemBackgroundBorderless" 如果要修改默认波纹的颜色，可以使用主题中android:colorControlHighlight属性进行设置。 还可以在XML文件中，直接创建Ripple效果的背景资源： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- res/drawable/ripple_sample --&gt;&lt;ripple xmlns:android="http://schemas.android.com/apk/res/android" android:color="@color/colorPrimary"&gt; &lt;item&gt; &lt;shape android:shape="oval"&gt; &lt;solid android:color="@color/colorAccent"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/ripple&gt; Reveal AnimationReveal动画为显示或隐藏一组UI元素提供视觉一致性体验，具体表现为一个View以圆的形式展开。使用ViewAnimationUtils.createCircularReveal()方法创建Reveal动画。 展现隐藏的View： 1234567891011121314151617// previously invisible viewView myView = findViewById(R.id.my_view);// get the center for the clipping circleint cx = myView.getWidth() / 2;int cy = myView.getHeight() / 2;// get the final radius for the clipping circlefloat finalRadius = (float) Math.hypot(cx, cy);// create the animator for this view (the start radius is zero)Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0, finalRadius);// make the view visible and start the animationmyView.setVisibility(View.VISIBLE);anim.start(); 隐藏可见的View： 12345678910111213141516171819202122232425// previously visible viewfinal View myView = findViewById(R.id.my_view);// get the center for the clipping circleint cx = myView.getWidth() / 2;int cy = myView.getHeight() / 2;// get the initial radius for the clipping circlefloat initialRadius = (float) Math.hypot(cx, cy);// create the animation (the final radius is zero)Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0);// make the view invisible when the animation is doneanim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); myView.setVisibility(View.INVISIBLE); &#125;&#125;);// start the animationanim.start(); View State Changes Animation在Android5.0以后，可以为View的状态改变设置一个状态切换动画。 StateListAnimatorStateListAnimator作为视图改变时的动画效果时，通常使用Selector进行设置。示例代码如下： 1234567891011121314151617181920212223&lt;!-- animate the translationZ property of a view when pressed --&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="translationZ" android:duration="@android:integer/config_shortAnimTime" android:valueTo="2dp" android:valueType="floatType"/&gt; &lt;!-- you could have other objectAnimator elements here for "x" and "y", or other properties --&gt; &lt;/set&gt; &lt;/item&gt; &lt;item android:state_enabled="true" android:state_pressed="false" android:state_focused="true"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="translationZ" android:duration="100" android:valueTo="0" android:valueType="floatType"/&gt; &lt;/set&gt; &lt;/item&gt;&lt;/selector&gt; 定义好对应的XML文件后，将其作为View的android:stateListAnimator属性，就可以使用对应的动画。 同样的，可以在代码中调用AnimatorInflater.loadStateListAnimator()方法加载XML文件，然后通过View.setStateListAnimator()方法将动画设置到对应的View上。 当时用Material主题时，Button默认带有translationZ的动画，如果不需要这个动画，可以将android:stateListAnimator属性设置为@null。 AnimatedStateListDrawableAnimatedStateListDrawable可以为View的状态切换设置可绘制动画，Android5.0中很多系统组件就使用了这样的的动画效果，具体可以通过animated-selector进行定义，示例代码如下： 12345678910111213141516171819202122&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;&lt;animated-selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- provide a different drawable for each state--&gt; &lt;item android:id="@+id/pressed" android:drawable="@drawable/drawableP" android:state_pressed="true"/&gt; &lt;item android:id="@+id/focused" android:drawable="@drawable/drawableF" android:state_focused="true"/&gt; &lt;item android:id="@id/default" android:drawable="@drawable/drawableD"/&gt; &lt;!-- specify a transition --&gt; &lt;transition android:fromId="@+id/default" android:toId="@+id/pressed"&gt; &lt;animation-list&gt; &lt;item android:duration="15" android:drawable="@drawable/dt1"/&gt; &lt;item android:duration="15" android:drawable="@drawable/dt2"/&gt; ... &lt;/animation-list&gt; &lt;/transition&gt; ...&lt;/animated-selector&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过渡动画框架]]></title>
    <url>%2F2018%2F01%2F22%2F%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[当用户通过键盘输入或者触发其他事件时界面需要做出变化，比如，某个Activity包含一个搜索框，当用户输入数据并提交的时候，Activity会隐藏搜索框同时显示搜索的结果。 在这种应用场景(Scenes)下，可以通过在不同的View树上运行动画，来提供连续的视觉效果。这些动画不仅仅响应了用户的操作，也帮助用户学习应用是如何工作的。 Android的过渡动画框架(Transitions Framework)可以方便的实现两个View树之间的动画。它通过动态的改变View的属性从而达到动画变换的效果。Android系统内置了常用的动画效果，也可以自定义过渡动画和过渡生命周期。 在Android4.4之前可以使用布局动画实现简单过渡动画效果，但是对于复杂的场景，布局动画使用起来不太方便，所以，Android4.4引入了过渡动画框架来方便实现这样的应用场景。 过渡动画的本质还是属性动画，只不过是对属性动画做了一层封装，目的是方便开发者实现ViewGroup的过渡动画效果。 场景和过渡动画过渡动画框架可以在两个不同的View树之间运行过渡动画，它对View树中的所有View执行一个或者多个动画，框架的有如下特性： GroupView级别的动画：对View树中的所有View执行动画 基于变化的动画：动画的运行是基于View属性的开始值和结束值 内置动画：包含了一些预置的动画，比如淡入淡出和移动 支持资源文件：可以通过布局文件中加载View树和内置动画 声明周期回调：通过回调可以控制动画的执行过程 概述过渡动画框架和动画的关系如下所示： Transitions框架和View动画是平行关系。Transitions框架主要用于存储View树的状态，在切换View树时执行定义的动画，从而实现过渡效果。 Transitions框架提供了抽象的Scenes、Transition以及TransitionManagers。使用过程中，首先，为执行动画的View树创建初始Scene；然后，为动画创建Transition；最后，使用TransitionManager对象启动动画，并传入创建的Transition和结束Scene。 场景(Scenes)Scene存储了View树的状态，即View树中所有View的属性值，这样就可以通过改变属性值，从当前Scene变换到指定的Scene。 创建Scene可以通过Layout文件或者在代码中使用GroupView对象。通过代码创建Scene，用于动态生成View树，或者在运行时改变View树。 通常情况下，并不需要创建开始Scene。当使用Transition时，系统会使用上一个Transition的结束Scene作为下一个Transition的开始Scene；如果之前没有使用过Transition，系统会收集View树的当前状态作为开始Scene。 可以定义Scene变化的Action。比如，在Scene变化后，清除View的设置。 Scene除了存储View树的属性值，同时也存储了View树的父视图引用，这个引用称为Scene Root，Scene的变换和动画都发生在Scene Root中。 过渡动画(Transition)在Transitions框架中，创建了一系列的帧去描述View树从开始Scene到结束Scene的变化。动画的信息都存储在Transition对象中，可以使用TransitionManager对象为动画指定一个Transition。Transition可以用于两个不同的Scene，或者同一个Scene的不同状态。 系统内置了一组常用的Transition，比如淡入淡出，缩放等。可以根据框架中提供的API自定义一个Transition来创建想要动画的效果。也可以组合自定义或者内置Transition，作为一个Transition集合，达到不同的动画效果。 系统会监听Transition整个生命周期，这一点和Activity相似。每个重要的生命周期状态，都会执行一个回调函数，在函数中你可以根据不同的状态调整用户界面。 限制(Limitation) 应用于SurfaceView的动画显示会有问题。SurfaceView的更新通过非UI线程，它的更新与动画中的其他View可能会不同步。 用于TextureView的某些特定Transition类型会产生一些不同与期望的动画效果。 继承于AdapterView的类，例如ListView，管理子View的方式与Transition框架不兼容。如果将动画应用于这些View，会出问题。 TextView执行缩放动画时，在动画完成前，文本会被放置到新得到位置。为了避免此问题，不要在包含文本的TextView中使用缩放的动画。 创建场景Transitions框架可以在开始和结束的Scene中执行过渡动画。开始Scene通常由用户界面的当前状态决定。结束Scene，可以通过资源文件或者使用代码创建。 注意：单个View树的变换可以不使用Scene，具体使用在下一节介绍。 使用XML文件创建Scene通过资源文件可以直接创建Scene对象。当View树不会变化时可以使用这种方式。生成的Scene代表当你创建Scene实例时View树的状态。如果改变了View树，必须重新创建Scene。创建的Scene包含整个资源文件，不允许从部分资源文件中创建Scene。 从布局文件中创建Scene，首先要从布局文件中获取ViewGroup类型Scene Root对象，接着调用Scene.getSceneForLayout()，参数为Scene Root和布局文件中作为Scene的View树的资源ID。 为Scene定义Layout下面介绍通过相同的Scene Root元素创建两个不同的Scene。通过代码同样可以看到，只需要加载两个不相关的Scene对象，并不需要定义他们的依赖关系。 示例中的布局为： Activity的主布局文件包含一个TextView和一个子布局 一个相对布局中包含了两个TextView作为第一个Scene 一个相对布局同样包含两个TextView但是顺序不同作为第二个Scene 示例中所有的动画发生在Activity主布局文件的子布局中，而主布局文件中的TextView是不变的。 Activity主布局文件为： 123456789101112&lt;!-- res/layout/activity_main.xml --&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/master_layout"&gt; &lt;TextView android:id="@+id/title" ... android:text="Title"/&gt; &lt;FrameLayout android:id="@+id/scene_root"&gt; &lt;include layout="@layout/a_scene" /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 该布局文件中定义了一个TextView和一个作为Scene Root的子布局。第一个Scene被包含在主布局文件中。App把它作为应用的初始界面，Scene也会把整个子布局加载起来，因为Transition框架是不能够加载部分布局到Scene中。 Scene 1的布局定义如下： 123456789101112&lt;!-- res/layout/a_scene.xml --&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/scene_container" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/text_view1 android:text="Text Line 1" /&gt; &lt;TextView android:id="@+id/text_view2 android:text="Text Line 2" /&gt;&lt;/RelativeLayout&gt; Scene 2包含相同的两个TextView（一样的资源ID），但是他们的顺序和Scene 1不一样： 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/scene_container" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/text_view2 android:text="Text Line 2" /&gt; &lt;TextView android:id="@+id/text_view1 android:text="Text Line 1" /&gt;&lt;/RelativeLayout&gt; 从Layout文件中生成Scene12345678910Scene mAScene;Scene mAnotherScene;// Create the scene root for the scenes in this appmSceneRoot = (ViewGroup) findViewById(R.id.scene_root);// Create the scenesmAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this);mAnotherScene = Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this); 这样，应用就包含了两个基于View树的Scene对象。两个Scene使用同样Scene Root，它通过activity_main.xml中的FrameLayout元素定义。 使用Java代码创建Scene在代码中通过ViewGroup对象同样可以创建Scene实例。当你在代码中需要修改View树的结构或者动态的生成View树时，可以使用这种方式。 在代码中利用View树创建Scene，使用Scene(sceneRoot, viewHierarchy)构造函数。这个构造函数和Scene.getSceneForLayout()有同样的效果。 1234567891011Scene mScene;// Obtain the scene root elementmSceneRoot = (ViewGroup) mSomeLayoutElement;// Obtain the view hierarchy to add as a child of// the scene root when this scene is enteredmViewHierarchy = (ViewGroup) someOtherLayoutElement;// Create a scenemScene = new Scene(mSceneRoot, mViewHierarchy); 创建Scene Actions当Scene进入和退出时，系统允许自定义Scene Action。通常情况下自定义Action是没有必要的，因为系统会自动处理Scene间的变换。 Scene Action用于下面几个情况： 执行动画的View不在Scene的View树里，其执行动画的时机可能在Scene开始或者结束时。 Transitions框架不支持的View，比如ListView。 可以将Scene Action定义成Runnable对象，然后作为参数调用Scene.setExitAction()和Scene.setEnterAction()方法。在Transition动画运行之前，开始Scene会调用setExitAction()方法，在Transition动画运行之后，结束Scene会调用setEnterAction()方法。 注意：不要在开始Scene和结束Scene中的View之间使用Scene Action传递数据。因为结束View树直到动画结束才会被初始化。 使用过渡动画在Transitions框架中，动画创建了一系列的帧描述View树从开始Scene到结束Scene之间的变化。这些变化在Transition框架中使用Transition对象来表示，所有动画的信息都包含在其中。通过TransitionManager对象启动动画，具体使用时，需要传入Transition对象和结束Scene。 创建Transition内置Transition对象的创建方式有两种，可以资源文件定义，也可以直接用代码创建。 系统提供的内置Transition类型如下所示： Class Tag Effect AutoTransition &#60;autoTransition/&#62; Default transition. Fade out, move and resize, and fade in views, in that order. Fade &#60;fade/&#62; fade_in fades in views; fade_out fades out views; fade_in_out (default) does a fade_out followed by a fade_in. ChangeBounds &#60;changeBounds/&#62; Moves and resizes views. 通过资源文件中创建Transition在资源文件中创建Transition的好处是当你需要修改Transition的定义的时候不用修改Activity中的代码，另一个好处就是将复杂的Transition定义和代码分离。 创建Transition 12&lt;!-- res/transition/fade_transition.xml --&gt;&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" /&gt; 从资源文件中获取Transition对象 123Transition mFadeTransition = TransitionInflater.from(this). inflateTransition(R.transition.fade_transition); 通过代码中创建Transition这种方式的好处是可以动态的创建Transition对象（如果你在代码中需要修改用户界面），而且创建内置Transition需要很少的参数。 1Transition mFadeTransition = new Fade(); 使用TransitionTransition通常用于切换不同的View树，来响应用户操作等事件。例如：当用户输入搜索关键字并点击搜索按钮，应用切换到搜索结果布局，此时搜索界面执行淡出效果，搜索结果界面执行淡入效果。 在Activity中利用Transition切换Scene，通过调用静态方法TransitionManager.go()，并传入结束的Scene和代表动画效果的Transition实例，如下所示： 1TransitionManager.go(mEndingScene, mFadeTransition); 当运行Transition实例指定的动画时，系统会将Scene Root中的View树切换成结束Scene中的View树。上一个Transition结束的Scene作为开始的Scene，如果不存在上一个Transition，用户界面的当前状态就是开始Scene。 如果没有指定Transition实例，TransitionManager会使用AutoTransition对象，它会执行大多数情况下合理的动画效果。 选择特定的Target View默认情况下系统对开始和结束Scene中所有的View执行动画。有些时候，只希望仅仅让Scene中的一个子View运行动画。例如，系统不支持ListView对象的动画，在Transition的过程中就必须排除ListView对象。Transition框架允许只让某个特定的View运行动画。 被选定运行动画的View叫Target。你只能选择Scene中View树的子View作为Target。 Target是被保存在列表中，从Target list中删除一个或者多个Target，调用removeTarget()方法，该方法必须在执行动画之前调用。调用addTarget()方法添加View到Target list中。 定义Transition集合在Transition系统中可以绑定一系列内置或者自定义的动画到Transition集合中。 123456&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android" android:transitionOrdering="sequential"&gt; &lt;fade android:fadingMode="fade_out" /&gt; &lt;changeBounds /&gt; &lt;fade android:fadingMode="fade_in" /&gt;&lt;/transitionSet&gt; 通过在Activity中调用TransitionInflater.from()方法在代码中获取XML声明的TransitionSet对象。TransitionSet继承自Transition类，所以TransitionManager可以和使用Transition对象一样使用TransitionSet。 不使用Scene的情况下使用Transition改变用户界面不仅仅只有通过切换View树这一种方式，还可以在当前View树中通过添加，修改，删除子View修改界面。 如果供选择的两个View树有相似的结构，则可以选择使用这种方式。不必为了用户界面的微小差别而创建和维护两个不同的资源文件，可以在资源文件中定义View树然后在代码中修改它的结构。 如果只是在一个View树改动，则不必创建Scene。而是使用delayed transition的方式在一个View树的两个状态间创建和使用Transition。Transition框架记录View树的当前状态和View的变动，在系统重绘用户界面时对View的变化执行Transition动画。 在单一的View树中创建delayed transition，遵循以下步骤： 当事件触发了Transition，调用TransitionManager.beginDelayedTransition()方法，传入待执行动画View的父View和Transition。系统会保存View的当前状态和属性值。 根据Transition改变子View。系统会记录哪些子View的哪些属性被改变了。 当系统根据你的变化重绘用户界面时，会在初始状态和最终状态间执行动画。 下面的代码演示了如何使用delayed transition添加一个TextView到一个View树中： View树对应的资源文件 12345678910111213&lt;!-- res/layout/activity_main.xml --&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/mainLayout" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;EditText android:id="@+id/inputText" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; ...&lt;/RelativeLayout&gt; 添加TextView时执行动画 123456789101112131415161718192021222324252627/* MainActivity.java */private TextView mLabelText;private Fade mFade;private ViewGroup mRootView;...// Load the layoutthis.setContentView(R.layout.activity_main);...// Create a new TextView and set some View propertiesmLabelText = new TextView();mLabelText.setText("Label").setId("1");// Get the root view and create a transitionmRootView = (ViewGroup) findViewById(R.id.mainLayout);mFade = new Fade(IN);// Start recording changes to the view hierarchyTransitionManager.beginDelayedTransition(mRootView, mFade);// Add the new TextView to the view hierarchymRootView.addView(mLabelText);// When the system redraws the screen to show this update,// the framework will animate the addition as a fade in 定义Transition的生命周期回调Transition的生命周期和Activity相似。它代表从调用TransitionManager.go()方法到动画运行结束过程中的状态。重要的生命状态，系统会执行TransitionListener中的回调方法。 Transition的生命周期回调是非常有用的，比如，在Scene变化过程中将某个View的属性值从开始View树中复制到结束View树中。由于结束View树直到动画结束才会被初始化，所以简单的复制值会出问题。这种情况下，可以先将值存储在一个变量中，然后当动画结束后再复制它到结束View树中。获取动画结束事件可以在Activity中实现TransitionListener.onTransitionEnd()回调方法。 参考资料 Animating Views Using Scenes and Transitions]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity&Fragment过渡动画]]></title>
    <url>%2F2018%2F01%2F18%2FActivity%26Fragment%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[在Android5.0以前，切换Activity或者Fragment时可以通过Activity#overridePendingTransition()或FragmentTransaction#setCustomAnimation()方法增加过场动画，不过效果比较单调，并且只能针对页面中的所有元素，具体使用可参考Android转场动画。 在Android5.0以后，切换Activity或者Fragment时使用过渡动画(Transition Animation)，它是Material Design的一部分，能为页面元素在不同状态之间的移动和转换提供视觉切换效果。过渡动画不但能够提供更加丰富的切换效果，并且在进行切换时，排除特定的页面元素不参与动画，以及对两个页面的共享元素设置动画。 Android5.0提供了三种过渡类型： Enter Transition：进入过渡，决定Activity&amp;Fragment中的视图如何进入屏幕； Exit Transition：退出过渡，决定Activity&amp;Fragment中的视图如何退出屏幕； Shared Elements Transition：共享元素过渡，决定两个Activity&amp;Fragment之间的共享视图元素如何转换； 进入和退出效果包括： explode：分解，视图从屏幕中间进入或退出； slide：滑动，视图从屏幕边缘进入或退出； fade：淡出，通过改变视图的透明度，控制视图显示或消失； 共享元素效果包括： changeBounds：改变目标视图的布局边界； changeClipBounds：裁剪目标视图边界； changeTransform：改变目标视图的缩放比例和旋转角度； changeImageTransform：改变目标图片的大小和缩放比例； Enter/Exit Transition 确定了非共享元素如何 进入/退出 页面视图；Shared Elements Transition 确定了两个页面共享元素的动画效果。 Activity进入和退出动画通过XML文件设置 定义Transition 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- res/transition/transition_explode.xml --&gt;&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;explode xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000" android:interpolator="@android:interpolator/bounce"/&gt; &lt;!-- 顶部的状态栏以及底部的导航栏不执行动画 --&gt; &lt;targets&gt; &lt;target android:excludeId="@android:id/statusBarBackground"/&gt; &lt;target android:excludeId="@android:id/navigationBarBackground"/&gt; &lt;/targets&gt;&lt;/transitionSet&gt; 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- res/transition/transition_fade.xml --&gt;&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000" android:interpolator="@android:interpolator/bounce"/&gt; 设置Transition 1234567891011121314151617181920&lt;style name="BaseAppTheme" parent="android:Theme.Material"&gt; &lt;!-- enable activity transitions --&gt; &lt;item name="android:windowActivityTransitions"&gt;true&lt;/item&gt; &lt;!-- transitions --&gt; &lt;!-- 启动新Activity ，当前页面退出的动画 --&gt; &lt;item name="android:windowExitTransition"&gt;@transition/transition_explode&lt;/item&gt; &lt;!-- Activity首次进入显示的动画 --&gt; &lt;item name="android:windowEnterTransition"&gt;@transition/transition_fade&lt;/item&gt; &lt;!-- 调用finishAfterTransition()时，当前页面返回退出的动画 --&gt; &lt;!-- 如果没有定Return动画，Return时会使用“反Enter”动画 --&gt; &lt;item name="android:windowReturnTransition"&gt;@transition/transition_explode&lt;/item&gt; &lt;!-- 从其它页面返回，重新进入的动画，即第二次进入，可以和首次进入不一样 --&gt; &lt;!-- 如果没有定Reenter动画，Reenter时会使用“反Exit”动画 --&gt; &lt;item name="android:windowReenterTransition"&gt;@transition/transition_fade&lt;/item&gt; &lt;!-- 是否覆盖执行，可以理解成前后两个页面的Transition是同步执行还是顺序执行 --&gt; &lt;item name="android:windowAllowEnterTransitionOverlap"&gt;false&lt;/item&gt; &lt;item name="android:windowAllowReturnTransitionOverlap"&gt;false&lt;/item&gt;&lt;/style&gt; 通过Java代码设置 定义Transition 12345678910Explode explode = new Explode();explode.setDuration(2000);explode.setInterpolator(new BounceInterpolator());// 顶部的状态栏以及底部的导航栏不执行动画explode.excludeTarget(android.R.id.navigationBarBackground, true);explode.excludeTarget(android.R.id.statusBarBackground, true);Fade fade = new Fade();fade.setDuration(2000);fade.setInterpolator(new BounceInterpolator()); 设置Transition 在第一个页面中： 12345678910// inside your activity (if you did not enable transitions in your theme)getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);// set transitiongetWindow().setExitTransition(explode);getWindow().setReenterTransition(fade);// set overlapgetWindow().setAllowEnterTransitionOverlap(false);getWindow().setAllowReturnTransitionOverlap(false); 在第二个页面中： 12345678910// inside your activity (if you did not enable transitions in your theme)getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);// set transitiongetWindow().setEnterTransition(fade);getWindow().setReturnTransition(explode);// set overlapgetWindow().setAllowEnterTransitionOverlap(false);getWindow().setAllowReturnTransitionOverlap(false); 这样可以达到上面XML文件同样的效果，可以看出，使用代码方式相对比较繁琐，不过，代码方式可以为Transition提供更多属性，比如为Transition添加Listener等。 为Activity添加动画123// 第一个页面启动第二个页面ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(this);startActivity(intent, options.toBundle()); 123// 第二个页面从第一个页面返回// 按系统Back键时，会默认调用这个方法finishAfterTransition(); Activity共享元素动画共享元素的过渡动画用于给两个Activity中共享的View添加过渡效果，其使用和进入和退出过的渡动画类似，这里只介绍XML方式添加共享元素过渡动画。 定义Transition 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- res/transition/transition_change_bounds.xml --&gt;&lt;changeBounds xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000" android:interpolator="@android:interpolator/bounce"/&gt; 设置Transition 123456789101112131415&lt;style name="BaseAppTheme" parent="android:Theme.Material"&gt; &lt;!-- Enable Activity transitions in your theme --&gt; &lt;item name="android:windowActivityTransitions"&gt;true&lt;/item&gt; &lt;!-- specify shared element transitions --&gt; &lt;item name="android:windowSharedElementEnterTransition"&gt; @transition/transition_change_bounds &lt;/item&gt; &lt;item name="android:windowSharedElementExitTransition"&gt; @transition/transition_change_bounds &lt;/item&gt; &lt;!-- 共享元素Enter和Exit的Transition动画是否叠加执行 --&gt; &lt;item name="android:windowSharedElementsUseOverlay"&gt;true&lt;/item&gt;&lt;/style&gt; 为两个Activity的layout文件中的共享View添加同样android:transitionName属性 添加过渡动画 1234ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(this, Pair.create(view1, "shared_elements1"), Pair.create(view2, "shared_elements2"));startActivity(intent, options.toBundle()); Fragment过渡动画Fragment的过渡动画使用与Activity基本相同，但是会有一些小区别： 进入和退出效果过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。 共享元素的过渡动画应该在Fragment的.java文件中调用对应的方法或者在xml属性声明里设置。 Activity的Transition是通过调用startActivity()和finishAfterTransition()直接启动的，Fragment的Transition是在Fragment被add, remove, attach, detach, show或hidden后由FragmentTransaction自动启动的。 共享元素应该在transaction(事务)提交前调用addSharedElement(View, String)方法，声明为FragmentTransaction的一部分。 参考资料 Getting Started with Activity &amp; Fragment Transitions]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局动画]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Android动画机制提供了视图动画、属性动画和可绘制动画，这些动画都是针对单个View对象的，而布局动画(Layout Animation)作用的对象是ViewGroup，它可以在ViewGroup布局子View时，为子View添加相应的动画效果。 LayoutAnimationLayoutAnimation在API Level 1就已经提供了，它对ViewGroup所有的子View都产生动画效果。LayoutAnimation有XML文件和Java代码两种使用方式。 XML文件 定义layoutAnimation 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--animation: 指定动画资源animation, 注意不能使用animator.animationOrder: 动画执行顺序, normal(正序)、reverse(倒序)、random(随机)。delay: ViewGroup中单个子View动画的开始延时, 取值是android:animation所指定动画时长的倍数, 可以是float, 也可以是百分数, 默认0.5; 比如anim_rotation中定义的动画时长是500ms, 这里delay=1, 那么在上一个子View的动画执行之后延时500ms执行下一个子View的动画。--&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:animation="@anim/anim_rotation" android:animationOrder="normal" android:delay="0.5"/&gt; 在ViewGroup中加载动画 1android:layoutAnimation="@anim/layout_animation" Java代码123456789// 加载动画Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_rotation);// 设置布局动画LayoutAnimationController animationController = new LayoutAnimationController(animation, 1f);animationController.setInterpolator(new AccelerateDecelerateInterpolator());animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);// 加载布局动画viewGroup.setLayoutAnimation(animationController); 注意 系统提供了gridLayoutAnimation用于给Gridview设置布局动画，对应的XML标签为 gridLayoutAnimation，对应的类为GridLayoutAnimationController； LayoutAnimation只在在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的； LayoutTransitionLayoutTransition是API Level 11才出现的，其动画效果只有当ViewGroup添加、删除、隐藏、显示子View的时候才会展示出来，所以，LayoutTransition是一个布局改变动画。LayoutTransition也有XML文件和Java代码两种使用方式。 XML文件使用XML文件只能使用系统默认的LayoutTransition动画效果。 12&lt;!-- 使用系统默认的LayoutTransition动画 --&gt;android:animateLayoutChanges="true" Java代码使用Java代码可以自定义LayoutTransition动画效果 123456// 使用自定义LayoutTransition动画LayoutTransition transition = new LayoutTransition();Animator animator = AnimatorInflater.loadAnimator(this, R.animator.animator_rotation);transition.setAnimator(LayoutTransition.APPEARING, animator);transition.setDuration(2000);viewGroup.setLayoutTransition(transition); 设置自定义动画时，有以下几种方式： LayoutTransition.APPEARING：View添加时的动画。 LayoutTransition.CHANGE_APPEARING：View添加导致布局改变时整个布局容器的动画。 LayoutTransition.DISAPPEARING：View消失时的动画。 LayoutTransition.CHANGE_DISAPPEARING：View消失导致布局容改变时整个布局容器的动画。 LayoutTransition.CHANGE：不是由于View出现或消失造成改变的时候整个布局容器的动画。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可绘制动画]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%8F%AF%E7%BB%98%E5%88%B6%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[可绘制动画(Drawable Animation)可以按顺序加载一系列的Drawable资源产生动画效果，它的原理类似于播放动画片，一帧一帧展示图片，具体播放使用AnimationDrawable类。 使用可绘制动画时，首先需要定义其XML文件： 123456&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@drawable/rocket_thrust1" android:duration="200" /&gt; &lt;item android:drawable="@drawable/rocket_thrust2" android:duration="200" /&gt; &lt;item android:drawable="@drawable/rocket_thrust3" android:duration="200" /&gt;&lt;/animation-list&gt; 注意要将android:oneshot属性设置为true，这样动画会播放一次，否则，动画会循环播放。定义好的XML文件可作为View的背景图片，具体播放过程如下： 123456789101112131415161718AnimationDrawable rocketAnimation;public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image); rocketImage.setBackgroundResource(R.drawable.rocket_thrust); rocketAnimation = (AnimationDrawable) rocketImage.getBackground();&#125;public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; rocketAnimation.start(); return true; &#125; return super.onTouchEvent(event);&#125; 注意动画的播放方法start()不能在onCreate()方法执行，因为这个时候动画还没被加载到Activity的Window上。如果需要在没有交互的情况下播放可绘制动画，可以在Activity的onWindowFocusChanged()中进行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性动画框架]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[属性动画(Property Animation)框架可以弥补视图动画交互上的不足，实现更加丰富的动画效果。 在使用属性动画时，经常将ObjectAnimator和AnimatorSet配合使用，ObjectAnimator用来控制对象的一个属性值的变化，多个ObjectAnimator可以组合到AnimatorSet中，并且ObjectAnimator能够自驱动，还可以调用setFrameDelay()方法设置动画帧之间的间隙时间来调整帧率，减少频繁绘制达到节约CPU资源消耗的效果。 属性动画是通过调用属性的get、set方法真实地改变了View的属性值，所以，属性动画框架能满足在动画过程中的交互需求，实现基本上所有的动画效果。 ObjectAnimatorObjectAnimator是属性框架中最重要的实行类，具体通过其静态工厂类进行创建。参数包括进行动画的对象和对象的属性名，这个属性必须要有get和set方法，因为ObjectAnimator会通过Java反射机制调用set方法修改属性值， 从而产生具体的动画效果。 下面利用ObjectAnimator实现一个简单的平移动画： 1234567ObjectAnimator animator = ObjectAnimator.ofFloat( view, "translationX", 200f);animator.setDuration(2000);animator.start(); 在使用ObjectAnimator时，要注意需要操纵的属性必须要有get和set方法，下面是一些常用的可使用的属性值： translationX和translationY：控制View从坐标原点的偏移位置。 rotation、rotationX和rotationY：控制View围绕支点进行旋转。 scaleX和scaleY：控制View围绕支点进行缩放。 pivotX和pivotY：控制View的支点位置，默认情况，支点位置时View的中心点。 x和y：描述View在它的容器的最终位置，是最初的坐标位置与translationX和translationY的累计和。 alpha：控制View的透明度。 视图动画的所有动画效果，都可以使用上面介绍的属性值实现。 如果View的某个属性没有提供get和set方法，也可以为其实现动画效果。具体有两种方案：一个是自定义属性类或包装类，间接地给属性增加get和set方法；另一个是通过ValueAnimator实现。ValueAnimator的具体使用在后面介绍，这里介绍如何使用前一种方法： 自定义包装类 12345678910111213141516private static class WrapperView &#123; private View mTarget; public WrapperView(View target) &#123; mTarget = target; &#125; public int getWidth() &#123; return mTarget.getLayoutParams().width; &#125; public void setWidth(int width) &#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125;&#125; 操作包装类实现动画 123456WrapperView wrapper = new WrapperView(view);ObjectAnimator.ofInt( wrapper, "width", 200, 500).setDuration(3000).start(); PropertyValuesHolder类似于视图动画中的AnimationSet，在属性动画中，如果要对同一个对象的多个属性同时产生动画，可以使用PropertyValuesHolder实现，具体使用如下： 123456789PropertyValuesHolder pvh1 = PropertyValuesHolder .ofFloat("translationX", 300f);PropertyValuesHolder pvh2 = PropertyValuesHolder .ofFloat("scaleX", 1f, 0, 1f);PropertyValuesHolder pvh3 = PropertyValuesHolder .ofFloat("scaleY", 1f, 0, 1f);ObjectAnimator.ofPropertyValuesHolder(view, pvh1, pvh2, pvh3) .setDuration(2000) .start(); ValueAnimatorValueAnimator是属性动画的核心类，ObjectAnimator就是它的子类。 ValueAnimator本身不提供任何动画效果，它像一个数值发生器，产生具有一定规律的数值，让调用者使用这些数值实现动画效果。 通常情况下，在ValueAnimator的AnimatorUpdateListener中监听数值变化，完成动画效果。具体使用如下： 123456789101112ValueAnimator animator = ValueAnimator.ofInt(200, 500);animator.setDuration(3000);animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Integer value = (Integer) animation.getAnimatedValue(); // Use the value view.getLayoutParams().width = value; view.requestLayout(); &#125;&#125;);animator.start(); 监听动画事件属性动画的声明周期有Start、Repeat、End、Cancel四个过程，可以通过AnimatorListener监听这些事件： 123456789101112131415161718192021animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; @Override public void onAnimationStart(Animator animation) &#123; &#125;&#125;); 大部分时候，我们只关心特定的事件，这时可以使用AnimatorListenerAdapter选择监听特定的事件： 123456animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); &#125;&#125;); AnimatorSet对于一个View同时作用多个属性动画效果，除了用前面介绍的PropertyValuesHolder实现，还可以用AnimatorSet实现，同时，AnimatorSet还可以对动画的播放顺序进行精确地控制。具体使用如下所示： 12345678910ObjectAnimator animator1 = ObjectAnimator .ofFloat(view, "translationX", 300f);ObjectAnimator animator2 = ObjectAnimator .ofFloat(view, "scaleX", 1f, 0, 1f);ObjectAnimator animator3 = ObjectAnimator .ofFloat(view, "scaleY", 1f, 0, 1f);AnimatorSet animatorSet = new AnimatorSet();animatorSet.setDuration(2000);animatorSet.playTogether(animator1, animator2, animator3);animatorSet.start(); AnimatorSet可以使用playTogether()、playSequentially()、play()、with()、before()、after()方法控制多个动画协同工作，从而对动画播放顺序进行精确控制。 在XML中定义属性动画属性动画同视图动画一样，可以直接在XML文件中定义，这样可以方便多个组件共享动画效果，具体代码如下所示： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000" android:propertyName="rotation" android:valueFrom="0" android:valueTo="360" android:valueType="floatType"/&gt; 定义完动画效果后，具体使用如下： 1234Animator animator = AnimatorInflater .loadAnimator(this, R.animator.animator_sample);animator.setTarget(view);animator.start(); ViewPropertyAnimator可以使用ViewPropertyAnimator简化常用属性动画的使用，具体通过View的animate()方法实现，示例代码如下所示： 1234567891011121314151617view.animate() .alpha(0) .rotation(360) .setDuration(3000) .withStartAction(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;) .withEndAction(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;) .start(); ViewPropertyAnimator、ObjectAnimator、ValueAnimator这三种Animator其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。它们的性能是一样的，因为ViewPropertyAnimator和ObjectAnimator的内部实现都是ValueAnimator。它们的差别只是使用的便捷性以及功能的灵活性。在实际使用时候的选择，只要遵循一个原则：尽量用简单的。能用View.animate()实现就不用ObjectAnimator，能用ObjectAnimator就不用ValueAnimator。 Interpolators插值器(Interpolators)可以定义动画的变化速率，类似于物理学中的加速度，控制View的属性由起始值到目标值变化的方式。例如，对于位移动画，可以通过setInterpolator()方法设置AccelerateInterpolator，这样View的位移速度会越来越快。具体插值器的类别可以参考HenCoder的属性动画（上手篇）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图动画框架]]></title>
    <url>%2F2018%2F01%2F17%2F%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[视图动画(View Animation)框架提供了透明度、旋转、缩放和位移这几种动画，它控制的是整个View，实现原理是每次绘制View时，在其ViewGroup中的drawChild()方法调用View的draw()方法，接着在draw()方法中获取Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())方法，通过矩阵运算实现动画帧，如果动画没有完成，就继续调用invalidate()方法，启动下次绘制来实现下一个动画帧，最终完成整个动画。 视图动画使用比较简单，提供了AlphaAnimation、RotateAnimation、ScaleAnimation、TranslateAnimation分别实现透明度、旋转、缩放和位移动画，还提供了AnimationSet实现动画集合，组合使用多种动画。不过，视图动画主要用于Android3.0之前，Android3.0之后一般使用属性动画。相比属性动画，视图动画最大的劣势是不具备交互性，当View通过视图动画产生移动后，其响应事件的位置依然还动画产生前的地方。所以，视图动画只能用来实现没有交互的动画效果，但是，它也有使用方便、效率高的优点。 具体使用视图动画时，可以通过XML文件描述动画过程，也可以使用Java代码实现同样的动画过程。 透明度动画为视图增加透明度动画的代码如下： 123AlphaAnimation animation = new AlphaAnimation(0, 1);animation.setDuration(1000);view.startAnimation(animation); 旋转动画为视图增加旋转动画的代码如下： 1234RotateAnimation animation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);animation.setDuration(1000);view.startAnimation(animation); 缩放动画为视图增加缩放动画的代码如下： 1234ScaleAnimation animation = new ScaleAnimation(2, 1, 2, 1, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);animation.setDuration(1000);view.startAnimation(animation); 位移动画为视图增加位移动画的代码如下： 123TranslateAnimation animation = new TranslateAnimation(0, 200, 0, 200);animation.setDuration(1000);view.startAnimation(animation); 动画集合通过AnimationSet可以将多个动画以组合的形式展现出来： 1234567891011AnimationSet animationSet = new AnimationSet(true);AlphaAnimation aa = new AlphaAnimation(0, 1);aa.setDuration(3000);animationSet.addAnimation(aa);TranslateAnimation ta = new TranslateAnimation(0, 200, 0, 200);ta.setDuration(1000);animationSet.addAnimation(ta);view.startAnimation(animationSet); 动画监听对于动画事件，Android系统提供了对应的监听回调方法， 通过监听，可以获取动画的开始、结束和重复事件。 12345678910111213141516animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationStart(Animation animation) &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView使用]]></title>
    <url>%2F2018%2F01%2F16%2FSurfaceView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SurfaceView和View的区别View通过刷新来重绘视图，两次刷新的间隔时间为16ms，如果在16ms内，View没有完成需要执行的操作，用户就会产生卡顿的感觉。为了避免这个问题，可以使用SurfaceView，它与View的主要区别如下： View主要用于主动刷新，而SurfaceView适用于被动刷新，比如拍照和游戏界面的频繁刷新； View刷新在主线程中进行，而SurfaceView通常使用一个子线程进行刷新操作； View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现了这个机制； 因此，如果在自定义View的时候需要频繁刷新，或者刷新时数据处理量比较大时，可以考虑使用SurfaceView代替。 SurfaceView使用模板在使用SurfaceView时，可以使用一套模板代码，大部分的SurfaceView绘图操作都可以使用这套模板代码实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mHolder; private Canvas mCanvas; // 画布，用于绘图 private boolean mIsDrawing; // 标志位，用于控制进行绘制的子线程 public SurfaceViewTemplate(Context context) &#123; super(context); initView(); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; mHolder = getHolder(); mHolder.addCallback(this); setFocusable(true); setFocusableInTouchMode(true); setKeepScreenOn(true); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; while (mIsDrawing) &#123; draw(); &#125; &#125; private void draw() &#123; try &#123; mCanvas = mHolder.lockCanvas(); // 获取上一次的Canvas，之前的绘图操作会被保留 // To do drawing &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (mCanvas != null) mHolder.unlockCanvasAndPost(mCanvas); // 提交绘制内容 &#125; &#125;&#125; SurfaceView实例下面通过具体实例介绍如何使用SurfaceView进行频繁刷新的绘图。 正弦曲线1234567891011121314151617181920212223@Overridepublic void run() &#123; while (mIsDrawing) &#123; draw(); x += 1; y = (float) (100 * Math.sin(x * 2 * Math.PI / 180) + getHeight() / 2); mPath.lineTo(x, y); &#125;&#125;private void draw() &#123; try &#123; mCanvas = mHolder.lockCanvas(); // 获取上一次的Canvas，之前的绘图操作会被保留 // To do drawing mCanvas.drawColor(Color.WHITE); mCanvas.drawPath(mPath, mPaint); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (mCanvas != null) mHolder.unlockCanvasAndPost(mCanvas); // 提交绘制内容 &#125;&#125; 绘图板12345678910111213141516171819202122232425262728293031323334353637@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; float x = event.getX(); float y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(x, y); return true; case MotionEvent.ACTION_MOVE: mPath.lineTo(x, y); return true; case MotionEvent.ACTION_UP: return true; &#125; return super.onTouchEvent(event);&#125;@Overridepublic void run() &#123; while (mIsDrawing) &#123; draw(); &#125;&#125;private void draw() &#123; try &#123; mCanvas = mHolder.lockCanvas(); // 获取上一次的Canvas，之前的绘图操作会被保留 // To do drawing mCanvas.drawColor(Color.WHITE); mCanvas.drawPath(mPath, mPaint); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (mCanvas != null) mHolder.unlockCanvasAndPost(mCanvas); // 提交绘制内容 &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paint使用]]></title>
    <url>%2F2018%2F01%2F11%2FPaint%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在2D绘图中可以了解到Paint的基本使用，使用这些基本方法可以实现一般的绘制需求，如果要实现更加丰富的绘图效果，需要了解Paint的更详细使用。 Paint的方法按功能可以分为四类：颜色处理、绘制效果、文字绘制和初始化相关。 颜色处理颜色处理有三个层次：直接使用设置颜色的API给图形和文字设置颜色；使用setColorFilter()基于颜色进行过滤处理；使用setXfermode()处理源图像和Canvas已有内容的关系。 颜色设置Paint设置颜色的方法有两种：一种是直接用Paint.setColor/ARGB()来设置颜色，另一种是使用Shader来指定着色方案。 直接设置颜色 setColor(int color) setARGB(int a, int r, int g, int b) 使用Shader通过setShader(Shader shader)设置Shader后，Paint 在绘制图形和文字时就不使用setColor/ARGB()设置的颜色了，而是使用Shader中的颜色方案。系统提供的Shader有以下几类： LinearGradient 线性渐变 RadialGradient 辐射渐变 BitmapShader 用Bitmap的像素来作为图形或文字的填充 上面三种Shader都有3种着色规则（TileMode）：CLAMP会在端点之外延续端点处的颜色；MIRROR是镜像模式；REPEAT是重复模式。 SweepGradient 扫描渐变 ComposeShader 混合着色器，把两个Shader叠加使用叠加使用时，需要用到叠加模式，它的类型是PorterDuff.Mode，决定shaderA和shaderB应该怎样共同绘制。 设置滤色器通过setColorFilter(ColorFilter colorFilter)设置滤色器，系统提供的ColorFilter有以下几类： LightingColorFilter模拟简单的光照效果。 PorterDuffColorFilter使用一个指定的颜色和一种指定的PorterDuff.Mode来与绘制对象进行合成。 ColorMatrixColorFilter使用一个ColorMatrix来对颜色进行处理，具体使用可以查看图像特效中的颜色特效。 设置TransferMode通过setXfermode(Xfermode xfermode)设置TransferMode，”Xfermode”是”Transfer mode”的简写，指的是要绘制的内容和Canvas目标位置的内容进行颜色结合的模式，简单来说，就是以要绘制的内容作为源图像，以Canvas中已有的内容作为目标图像，选取一个PorterDuff.Mode作为绘制内容的颜色处理方案。 创建Xfermode的时候其实是创建的它的子类PorterDuffXfermode，而事实上，Xfermode只有这一个子类。 绘制效果绘制效果指的就是抗锯齿、填充/轮廓、线条宽度等等这些。 抗锯齿使用setAntiAlias (boolean b)设置是否抗锯齿。 绘制风格使用setStyle(Paint.Style style)设置图形是线条风格还是填充风格的（或者二者并用）。 线条形状 setStrokeWidth(float width)设置线条宽度。单位为像素，默认值是 0。 setStrokeCap(Paint.Cap cap)设置线头的形状。线头形状有三种：BUTT平头、ROUND圆头、SQUARE方头。默认为BUTT。 setStrokeJoin(Paint.Join join)设置拐角的形状。有三个值可以选择：MITER尖角、 BEVEL平角和ROUND 圆角。默认为MITER。 setStrokeMiter(float miter)这个方法是对于setStrokeJoin()的一个补充，它用于设置MITER型拐角的延长线的最大值，所谓“延长线的最大值”。 色彩优化 setDither(boolean dither)设置图像的抖动。 setFilterBitmap(boolean filter)设置是否使用双线性过滤来绘制Bitmap。图像在放大绘制的时候，默认使用的是最近邻插值过滤，这种算法简单，但会出现马赛克现象；而如果开启了双线性过滤，就可以让结果图像显得更加平滑。 PathEffect通过setPathEffect(PathEffect effect)给图形的轮廓设置效果，对Canvas所有的图形绘制有效，即对 drawLine() drawCircle() drawPath() 这些方法有效。 单一效果的PathEffect有： CornerPathEffect把所有拐角变成圆角。 DiscretePathEffect把线条进行随机的偏离，让轮廓变得乱七八糟。 DashPathEffect使用虚线来绘制线条。 PathDashPathEffect比DashPathEffect多一个前缀Path，顾名思义，它是使用一个Path来绘制“虚线”。 组合效果类的PathEffect有： SumPathEffect按照两种PathEffect分别对目标进行绘制。 ComposePathEffect先对目标Path使用一个PathEffect，然后再对这个改变后的Path使用另一个PathEffect。 添加阴影具体使用setShadowLayer(float radius, float dx, float dy, int shadowColor)方法。radius是阴影的模糊范围；dx dy是阴影的偏移量；shadowColor是阴影的颜色。 如果要清除阴影层，使用clearShadowLayer()方法。 MaskFiltersetShadowLayer()设置的是绘制层下方的附加效果；而MaskFilter和它相反，setMaskFilter(filter)设置的是绘制层上方的附加效果。 前面有一个setColorFilter(filter)方法，它对每个像素的颜色进行过滤；而setMaskFilter(filter)是基于整个画面来进行过滤。 BlurMaskFilter 模糊效果 EmbossMaskFilter 浮雕效果 获取绘制的Path根据Paint的设置，计算出绘制Path或文字时的实际Path，所谓实际Path，指的就是drawPath()绘制内容的轮廓，要算上线条宽度和设置的PathEffect。 getFillPath(Path src, Path dst)src是原Path，而dst就是实际Path的保存位置。 getTextPath()获取的就是目标文字所对应的Path。 获取绘制的Path主要是用于图形和文字的装饰效果的位置计算，比如自定义的下划线效果。 文字绘制Paint有很多文字绘制相关的方法，即和drawText()相关的方法，这些方法可以设置文字大小、文字间隔、文字效果等。除此之外，Paint还有很多与文字绘制相关的设置或计算的方法，具体可以参考官方文档。 初始化相关这一类方法很简单，它们是用来初始化Paint对象，或者是批量设置Paint的多个属性的方法。 reset()重置Paint的所有属性为默认值。相当于重新new一个，不过性能相对要高。 set(Paint src)把src的所有属性全部复制过来。相当于调用src所有的get方法，然后调用这个Paint的对应的set方法来设置它们。 setFlags(int flags)批量设置flags。相当于依次调用它们的set方法。 这里只是简单介绍了Paint提供的绘制功能，详细介绍可以参考HenCoder的Paint详解。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像特效]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%9B%BE%E5%83%8F%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[图像特效按照处理对象一般可以分为颜色特效和图形特效两类，下面分别进行介绍。 颜色特效在Android系统中，通常使用Bitmap（位图）的数据结构来表示一张图片，它包含了图片的所有数据。Bitmap由点阵和颜色值组成，点阵是图片像素的矩阵，其中每个元素对应图片的一个像素；颜色值（ARGB）分别对应透明度、红、绿、蓝四个分量，它们共同决定每个像素点的颜色。 进行颜色处理时，通常使用以下三个角度来描述一个图像： 色调——物体的颜色 饱和度——颜色的纯度，从0（灰）到100%（饱和）进行描述 亮度——颜色的明暗程度 颜色矩阵——ColorMatrixAndroid中使用颜色矩阵（ColorMatrix）处理图像的颜色效果，ColorMatrix是一个4x5的矩阵，对于图像的每个像素点，都有一个4x1的颜色分量矩阵保存颜色的RGBA值。 具体对图像的颜色进行处理时，会通过一定的算法得到一个对应效果的ColorMatrix，接着把这个矩阵分别与每个像素点的颜色分量矩阵进行乘法运算得到新的颜色分量矩阵，最后为每个像素点设置新的颜色分量矩阵，从而达到颜色特效的处理效果，具体过程如下所示： 根据上述过程，可以得到： 根据处理结果可以知道，在4x5的ColorMatrix中： 第一行r1 g1 b1 a1 o1的值决定新颜色值中的R（红色） 第二行r2 g2 b2 a2 o2的值决定新颜色值中的G（绿色） 第三行r3 g3 b3 a3 o3的值决定新颜色值中的B（蓝色） 第四行r4 g4 b4 a4 o4的值决定新颜色值中的A（透明度） 第五列o1 o2 o3 o4的值决定新颜色值中每个分量的偏移量（offset） 因此，对图像的颜色进行处理时，通常有两种方法：一个是改变颜色的offset；另一个是改变对应RGBA值的系数。 通过颜色矩阵进行颜色处理改变ColorMatrix方式通常有两种：一种是通过系统API修改；另一种是利用经典算法直接创建。 通过系统API修改通过系统API修改颜色矩阵可以改变图像的色调、饱和度和亮度。 色调使用setRotate(int axis, float degrees)方法设置颜色矩阵的色调。axis使用0，1，2来表示Red、Green、Blue三种颜色的处理；degrees表示处理的具体值。 饱和度使用setSaturation(float sat)方法设置颜色矩阵的饱和度。当饱和度为0时，图像会变为灰色。 亮度使用setScale(float rScale, float gScale, float bScale, float aScale)方法设置颜色矩阵的亮度。其本质是利用三原色以同比例混合会显示出白色的原理。当亮度为0时，图像会变为黑色。 效果叠加除了上面三种处理方法外，还可以使用postConcat()方法将不同效果的矩阵进行混合，从而产生叠加效果。 下面的示例代码展示了如何使用上面介绍的方法： 123456789101112131415161718192021222324252627public static Bitmap handleImageEffect(Bitmap bm, float hue, float saturation, float lum) &#123; Bitmap bitmap = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); ColorMatrix hueMatrix = new ColorMatrix(); hueMatrix.setRotate(0, hue); hueMatrix.setRotate(1, hue); hueMatrix.setRotate(2, hue); ColorMatrix saturationMatrix = new ColorMatrix(); saturationMatrix.setSaturation(saturation); ColorMatrix lumMatrix = new ColorMatrix(); lumMatrix.setScale(lum, lum, lum, 1); ColorMatrix imageMatrix = new ColorMatrix(); imageMatrix.postConcat(hueMatrix); imageMatrix.postConcat(saturationMatrix); imageMatrix.postConcat(lumMatrix); paint.setColorFilter(new ColorMatrixColorFilter(imageMatrix)); canvas.drawBitmap(bm, 0, 0, paint); return bitmap;&#125; 利用经典算法创建图像色彩处理，通常就是研究如何通过某种算法创建颜色矩阵，将其作用到图像上，形成新的色彩风格的图像。下面介绍一些经典算法对应的颜色矩阵。 灰度效果 1234567// 灰度效果float[] colorMatrix = new float[] &#123; 0.33f, 0.59f, 0.11f, 0, 0, 0.33f, 0.59f, 0.11f, 0, 0, 0.33f, 0.59f, 0.11f, 0, 0, 0, 0, 0, 1, 0,&#125;; 图像反转 1234567// 图像反转float[] colorMatrix = new float[] &#123; -1, 0, 0, 1, 1, 0, -1, 0, 1, 1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 0,&#125;; 怀旧效果 1234567// 怀旧效果float[] colorMatrix = new float[] &#123; 0.393f, 0.769f, 0.189f, 0, 0, 0.349f, 0.686f, 0.168f, 0, 0, 0.272f, 0.534f, 0.131f, 0, 0, 0, 0, 0, 1, 0,&#125;; 去色效果 1234567// 去色效果float[] colorMatrix = new float[] &#123; 1.5f, 1.5f, 1.5f, 0, -1, 1.5f, 1.5f, 1.5f, 0, -1, 1.5f, 1.5f, 1.5f, 0, -1, 0, 0, 0, 1, 0,&#125;; 高饱和度 1234567// 高饱和度float[] colorMatrix = new float[] &#123; 1.438f, -0.122f, -0.016f, 0, -0.03f, -0.062f, 1.378f, -0.016f, 0, 0.05f, -0.062f, -0.122f, 1.483f, 0, -0.02f, 0, 0, 0, 1, 0,&#125;; 像素点分析除了通过ColorMatrix改变图像的颜色，还可以直接改变每个像素点的ARGB值来改变图像的颜色，这种处理方式相对更加精确。用这种方式处理图片时，需要注意原始图片是不可变的（mutable），需要复制原始图片进行处理。 Android中使用Bitmap.getPixels(int[] pixels, int offset, int stride,int x, int y, int width, int height)方法获取图片的像素点的颜色值： pixels: 接收位图像素点颜色值的数组 offset: 写入到pixels[]中的第一个像素索引值 stride: pixels[]的行间距 x: 从bitmap中读取的第一个像素的x坐标值 y: 从bitmap中读取的第一个像素的y坐标值 width: 每行的像素个数 height: 读取的行数 修改图像像素点的颜色值的关键代码如下所示： 1234567891011121314151617181920// 获取图片像素点的颜色值数组bitmap.getPixels(oldPx, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());// 获取每个像素点具体的ARGB值int color = oldPx[i];a = Color.alpha(color);r = Color.red(color);g = Color.green(color);b = Color.blue(color);// 根据图像处理算法修改像素点的ARGB值rn = (int) (0.393 * r + 0.322 * g + 0.189 * b);gn = (int) (0.393 * r + 0.322 * g + 0.189 * b);bn = (int) (0.393 * r + 0.322 * g + 0.189 * b);newPx[i] = Color.argb(a, rn, gn, bn);// 将修改后的颜色数组设置到位图上，完成颜色处理bitmap.setPixels(newPx, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight()); 通过像素点进行颜色处理通过Pixels进行颜色处理，就是通过特定的算法改变每个像素点的颜色值，从而得到相应的处理效果。下面介绍一些常用的处理算法。 底片效果 处理算法： 123r = 255 - r;g = 255 - g;b = 255 - b; 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738public static Bitmap handleImagePixels(Bitmap bitmap) &#123; int width = bitmap.getWidth(); int height = bitmap.getHeight(); int color; int a, r, g, b; Bitmap bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); int[] oldPx = new int[width * height]; int[] newPx = new int[width * height]; // 获取图片像素点的颜色值数组 bitmap.getPixels(oldPx, 0, width, 0, 0, width, height); for (int i = 0; i &lt; width * height; i++) &#123; // 获取每个像素点具体的ARGB值 color = oldPx[i]; a = Color.alpha(color); r = Color.red(color); g = Color.green(color); b = Color.blue(color); // 根据图像处理算法修改像素点的ARGB值 r = 255 - r; g = 255 - g; b = 255 - b; if (r &gt; 255) r = 255; if (r &lt; 0) r = 0; if (g &gt; 255) g = 255; if (g &lt; 0) g = 0; if (b &gt; 255) b = 255; if (b &lt; 0) b = 0; newPx[i] = Color.argb(a, r, g, b); &#125; // 将修改后的颜色数组设置到位图上，完成颜色处理 bmp.setPixels(newPx, 0, width, 0, 0, width, height); return bmp;&#125; 老照片效果 处理算法： 123rn = (int) (0.393 * r + 0.769 * g + 0.189 * b);gn = (int) (0.349 * r + 0.686 * g + 0.168 * b);bn = (int) (0.272 * r + 0.534 * g + 0.131 * b); 示例代码和上面类似。 图形特效可以将一张图像的形状进行处理，达到某种图形上的效果。Android中提供的常用处理方式有：平移、旋转、缩放和错切（skew），除了常用的处理方式，还可以通过变形矩阵自定义图形变换。 变形矩阵——Matrix类似于颜色矩阵，Android中使用变形矩阵（Matrix）处理图像的图形变换，变形矩阵是一个3x3的矩阵，对于图像的每个像素点，都有一个3x1的位置矩阵保存其X，Y的坐标值。 具体进行图形变换时，会将变形矩阵与每个像素的位置矩阵相乘，为每个像素设置新的位置，从而达到图像变换效果，具体过程如下所示： 根据上述过程，可以得到： 通常情况下为了保证 1 = gX + hY + i 成立，会令 g = h = 0，i = 1，这样，在处理图形变换时，只需要关注其它几个参数即可。 平移变换（Translate） 平移变换就是将所有像素点的坐标值进行平移，其变换过程如下： 旋转变换（Rotate） 旋转变换是将像素点围绕一个中心点进行选择，以原点为中心旋转一定角度的变换过程如下： 述变换过程是以坐标原点为中心旋转的，如果以任意点O为中心旋转通常需要：将坐标原点平移到O点；以原点为中心旋转；将坐标原点还原。 缩放变换（Scale） 缩放变换是对于多个像素点才会有效果，将图像沿X轴和Y轴按一定比例缩放的变换过程如下： 错切变换（Skew） 错切变换是将所有像素点的X坐标（或Y坐标）保持不变，而对应的Y坐标（或X坐标）按比例发生平移，并且平移的大小和该点到X轴（或Y轴）的垂直距离成正比。 错切变换的示意图如下所示： 错切变换过程如下： 通过变形矩阵进行图形处理与颜色矩阵一样，变形矩阵也提供了相关API简化图形变换，其中Matrix提供的方法是进行2D变换的，而Camera提供的方法还可以进行3D变换。 通过Matrix进行2D变换Matrix提供的变换API有： Matrix.setTranslate()：平移变换 Matrix.setRotate()：旋转变换 Matrix.setScale()：缩放变换 Matrix.setSkew()：错切变换 Matrix.setPolyToPoly() setRectToRect() setSinCos()：自定义变换 Matrix.preXXX()和Matrix.postXXX()：叠加变换 当设置完Matrix后，把Matrix设置到Canvas上有两个方法： Canvas.setMatrix(matrix)：用Matrix直接替换Canvas当前的变换矩阵，即抛弃Canvas当前的变换，改用Matrix的变换 Canvas.concat(matrix)：用Canvas当前的变换矩阵和Matrix相乘，即基于Canvas当前的变换，叠加上Matrix中的变换 通过Camera进行3D变换Camera提供的3D变换有三类： Camera.rotateXXX()：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行旋转，可以用来实现翻转效果。同时要注意，虚拟相机旋转的轴心是坐标原点。 Camera.translate(x, y, z)：将虚拟相机的坐标轴沿X、Y、Z轴三个方向进行移动，可以使用Canvas的translate()和scale()方法代替。 Camera.setLocation(x, y, z)：设置虚拟相机的位置，可以用来控制投影的图像大小。 当设置完Camera后，把Camera的Matrix设置到Canvas需要使用Camera.applyToCanvas(canvas)方法。 示例代码如下： 12345678canvas.translate(centerX, centerY); // 旋转之前把绘制内容移动到轴心（原点）camera.save(); // 保存 Camera 的状态camera.rotateX(30); // 旋转 Camera 的三维空间camera.applyToCanvas(canvas); // 把旋转投影到 Canvascamera.restore(); // 恢复 Camera 的状态canvas.translate(-centerX, -centerY); // 旋转之后把投绘制内容动回来 像素块分析类似于颜色处理，除了使用矩阵的方式，还可以使用基于像素的方式进行图形处理。具体处理的时候需要使用drawBitmapMesh()方法，该方法像一张网格，把图像分成一个个像素块，通过改变像素块间节点的坐标位置，使整个图像的图形发生变化。 该方法具体形式如下：drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 其中关键参数有： bitmap：需要形变的图像 meshWidth：横向网格数目 meshHeight：纵向网格数目 verts：网格交叉点坐标数组 vertOffset：绘制的时候，verts数组跳过坐标对数目 其中最重要的参数是verts数组，drawBitmapMesh()方法绘制前会将图像分成多个像素块，假如在图像上的横向和纵向各画N（N &gt; 1，线条从图像边缘开始）条线，这些线会交叉组成NxN个的点，那么，每个点的坐标值以 x1, y1, x2, y2, … , xn, yn 的形式保存在verts数组中，drawBitmapMesh()方法就是通过改变这些坐标值，重新定位每个像素块，从而改变图像形状。 drawBitmapMesh()方法基本上可以实现所有的图像特效，其使用关键在于计算去，确定新的交叉点坐标。 通过像素块进行图形处理这里使用drawBitmapMesh()方法使一张图片产生“旗帜飞扬”的效果。 要达到这个效果，需要保持交叉点的横坐标不变，并且交叉点纵坐标呈现一个三角函数的周期变化。 获取交叉点坐标 基本原理是通过遍历所有的交叉线，按比例获取交叉点坐标。 12345678910111213141516171819202122232425// 网线数目 = 网格数目 + 1private static int HEIGHT = 19; // 纵向网格数目private static int WIDTH = 29; // 横向网格数目/** * 获取原始交叉点坐标 */private float[] getBitmapVerts(Bitmap bitmap) &#123; float[] verts = new float[(WIDTH + 1) * (HEIGHT + 1) * 2]; // 坐标值数目 = 2 * 交点数目 float bitmapHeight = bitmap.getHeight(); float bitmapWidth = bitmap.getWidth(); int index = 0; for (int y = 0; y &lt;= HEIGHT; y++) &#123; float fy = bitmapHeight * y / HEIGHT; for (int x = 0; x &lt;= WIDTH; x++) &#123; float fx = bitmapWidth * x / WIDTH; verts[index * 2] = fx; verts[index * 2 + 1] = fy + 100; // 为了避免图像偏移后被遮挡，将纵坐标+100，使图像下移 index++; &#125; &#125; return verts;&#125; 改变交叉点坐标值 横坐标不变，使用正弦函数改变纵坐标值。 1234567891011121314151617/** * 根据正选函数修改交叉点坐标 * * @param verts 交叉点坐标 * @param K 相位，用于动态改变偏移量，实现动态效果 * @param A 振幅，用于改变偏移幅度 */private void flagWave(float[] verts, float K, float A) &#123; for (int j = 0; j &lt;= HEIGHT; j++) &#123; for (int i = 0; i &lt;= WIDTH; i++) &#123; float offsetY = (float) Math.sin(((float) i / WIDTH + K) * 2 * Math.PI); int index = 2 * (j * (WIDTH + 1) + i); verts[index] += 0; verts[index + 1] += offsetY * A; &#125; &#125;&#125; 根据交叉点绘制图像 这样绘制可以得到一个静态的效果。 12345678910private float mVerts[] = getBitmapVerts(mBitmap);private static float K = 0f, A = 50f;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(mVerts, K, A); canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, 0, null, 0, null);&#125; 重绘产生动态效果 每次重绘时，通过改变正弦函数的相位来改变纵坐标的偏移量。 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(mVerts, K, A); canvas.drawBitmapMesh(mBitmap, WIDTH, HEIGHT, mVerts, 0, null, 0, null); // 改变相位后重绘，产生飘扬效果 K += 0.1f; postInvalidateDelayed(50); // 延时重绘，避免飘扬太快&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML绘图]]></title>
    <url>%2F2018%2F01%2F02%2FXML%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Bitmap在XML中使用Bitmap的语法如下所示： 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:antialias=["true" | "false"] android:dither=["true" | "false"] android:filter=["true" | "false"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:mipMap=["true" | "false"] android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&gt; 通过这种方式引用图片，可以直接将res中只读的图片资源转成Bitmap对象使用。 Shape在XML中使用Shape的语法如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] &gt; &lt;corners android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" /&gt; &lt;gradient android:angle="integer" android:centerX="float" android:centerY="float" android:centerColor="integer" android:endColor="color" android:gradientRadius="integer" android:startColor="color" android:type=["linear" | "radial" | "sweep"] android:useLevel=["true" | "false"] /&gt; &lt;padding android:left="integer" android:top="integer" android:right="integer" android:bottom="integer" /&gt; &lt;size android:width="integer" android:height="integer" /&gt; &lt;solid android:color="color" /&gt; &lt;stroke android:width="integer" android:color="color" android:dashWidth="integer" android:dashGap="integer" /&gt;&lt;/shape&gt; Shape是XML绘图的关键，无论是扁平化、拟物化还是渐变，它都可以实现。 Layer在XML中使用Layer的语法如下所示： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:id="@[+][package:]id/resource_name" android:top="dimension" android:right="dimension" android:bottom="dimension" android:left="dimension" /&gt;&lt;/layer-list&gt; 通过Layer可以很方便地实现图层叠加的效果。 SelectorSelector用于定义的可绘制对象，它根据对象的状态，使用多个不同的图像来表示同一个图形。 在XML中使用Selector的语法如下所示： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"] android:dither=["true" | "false"] android:variablePadding=["true" | "false"] &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:state_pressed=["true" | "false"] android:state_focused=["true" | "false"] android:state_hovered=["true" | "false"] android:state_selected=["true" | "false"] android:state_checkable=["true" | "false"] android:state_checked=["true" | "false"] android:state_enabled=["true" | "false"] android:state_activated=["true" | "false"] android:state_window_focused=["true" | "false"] /&gt;&lt;/selector&gt; 通过Selector可以快速实现View的触摸反馈。通过配置不同的触发事件，自动选择不同的图像作为背景图。 更多以上只是介绍了常用的XML绘图方法，更多XML绘图方法可以参考官方文档。 另外，上面介绍的XML绘图方法是可以配合使用的，比如在Selector中的Item中使用Shape实现圆角的背景图片。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D绘图]]></title>
    <url>%2F2018%2F01%2F02%2F2D%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[绘图基础Android系统提供了Canvas和Paint对象进行绘图，类似于现实生活中的画板和画笔。 Canvas提供了绘制各种图形的API，常用的有： drawPoint(); 绘制点 drawLine(); 绘制线 drawRect(); 绘制矩形 drawRoundRect(); 绘制圆角矩形 drawVertices(); 绘制多边形 drawArc(); 绘制弧形和扇形 drawCircle(); 绘制圆 drawOval(); 绘制椭圆 drawText(); 绘制文本 drawColor(); 绘制颜色 drawPath(); 绘制路径（可以用于绘制自定义图形） drawBitmap(); 绘制图像 Paint提供了各种绘制效果的API，常用的有： setAntiAlias(); 设置画笔的锯齿效果 setColor(); 设置画笔的颜色 setARGB(); 设置画笔的A R G B值 setAlpha(); 设置画笔的透明度 setTextSize(); 设置字体的尺寸 setStyle(); 设置画笔的风格（实心或空心等） setStrokeWidth(); 设置画笔的宽度 具体绘制的时候，可以任意组合Canvas和Paint的API实现不同的绘制效果，比如绘制一个红色实心矩形。 Canvas高级使用虽然通过Canvas的drawXXX()方法可以绘制各种图形，但是对于一些复杂的图形，会涉及到复杂的坐标运算，为了简化坐标运算，可以使用以下方法。 Canvas.save()和Canvas.restore()save()的作用是将之前已绘制的图像保存起来，这样，后续绘制操作相当于在一个新的图层上进行；restore()方法作用是将save()之后绘制的图像与save()之前绘制的图像进行合并，即将新的图层绘制到Canvas上；这两个方法一般是配合使用； Canvas.translate()和Canvas.rotate()translate(x, y)方法可以理解为将绘图的坐标原点(0, 0)移到(x, y)，后续的绘图操作都以(x, y)为原点进行；rotate()方法可以理解为将绘图的坐标系旋转一定的角度，后续的绘图操作都以旋转后的坐标系为参照进行，这样可以减少坐标计算，例如，在原坐标系中的斜线，在旋转后的坐标系中只需要绘制成直线； Canvas还提供了clipXXX()方法对图像进行裁剪，比如clipRect()方法可以将绘制好的图像裁剪成为矩形。 Layer图层一张复杂的图像可以由多个图层叠加形成，多个图层就形成了一个栈的结构，Android系统对图层的管理就是通过栈的结构进行的。 saveLayer()和saveLayerAlpha()方法将一个图层入栈；restore()和restoreToCount()方法将一个图层出栈。 入栈的时候，后面所有的绘制操作都发生在这个图层上；出栈的时候，会把图层上的图像绘制到Canvas上。 通过控制图层的位置、透明度等，可以绘制出各种复杂的图像。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏幕信息]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%B1%8F%E5%B9%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Android手机屏幕的尺寸、分辨率多种多样，这为绘图造成了一定的难度，想要在不同的屏幕上保持绘图的准确性，需要对屏幕的信息有充分了解。 屏幕参数通常Android手机屏幕有下面几个参数： 屏幕尺寸指屏幕对角线的长度，通常使用“寸”表示，比如4.7寸手机。 分辨率指屏幕像素点的个数，例如720 x 1280分辨率手机表示：宽有个720个像素点，高有1280个像素点。 ppi或dpi指每英寸像素（Pixels Per Inch），又称dpi（Dots Per Inch），由对角线的像素点个数除以屏幕的尺寸得到。 Android系统屏幕密度虽然Android手机有各种尺寸和分辨率，但是Android系统定义了几个标准的dpi值，在具体适配时，只需要对下面表格里的标准dpi进行适配即可。 屏幕类型 ldpi mdpi hdpi xhdpi xxhdpi 密度值 120 160 240 320 480 分辨率 240x320 320x480 480x800 720x1280 1080x1920 独立像素密度dp由于Android手机屏幕密度不同，因此，同样的像素点个数在不同屏幕上显示的长度也不同，因为高密度屏幕在同样的长度范围包含更多像素点。为了解决这个问题，Android系统使用dp（Device Independent Pixels，又称dip）表示屏幕长度，并规定在mdpi中，1dp = 1px，这样可以根据屏幕的密度值进行换算，得到每种屏幕密度对应的像素数目，例如，在xhdpi中，1dp = 320/160 * 1px = 2px。 单位转换根据上面的分析，可以手动对像素单位进行转换，不过更好的方式是使用系统的TypedValue类，代码如下所示： 123456789101112131415/** * dip to pixels */public static float dipToPixels(Context context, float dipValue) &#123; DisplayMetrics metrics = context.getResources().getDisplayMetrics(); return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dipValue, metrics);&#125;/** * sp to pixels */public static float spToPixels(Context context, float spValue) &#123; DisplayMetrics metrics = context.getResources().getDisplayMetrics(); return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, metrics);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘图处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现滑动的方法]]></title>
    <url>%2F2017%2F12%2F27%2F%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[了解滑动实现原理后，可以总结出实现滑动效果的基本思想：当View被触摸时，记录当前触摸点的坐标；当触摸点移动时，记录移动后触摸点的坐标；根据两次获取的坐标计算出触摸点的偏移量，通过偏移量修改View的坐标；不断重复，实现滑动效果。 接下来介绍实现滑动效果的一些方法。 layout方法在View进行绘制时，会调用onLayout()方法设置显示的位置，因此，可以通过修改View的left，top，right，bottom属性来控制View的坐标。具体在onTouchEvent()方法中实现，示例代码如下： 12345678910111213141516171819202122232425@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); return true; &#125; return super.onTouchEvent(event);&#125; 面的示例代码是通过getX()和getY()方法获取触摸事件的坐标值，下面以getRawX()和getRawY()方法来获取坐标值实现滑动效果： 1234567891011121314151617181920212223242526272829@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int rawX = (int) event.getRawX(); int rawY = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = rawX; lastY = rawY; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = rawX - lastX; int offsetY = rawY - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); // 重新设置初始坐标 lastX = rawX; lastY = rawY; return true; &#125; return super.onTouchEvent(event);&#125; 注意 使用绝对坐标系时，每次执行完ACTION_MOVE逻辑后，一定要重新设置初始坐标，这样才能准确获取连续移动时的偏移量。因为在相对坐标系中，ACTION_DOWN事件的坐标值对于View是不变的，而在绝对坐标系中，这个坐标值对于View是变化的。 offsetLeftAndRight和offsetTopAndBottom方法这两个方法只需要偏移量就可以完成View的重新绘制，达到layout方法同样的效果，示例代码如下： 12345678910111213141516171819202122232425@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 offsetLeftAndRight(offsetX); offsetTopAndBottom(offsetY); return true; &#125; return super.onTouchEvent(event);&#125; LayoutParamsLayoutParams保存了View的布局参数，可以通过改变LayoutParams来动态修改View的位置参数，实现View的滑动效果。具体示例代码如下： 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams(); layoutParams.leftMargin += offsetX; layoutParams.topMargin += offsetY; setLayoutParams(layoutParams); return true; &#125; return super.onTouchEvent(event);&#125; scrollTo与scrollBy方法View提供了scrollTo与scrollBy方法来改变View的位置，scrollTo(x, y)表示移动到坐标点(x, y)，scrollBy(dx, dy)表示移动的增量为dx、dy。 scrollTo与scrollBy方法的本质是移动View，从而使View中content产生相对移动。以下示意图以scrollBy方法为例进行说明： 从示意图可以看出，content移动的方向和ViewGroup移动的方向是相反的，所以，如果以子View的偏移量来移动ViewGroup来达到子View的滑动效果，那么，scrollBy中的偏移量要使用负值。 根据以上分析，使用scrollBy方法实现滑动效果的示例代码如下： 123456789101112131415161718192021222324@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 根据偏移量重新布局View，使View移动产生滑动效果 ((View) getParent()).scrollBy(-offsetX, -offsetY); return true; &#125; return super.onTouchEvent(event);&#125; 类似的，在绝对坐标系中，可以使用scrollTo方法实现同样的滑动效果。 Scroller在使用scrollTo与scrollBy方法移动时，View的移动都是瞬时完成的，为了产生平滑移动的效果，需要使用Scroller类。 Scroller的原理也是使用scrollTo与scrollBy方法来移动View，但是它会把移动的偏移量分为多个很小的偏移量，虽然在每个小的偏移量里面，移动是瞬时的，但是整体上会是一个平滑的移动效果。 使用Scroller类实现滑动效果需要以下几个步骤： 初始化Scroller 1mScroller = new Scroller(context); 重写computeScroll()方法，实现平滑移动 系统绘制View的时候会在draw()方法中调用computeScroll()方法，可以在computeScroll()中使用scrollTo()方法进行小的偏移量的移动，接着调用invalidate()方法触发draw()方法，形成一个循环过程，最终实现平滑移动。示例代码如下： 12345678910@Overridepublic void computeScroll() &#123; super.computeScroll(); // 判断Scroller是否执行完毕 if (mScroller.computeScrollOffset()) &#123; ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 通过重绘不断调用computeScroll()，达到平滑移动的效果 invalidate(); &#125;&#125; Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动过程，用时提供了getCurX()、getCurY()方法获取当前的滑动坐标。 执行startScroll()方法，执行滑动过程 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取触摸点坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录当前触摸点坐标 lastX = x; lastY = y; return true; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 执行滑动过程 View viewGroup = (View) getParent(); mScroller.startScroll(viewGroup.getScrollX(), viewGroup.getScrollY(), -offsetX, -offsetY, 0); // 通过重绘首次触发computeScroll() invalidate(); return true; &#125; return super.onTouchEvent(event);&#125; 通常使用getScrollX()和getScrollY()方法获取滑动的起始坐标，由于是父视图在滑动，因此，偏移值的正负情况与scrollTo、scrollBy方法相同。同时，需要注意调用invalidate()触发computeScroll()方法进行滑动过程。 ViewDragHelperAndroid的Support库中提供了DrawerLayout和SlidingPaneLayout方便实现侧滑菜单的效果，这两个布局就是通过ViewDragHelper类实现的。通过ViewDragHelper类，基本可以实现各种不同的Scroll、Drag需求。 ViewDragHelper功能比较强大，使用也相对比较复杂，具体使用可以搜索相关资料，这里就不详细介绍了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>滑动效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动实现原理]]></title>
    <url>%2F2017%2F12%2F26%2F%E6%BB%91%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[滑动的产生View的滑动，本质上是移动View，即改变View所处的位置，这点和动画效果类似，都是通过不断改变View的坐标来实现的。 因此，要产生滑动效果，需要监听用户的触摸事件，根据事件的坐标信息不断改变View的坐标，使View跟随用户的触摸进行移动。 滑动是相对的移动，要实现滑动，就必须了解Android系统中的坐标体系和触摸事件(MotionEvent)，接下来对坐标体系和触摸事件进行说明。 系统坐标系Android系统的坐标系如下图所示： 系统提供了getLocationOnScreen()方法获取View在系统坐标系的位置，即该View左上角在系统坐标系的位置。 触摸事件中触摸点的系统坐标使用getRawX()和getRawY()方法获取。 视图坐标系除了系统坐标系，Android中还有视图坐标系，它用来描述子View在父View中的位置，系统坐标系如下图所示： 触摸事件中触摸点的视图坐标使用getX()和getY()方法获取。 触摸事件与坐标系触摸事件MotionEvent中封装了常用的事件常量，这些常量定义了不同的类型的触摸事件，可以使用getAction()方法获取。 下面用一幅图来描述一些获取坐标值和相对距离的常用API：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>滑动效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件拦截机制]]></title>
    <url>%2F2017%2F12%2F21%2F%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在对控件进行测量、布局、绘制一系列工作后，想要让控件与用户进行交互，就需要涉及到Android的事件拦截机制。Android系统提供了一套完善的事件分发、拦截、处理机制，让控件能够对用户输入的事件进行准确的响应和处理。 触摸事件Android中使用MotionEvent类代表一个触摸事件，比如用户的点击、滑动事件，从MotionEvent类中，可以获取事件的类型、点击坐标等一系列信息。 事件拦截机制分析在描述事件拦截机制前，要明确Android的视图是树结构。树结构具有层次，一个事件会从顶层逐步向低层进行分发。如果处于上层的ViewGroup要对事件进行处理，首先要对事件进行拦截，然后再进行处理；如果不进行处理，那么需要把事件分发到底层的View或者ViewGroup。如果底层的View处理了事件，那么这个事件的生命周期就结束了，否则，这个事件还要沿着原路向上层传递。这时，上层ViewGroup可以选择对事件进行处理，或者继续向上层传递，直到事件被处理为止。 以上分析可以用下面的流程图来表示： 事件处理的关键方法当控件想要分发一个事件时，会调用dispatchTouchEvent()方法。如果返回true，表示控件完成了这个事件的分发工作；如果返回false，表示事件分发工作未完成，事件将交由上层控件处理。 当控件想要拦截一个事件时，会调用onInterceptTouchEvent()方法。只有ViewGroup才拥有该方法，因为父控件只能是ViewGroup。当父控件要对分发到子控件的事件进行处理时，就需要调用此方法，如果返回true，表示父控件拦截了这个事件；如果返回false，父控件不对事件进行拦截，将把事件分发到子控件。 当控件想要处理一个事件时，会调用onTouchEvent()方法。在这个方法中，可以根据MotionEvent类提供的信息做相应的操作。操作完毕后，如果返回true，表示事件被处理了，该事件就结束了；如果返回false，表示事件没有被处理，事件将交由上层控件，直到被处理为止。 下面使用时序图描述一个事件处理的实例：父控件将事件分发给控件，控件接着将事件分发给子控件，然而子控件没有处理事件，把事件返还给了控件，最后控件自己处理了这个事件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View和ViewGroup]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%92%8CViewGroup%2F</url>
    <content type="text"><![CDATA[自定义View在自定义View时，通常需要重写onDraw()方法绘制View的显示内容；如果需要使用wrap_content属性，还需要重写onMeasure()方法进行测量；另外，还可以在attrs.xml文件中为View自定义属性。 在View中通常用到的回调方法有： onFinishInflate()从XML文件中加载控件后调用； onSizeChanged()控件大小改变时调用； onMeasure()测量控件大小时调用 onLayout()确定控件显示位置时调用 onDraw()绘制控件时调用； onTouchEvent()监听触摸事件时调用； 在自定义View的时候，只需要重写特点条件的回调方法。 通常情况下，自定义View有三种方式：对现有View进行扩展、创建复合View、自定义新的View。 对现有View进行扩展这种方式是在原生View的基础上进行扩展，比如修改显示的效果、增加新的功能等。 通常可以在onDraw()方法中，对原生View进行扩展。 创建复合View这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，从而组合成新的复合View。 对于复合View，一般会给它指定一些自定义属性，让其具有更强的扩展性。 自定义新的View当原生View无法满足需求时，可以通过继承View，自定义一个新的View。 自定义新的View，最重要的是绘制View和实现交互。绘制逻辑需要重写onDraw()和onMeasure()方法，交互逻辑需要重写onTouchEvent()等控制触控事件的方法。还可以像实现复合View那样，为新的View配置自定义属性，丰富自定义View的可定制性。 自定义ViewGroupViewGroup用于管理一组子View，将子View放到合适的位置，并为其添加响应事件。 自定义ViewGroup通常需要重写onMeasure()方法对子View进行测量，重写onLayout()方法确定子View的位置，重写onTouchEvent()方法为子View设置响应事件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件的测量和绘制]]></title>
    <url>%2F2017%2F12%2F20%2F%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%B5%8B%E9%87%8F%E5%92%8C%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[View的测量Android系统在绘制View前，要对View进行测量，告诉系统View的大小，这个过程是在View的onMeasure()方法中进行的。 具体测量View是通过MeasureSpec类，测量模式有一下三种： EXACTLY当控件的layout_width和layout_height属性为具体数值，或者被指定为match_parent时，使用的就是该模式； AT_MOST当控件的layout_width和layout_height属性被指定为wrap_content时使用，这时控件的大小会随着子控件的大小变化，同时控件的尺寸不允许超过父控件的最大尺寸； UNSPECIFIED在这个模式下，View大小可以随意指定，通常在绘制自定义View的时候使用； MeasureSpec类除了指定View的测量模式外，还指定了对应测量模式下View的尺寸。 MeasureSpec是一个32位的int值，其中高2位为测量的模式，低30位为测量的大小，为了提高运算效率，具体获取模式和大小的时候使用位运算。 View的默认onMeasure()方法只支持EXACTLY模式，如果想让View支持wrap_content属性，需要重写onMeasure()方法，指定AT_MOST模式下View的大小。 View的绘制View测量完毕后，需要重写onDraw()方法，在其Canvas对象上使用Paint对象绘制所需的图形。可以把Canvas对象看作成一块画板，Paint对象看作画笔，然后在onDraw()方法中进行绘制操作。 调用Canvas的drawXXX()方法绘制图形、文字、图片等，对于复杂的控件，可以把其拆分为一个个小的图形单元分别绘制。 ViewGroup的测量和布局ViewGroup在测量时，会遍历所有的子View，调用子View的measure()方法获取每个子View的测量结果，这时子View会调用onMeasure()方法进行测量。 当子View测量完毕后，还需要把子View放到合适的位置，这个过程就是View的布局过程。ViewGroup在执行布局过程时，同样会遍历调用子View的layout()方法，然后子View调用onLayout()方法进行具体的布局过程。 在自定义ViewGroup时，通常需要重写onLayout()方法来控制其子View的显示位置。类似于View，如果需要支持wrap_content属性，也需要重写onMeasure()方法。 ViewGroup的绘制ViewGroup通常不需要绘制，因为其本身没有需要绘制的内容，如果不指定背景颜色，ViewGroup的onDraw()方法都不会被调用。但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，这个过程也会遍历所有的子View，并调用子View的draw()方法完成绘制工作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件架构]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[控件树Android中的控件可以分为View控件和ViewGroup控件两类，一个ViewGroup控件可以包含多个View控件，这样就形式了一棵控件树： 控件树中的上层父控件负责下层子控件的测量和绘制，并且传递交互事件给子控件。 每个子控件都包含一个指向父控件的ViewParent对象，ViewParent对象专门负责管理与父控件的交互事件，从而对整个视图进行控制。 Activity中的findViewById()方法就是在控件树中，以DFS来查找对应的控件的。 界面架构每个Activity都包含一个Window对象，具体由PhoneWindow实现，PhoneWindow将DecorView设置为Window的顶层View。 DecorView将屏幕分为：StatusBar、DecorContent、NavigationBar三部分，DecorContent又包含ActionBar和ContentView两部分。 Activity就是通过setContentView()方法将布局内容加载到ContentView中的。 从界面架构图可以看出，ActionBar和ContentView都是在DecorView中进行绘制的，如果使用requestWindowFeature()方法设置全屏显示，那么需要在setContentView()方法调用之前进行。 视图树通过AS的Layout Inspector工具，可以直观的看到一棵标准的视图树： 视图树中的结构和上面描述的界面架构基本上能够对应上，只是多了一个action_mode_bar_stub，这个ViewStub对象主要用于绘制ActionMode状态下的ActionBar区域。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在网上浏览技术文章的时候，经常看到有人把文章发布到自己的个人博客上，感觉挺高端的，在查阅了相关资料后，也搭建了自己的个人博客，这篇文章就是我搭建个人博客的总结。 注意 本文主要是针对Windows环境，在Mac环境除了软件安装方式和命令有所区别外，其它基本一样。 创建域名和空间创建GitHub域名博客是托管在GitHub上的，首先要注册GitHub账号，注册的时候注意username，因为GitHub域名将是username.github.io，注册完毕后，GitHub域名也就创建了。 创建Blog存储空间Blog本质是一个网站，那么需要一个空间去存储网站的内容，这里使用GitHub的仓库(Repository)存储网站的内容，所以，需要在GitHub上创建一个仓库，Repository name就用上一步创建的域名：username.github.io，仓库创建完毕后，Blog存储空间也就创建了。 安装必要的工具Hexo是目前比较流行的博客框架，基于Node.js，可以使用 Markdown解析文章。要使用Hexo，需要安装Git，Node.js，Hexo工具。 安装GitGit用于把Hexo生成的本地网站内容提交到GitHub上，可以去Git官网下载安装程序进行安装，安装完毕后，需要在GitHub上配置SSH keys，具体配置方式可以参考Connecting to GitHub with SSH。 安装Node.jsNode.js是Hexo的运行环境，可以去Node.js官网下载安装程序进行安装，安装过程中，注意勾选Add to PATH选项。 安装Hexo在Git和Node.js安装完毕后，可在Git Bash中使用npm安装Hexo，由于Hexo的很多操作都涉及到命令行，可以考虑始终使用Git Bash来进行操作。 1$ npm install -g hexo-cli 创建网站和配置Hexo安装完毕后，接下来利用Hexo创建一个网站，并进行一些基本的配置。 创建网站执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 基本配置配置信息在网站的_config.yml文件中，可以根据需要进行配置，记得保存，注意配置的键值之间一定要有空格。 网站配置 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 你的名字 language 网站使用的语言 timezone 网站时区 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。下面附上我自己的配置，以供参考： 1234567# Sitetitle: Zhou Zejin&apos;s Homesubtitle: 想象力比知识更重要！description: Sunny的个人Blog，主要记录Android学习总结，欢迎交流~author: Zhou Zejinlanguage: zh-Hanstimezone: 其它配置可以参考更多配置。 部署配置这里只讲述Git的部署配置，其它方式的部署配置参考部署配置。 参数 描述 repo 库(Repository)地址 branch 分支名称 message 自定义提交信息 下面是我的部署配置： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:zhouzejin/zhouzejin.github.io.git 工作流程网站创建和配置完毕后，接着就可以撰写博客，并进行发布了。 新建1$ hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用_config.yml中的 default_layout 参数代替。如果标题包含空格，要使用引号括起来。 创建的文章在username.github.io/source/_posts目录下，默认是Markdown文件，在具体撰写博客前，可以学习一下Markdown语法。 测试1$ hexo server 启动本地服务器。默认情况下，访问网址为： http://localhost:4000/ 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 注意 上述方式如果无法启动Server，很大可能是默认端口4000被占用，可以更换其它端口重新启动 1$ hexo server -p 5000 服务器启动后，就可以浏览文章的排版和效果，如果不满意，可以直接修改文章对应的Markdown文件，修改完毕后，直接刷新就可以看到修改后的效果，不必重启Server。 发布使用Git发布需要先安装hexo-deployer-git插件（更多插件使用可以参考Hexo插件）： 1$ npm install hexo-deployer-git --save 发布前先要生成网站的静态文件： 1$ hexo generate 生成完毕后就可以进行发布： 1$ hexo deploy 生成和发布操作可以使用一个命令完成： 1$ hexo d -g 发布成功后，在浏览器输入username.github.io就可以进行访问了。 注意 在某些情况（尤其是更换主题后），如果发现对网站的更改无论如何也不生效，可以使用clean命令清除缓存文件(db.json)和已生成的静态文件(public)，然后再进行发布。 1$ hexo clean Hexo的更多使用可以参考Hexo官网文档 自定义主题经过以上步骤，个人博客就搭建完毕了，但是为让自己的博客更美观，可以更换默认主题，这里使用现在比较流行的NexT主题，如果需要使用其它主题，可以参考Hexo主题。 下面只对我自己用到的主题配置和第三方服务进行总结，更多配置和服务可以参考NexT使用文档。 主题安装下载主题在终端窗口下，定位到Hexo站点目录下。使用Git checkout代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在网站的_config.yml文件中，找到theme字段，并将其值更改为next： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题配置如果没有特殊说明，主题的配置都是在主题的_config.yml文件中进行的。 菜单配置每个菜单项目的配置都是类似的，接下来以配置about菜单进行说明： 在终端窗口下，定位到Hexo站点目录，创建一个名为about的页面 1hexo new page "about" 编辑分类页, 设置页面类型为about 123title: 关于date: 2017-11-24 16:00:52type: "about" 添加about到主题配置文件中menu字段下 123456789menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 配置完categories和tags菜单后，可以参考Hexo的Front-matter文档为文章添加分类和标签。 侧边栏配置 在移动设备上显示侧边栏 12# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true 设置头像 将头像放在网站目录下的source/uploads/路径，若uploads目录不存在则新建，然后在主题配置文件中进行如下配置： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/Sanji.jpg 添加社交链接 在主题配置文件下的social字段下，添加相应的社交链接即可： 12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 RSS配置安装hexo-generator-feed插件 1$ npm install hexo-generator-feed --save 安装成功后，就可以在侧边栏看到RSS订阅的标识了。 开启打赏功能只需要主题配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 网站footer个性化显示如果想自定义网站底部的信息，可以在主题配置文件进行如下配置： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false 设置「阅读全文」在主题配置文件中添加： 123auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定。 第三方服务可以为主题添加一些第三方服务来丰富网站的功能。 内容分享服务编辑主题配置文件，添加字段jiathis，值为true： 12# JiaThis 分享服务jiathis: true 搜索服务 安装hexo-generator-searchdb插件 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能 123# Local searchlocal_search: enable: true 参考资料 5分钟 搭建免费个人博客Hexo官方文档NexT使用文档]]></content>
      <categories>
        <category>方法和经验</category>
      </categories>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
</search>
